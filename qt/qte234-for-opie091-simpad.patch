--- src/kernel/qwsmouse_qws.cpp.orig    2003-01-31 04:34:52.000000000 +0100
+++ src/kernel/qwsmouse_qws.cpp 2003-03-10 12:26:40.000000000 +0100
@@ -61,12 +61,14 @@
 #endif
 
 #if defined(QT_QWS_IPAQ)
+#include <sys/time.h>
 #define QT_QWS_IPAQ_RAW
 typedef struct {
         unsigned short pressure;
         unsigned short x;
         unsigned short y;
         unsigned short pad;
+        struct timeval stamp;
 } TS_EVENT;
 #elif defined(QT_QWS_SL5XXX)
 #define QT_QWS_SL5XXX_RAW
@@ -1241,7 +1243,7 @@
 #if defined(QT_QWS_IPAQ) || defined(QT_QWS_SL5XXX)
 #if defined(QT_QWS_IPAQ)
 # ifdef QT_QWS_IPAQ_RAW
-    if ((mouseFD = open( "/dev/h3600_tsraw", O_RDONLY | O_NDELAY)) < 0) {
+    if ((mouseFD = open( "/dev/touchscreen/ucb1x00", O_RDONLY | O_NONBLOCK /*O_NDELAY*/)) < 0) {
 # else
     if ((mouseFD = open( "/dev/h3600_ts", O_RDONLY | O_NDELAY)) < 0) {
 # endif
--- src/kernel/qkeyboard_qws.cpp.orig	Sat May 24 16:49:38 2003
+++ src/kernel/qkeyboard_qws.cpp	Mon May 26 19:52:05 2003
@@ -131,6 +131,53 @@
 
 #endif // QNX6
 
+/*
+ * SIMpad switches handler
+ * (C) 2003 Michael 'Mickey' Lauer <mickey@tm.informatik.uni-frankfurt.de>
+ */
+
+//TODO: guard this against inclusion with #ifdef QT_QWS_SIMPAD
+
+#include <linux/switches.h>
+#define SIMPAD_SWITCHES_DEVICE "/dev/misc/switches"
+
+// switches from top to down over the SIMpad surface
+
+#define SIMPAD_SWITCH_UPPER 0x10
+
+#define SIMPAD_SWITCH_UP 0x20
+#define SIMPAD_SWITCH_DOWN 0x40
+#define SIMPAD_SWITCH_LEFT 0x80
+#define SIMPAD_SWITCH_RIGHT 0x100
+
+#define SIMPAD_SWITCH_LOWER 0x8
+
+class QWSsimpadButtonsHandler : public QWSKeyboardHandler
+{
+  Q_OBJECT
+
+  public:
+    QWSsimpadButtonsHandler();
+    virtual ~QWSsimpadButtonsHandler();
+
+    bool isOpen() { return fd > 0; }
+
+  private slots:
+    void readSwitchesData();
+    void autoRepeat();
+
+  private:
+    switches_mask_t switches;
+
+    int fd;
+    int repeatdelay;
+    int repeatperiod;
+    int k;
+
+    QTimer* repeater;
+    QSocketNotifier *notifier;
+};
+
 #ifdef QT_QWS_SL5XXX
 static const QWSServer::KeyMap keyM[] = {
     {	Qt::Key_unknown,	0xffff  , 0xffff  , 0xffff  }, // 00
@@ -396,7 +443,7 @@
        for the list of codes).
   <li>\a modifiers is the set of modifier keys (see Qt::Modifier).
   <li>\a isPress says whether this is a press or a release.
-  <li>\a autoRepeat says whether this event was generated by an auto-repeat
+  <li>\a time says whether this event was generated by an auto-repeat
 	    mechanism, or an actual key press.
   </ul>
 */
@@ -1440,7 +1486,11 @@
     } else {
 	type = spec;
     }
-
+    if ( type == "SIMpad" )
+    {
+        qDebug( "QWSKeyboardHandler: using SIMpad keyboard handler..." );
+        handler = new QWSsimpadButtonsHandler();
+    }
     if ( type == "Buttons" ) {
 #if defined(QT_QWS_YOPY)
 	handler = new QWSyopyButtonsHandler();
@@ -1469,6 +1519,103 @@
     return keyM;
 }
 
-#endif // QT_NO_QWS_KEYBOARD
+
+/*
+ * SIMpad switches handler
+ * (C) 2003 Michael 'Mickey' Lauer <mickey@tm.informatik.uni-frankfurt.de>
+ */
 
 
+QWSsimpadButtonsHandler::QWSsimpadButtonsHandler()
+                        :QWSKeyboardHandler(), fd( -1 ),
+                        repeatdelay( 400 ), repeatperiod( 80 )
+{
+    qDebug( "SimpadButtonsHandler()" );
+    fd = ::open( SIMPAD_SWITCHES_DEVICE, O_RDWR | O_NDELAY, 0 );
+    if ( fd < 0 )
+    {
+        qWarning( "SimpadButtonsHandler(): can't open %s", SIMPAD_SWITCHES_DEVICE );
+        return;
+    }
+
+    notifier = new QSocketNotifier( fd, QSocketNotifier::Read, this );
+    connect( notifier, SIGNAL( activated(int) ),this, SLOT( readSwitchesData() ) );
+
+    repeater = new QTimer(this);
+    connect(repeater, SIGNAL(timeout()), this, SLOT(autoRepeat()));
+
+}
+
+
+QWSsimpadButtonsHandler::~QWSsimpadButtonsHandler()
+{
+    qDebug( "~SimpadButtonsHandler()" );
+    if ( fd > 0 )
+    {
+        ::close( fd );
+        fd = -1;
+    }
+}
+
+
+void QWSsimpadButtonsHandler::readSwitchesData()
+{
+    qDebug( "SimpadButtonsHandler() - detected switches action" );
+
+    if ( ::read( fd, &switches, sizeof switches ) < 0 )
+    {
+        qWarning( "SimpadButtonsHandler() - switches read error!" );
+        return;
+    }
+
+    qDebug( "SimpadButtonsHandler() - SwitchEvent = %0x | %0x",
+            switches.events[0], switches.states[0] );
+
+    bool press = switches.states[0]; // == switches.event[0];
+    int code = switches.events[0];
+    k = -1;
+
+    switch(code)
+    {
+        case SIMPAD_SWITCH_UPPER: k = Qt::Key_Escape;   break;
+        case SIMPAD_SWITCH_UP:    k = Qt::Key_Up;       break;
+        case SIMPAD_SWITCH_DOWN:  k = Qt::Key_Down;     break;
+        case SIMPAD_SWITCH_LEFT:  k = Qt::Key_Left;     break;
+        case SIMPAD_SWITCH_RIGHT: k = Qt::Key_Right;    break;
+        case SIMPAD_SWITCH_LOWER: k = Qt::Key_Return;   break;
+        default: k=-1; qWarning( "SimpadButtonsHandler() - unhandled event!" ); break;
+    }
+
+    bool repeatable = ( k != SIMPAD_SWITCH_UPPER && k != SIMPAD_SWITCH_LOWER );
+
+    qDebug( "SimpadButtonsHandler() - Repeatable = %s", repeatable? "true":"false" );
+
+    if ( qt_screen->isTransformed() && k >= Qt::Key_Left && k <= Qt::Key_Down )
+    {
+        qDebug( "SimpadButtonsHandler() - We are transformed! Correcting..." );
+        int oldK = k;
+        k = xform_dirkey( k );
+        qDebug( "SimpadButtonsHandler() - Old Key: %d - New Key %d", oldK, k );
+    }
+
+    if ( repeatable && press )
+        repeater->start( repeatdelay, true );
+    else
+        repeater->stop();
+
+    if ( k >= 0 )
+    {
+        qwsServer->processKeyEvent( 0, k, 0, press, false );
+    }
+}
+
+
+void QWSsimpadButtonsHandler::autoRepeat()
+{
+    processKeyEvent( 0, k, 0, false, true );
+    processKeyEvent( 0, k, 0, true, true );
+    repeater->start(repeatperiod);
+}
+
+
+#endif // QT_NO_QWS_KEYBOARD
