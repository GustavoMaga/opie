This is a patch to mosfet's liquid 0.7.
Features:
 - Qt-only
 - works with Qt/E on QPE/OPIE
 
--- -	2002-11-21 20:45:47.000000000 +0100
+++ liquid.h	2002-11-18 03:32:40.000000000 +0100
@@ -2,7 +2,7 @@
 #define LIQUID_STYLE_H
 
 
-#include <kstyle.h>
+#include <qwindowsstyle.h>
 #include <qpainter.h>
 #include <qdrawutil.h>
 #include <qpalette.h>
@@ -20,7 +20,7 @@
  * Copyright (C)QPL 2001 Daniel M. Duley. All rights reserved.
  */
 
-class KPixmap;
+class QPixmap;
 
 #define BITMAP_ITEMS 41
 #define LIQUID_MENU_CHANGE 667
@@ -50,24 +50,22 @@
     ~TransMenuHandler(){;}
     void reloadSettings();
     int transType(){return(type);}
-    KPixmap *pixmap(WId id){return(pixDict.find(id));}
+    QPixmap *pixmap(WId id){return(pixDict.find(id));}
     const QColor& textColor(){return(fgColor);}
     const QColor& bgColor(){return(color);}
     bool useShadowText(){return(shadowText);}
-protected slots:
-    void slotKIPCMessage(int id, int arg);
 protected:
     bool eventFilter(QObject *obj, QEvent *ev);
-    void stripePixmap(KPixmap &pix, const QColor &color);
+    void stripePixmap(QPixmap &pix, const QColor &color);
 
     QColor color, fgColor;
     int opacity;
     int type;
     bool shadowText;
-    QIntDict<KPixmap>pixDict;
+    QIntDict<QPixmap>pixDict;
 };
 
-class LiquidStyle : public KStyle
+class LiquidStyle : public QWindowsStyle
 {
     friend class TransMenuHandler;
 public:
@@ -121,33 +119,14 @@
                     bool tickAbove, bool tickBelow);
     void drawSliderMask(QPainter *p, int x, int y, int w, int h,
                         Orientation orient, bool, bool);
-    void drawKToolBar(QPainter *p, int x, int y, int w, int h,
-                      const QColorGroup &g, KToolBarPos type,
-                      QBrush *fill=NULL);
-    void drawKBarHandle(QPainter *p, int x, int y, int w, int h,
-                        const QColorGroup &g,
-                        KToolBarPos type, QBrush *fill=NULL);
-    void drawKMenuBar(QPainter *p, int x, int y, int w, int h,
-                      const QColorGroup &g, bool macMode,
-                      QBrush *fill=NULL);
-    void drawKToolBarButton(QPainter *p, int x, int y, int w, int h,
-                            const QColorGroup &g, bool sunken=false,
-                            bool raised = true, bool enabled = true,
-                            bool popup = false,
-                            KToolButtonType icontext = Icon,
-                            const QString& btext=QString::null,
-                            const QPixmap *icon=NULL,
-                            QFont *font=NULL, QWidget *btn=NULL);
-    void drawKMenuItem(QPainter *p, int x, int y, int w, int h,
-                       const QColorGroup &g, bool active,
-                       QMenuItem *item, QBrush *fill=NULL);
+	void drawMenuBarItem(QPainter *p, int x, int y, int w, int h,
+                            QMenuItem *mi, QColorGroup &g, bool enabled, bool active );
+
     void drawPopupMenuItem(QPainter *p, bool checkable, int maxpmw,
                            int tab, QMenuItem *mi, const QPalette &pal,
                            bool act, bool enabled, int x, int y, int w,
                            int h);
     int popupMenuItemHeight(bool c, QMenuItem *mi, const QFontMetrics &fm);
-    void drawKProgressBlock(QPainter *p, int x, int y, int w, int h,
-                            const QColorGroup &g, QBrush *fill);
     void drawFocusRect(QPainter *p, const QRect &r, const QColorGroup &g,
                        const QColor *pen, bool atBorder);
     int defaultFrameWidth() const {return(2);}
@@ -167,12 +146,6 @@
     void drawToolButton(QPainter *p, int x, int y, int w,
                         int h, const QColorGroup &g,
                         bool sunken, const QBrush *fill);
-    void drawKickerAppletHandle(QPainter *p, int x, int y, int w, int h,
-                                const QColorGroup &g, QBrush *);
-    void drawKickerTaskButton(QPainter *p, int x, int y, int w, int h,
-                              const QColorGroup &g,
-                              const QString &title, bool active,
-                              QPixmap *icon, QBrush *fill);
     // for repainting toolbuttons when the toolbar is resized
     bool eventFilter(QObject *obj, QEvent *ev);
     void drawSliderGroove(QPainter * p, int x, int y, int w,  int h,
@@ -198,25 +171,15 @@
     void drawSBButton(QPainter *p, const QRect &r, const QColorGroup &g,
                       bool down=false, bool fast = true);
     void drawRoundRect(QPainter *p, int x, int y, int w, int h);
-    void loadCustomButtons();
-    void applyCustomAttributes(QPushButton *btn);
-    void unapplyCustomAttributes(QPushButton *btn);
     QPixmap* getPixmap(BitmapData item);
     QPixmap* processEmbedded(const char *label, int h, int s, int v, bool blend=false);
 private:
-    bool highcolor;
-    QColorGroup radioOnGrp;
+	bool oldqte;
+	bool flatTBButtons;
     QWidget *highlightWidget;
-    QBrush wallpaper;
-    QBitmap lightBmp;
-    QBitmap grayBmp;
-    QBitmap dgrayBmp;
-    QBitmap maskBmp;
-    QBitmap xBmp;
     QBitmap btnMaskBmp, htmlBtnMaskBmp;
     QPixmap *btnBorderPix, *btnBlendPix, *bevelFillPix, *smallBevelFillPix, *menuPix;
-    QBitmap paper1, paper2, paper3;
-    QBrush baseBrush, menuBrush, pagerBrush, pagerHoverBrush, bgBrush;
+    QBrush bgBrush, menuBrush;
     bool menuAni, menuFade;
 
     QIntDict<QPixmap>btnDict;
@@ -224,9 +187,6 @@
     QIntDict<QPixmap>bevelFillDict;
     QIntDict<QPixmap>smallBevelFillDict;
 
-    QList<QColor>customBtnColorList;
-    QList<QPixmap>customBtnIconList;
-    QStrList customBtnLabelList;
     QPixmap *vsbSliderFillPix;
     TransMenuHandler *menuHandler;
     QPixmap *pixmaps[BITMAP_ITEMS];
--- -	2002-11-21 20:45:47.000000000 +0100
+++ liquid.cpp	2002-11-21 20:27:48.000000000 +0100
@@ -2,6 +2,9 @@
  * Copyright (C)QPL 2001 Daniel M. Duley. All rights reserved.
  */
 
+//
+// (c) 2002 Robert 'sandman' Griebl 
+//
 
 
 #ifndef INCLUDE_MENUITEM_DEF
@@ -10,12 +13,10 @@
 
 #include <qmenudata.h>
 #include "liquid.h"
-#include <kapp.h>
-#include <kglobal.h>
-#include <kconfig.h>
-#include <kdrawutil.h>
-#include <kglobalsettings.h>
-#include <kpixmapeffect.h>
+//#include "liquiddeco.h"
+#include <qapplication.h>
+#include <qpe/config.h>
+#include "effects.h"
 #include <qpalette.h>
 #include <qbitmap.h>
 #include <qtabbar.h>
@@ -25,28 +26,30 @@
 #include <qtimer.h>
 #include <qpixmapcache.h>
 #include <qradiobutton.h>
-#include <kimageeffect.h>
-#include <ktoolbar.h>
+#include <qcombobox.h>
 #include <qdrawutil.h>
 #include <qwidgetlist.h>
 #include <qtoolbutton.h>
 #include <qheader.h>
 #include <unistd.h>
-#include <klocale.h>
-#include <kiconloader.h>
-#include <kmenubar.h>
-#include <kipc.h>
+#include <qmenubar.h>
+#include <qprogressbar.h>
+#include <qlineedit.h>
 
-#include <X11/X.h>
-#include <X11/Xlib.h>
+#include <stdio.h>
 
 #include "htmlmasks.h"
 #include "embeddata.h"
 
-void TransMenuHandler::stripePixmap(KPixmap &pix, const QColor &color)
+typedef void (QStyle::*QDrawMenuBarItemImpl) (QPainter *, int, int, int, int, QMenuItem *,
+                          QColorGroup &, bool, bool);
+
+QDrawMenuBarItemImpl qt_set_draw_menu_bar_impl(QDrawMenuBarItemImpl impl);
+
+void TransMenuHandler::stripePixmap(QPixmap &pix, const QColor &color)
 {
     QImage img(pix.convertToImage());
-    KImageEffect::fade(img, 0.9, color);
+    QImageEffect::fade(img, 0.9, color);
     int x, y;
     int r, g, b;
     for(y=0; y < img.height(); y+=3){
@@ -71,35 +74,37 @@
     : QObject(parent)
 {
     pixDict.setAutoDelete(true);
-    connect(kapp, SIGNAL(kipcMessage(int, int)), this,
-            SLOT(slotKIPCMessage(int, int)));
     reloadSettings();
 }
 
 void TransMenuHandler::reloadSettings()
 {
     pixDict.clear();
-    KConfig *config = KGlobal::config();
-    config->setGroup("MosfetMenus");
 
-    type = config->readNumEntry("Type", TransStippleBg);
-    color = config->readColorEntry("Color",
-                                   &QApplication::palette().active().button());
-    fgColor = config->readColorEntry("TextColor",
-                                     &QApplication::palette().active().text());
-    opacity = config->readNumEntry("Opacity", 10);
-    shadowText = config->readBoolEntry("ShadowText", true);
+    Config config ( "qpe" );
+    config. setGroup ( "Liquid-Style" );
+
+    type = config. readNumEntry("Type", TransStippleBg);
+    color = QColor ( config. readEntry("Color",  QApplication::palette().active().button().name()));
+    fgColor = QColor ( config. readEntry("TextColor", QApplication::palette().active().text().name()));
+    opacity = config. readNumEntry("Opacity", 10);
+    if ( opacity < -20 )
+    	opacity = 20;
+    else if ( opacity > 20 )
+    	opacity = 20;
+    
+    shadowText = config. readBoolEntry("ShadowText", true);
 }
 
 bool TransMenuHandler::eventFilter(QObject *obj, QEvent *ev)
 {
-    QPopupMenu *p = (QPopupMenu *)obj;
+    QWidget *p = (QWidget *)obj;
 
     if(ev->type() == QEvent::Show){
         if(type == TransStippleBg || type == TransStippleBtn ||
            type == Custom){
             QApplication::syncX();
-            KPixmap *pix = new KPixmap;
+            QPixmap *pix = new QPixmap;
             if(p->testWFlags(Qt::WType_Popup)){
                 QRect r(p->x(), p->y(), p->width(), p->height());
                 QRect deskR = QApplication::desktop()->rect();
@@ -107,7 +112,7 @@
                     r.setBottom(deskR.bottom());
                     r.setRight(deskR.right());
                 }
-                *pix = QPixmap::grabWindow(qt_xrootwin(), r.x(), r.y(),
+                *pix = QPixmap::grabWindow(QApplication::desktop()-> winId(), r.x(), r.y(),
                                            r.width(), r.height());
             }
             else{ // tear off menu
@@ -121,82 +126,61 @@
                 stripePixmap(*pix, p->colorGroup().button());
             }
             else{
-                KPixmapEffect::fade(*pix, (((float)opacity)+80)*0.01, color);
+                QPixmapEffect::fade(*pix, (((float)opacity)+80)*0.01, color);
             }
+
             pixDict.insert(p->winId(), pix);
+            
+            if ( !p->inherits("QPopupMenu")) 
+            	p->setBackgroundPixmap(*pix);
+            	
+            QObjectList *ol = p-> queryList("QWidget");
+			for ( QObjectListIt it( *ol ); it. current ( ); ++it ) {
+				QWidget *wid = (QWidget *) it.current ( );
+					
+				wid-> setBackgroundPixmap(*pix);
+			   	wid-> setBackgroundOrigin(QWidget::ParentOrigin);					
+            }
+			delete ol;
         }
     }
     else if(ev->type() == QEvent::Hide){
         if(type == TransStippleBg || type == TransStippleBtn ||
            type == Custom){
-            qWarning("Deleting menu pixmap, width %d", pixDict.find(p->winId())->width());
-            pixDict.remove(p->winId());
-        }
-    }
-    return(false);
-}
-
-void TransMenuHandler::slotKIPCMessage(int id, int)
-{
-    if(id == LIQUID_MENU_CHANGE){
-        bool oldShadow = shadowText;
-
-        KConfig *config = KGlobal::config();
-        config->reparseConfiguration(); // in case KControl changed values
+//            qWarning("Deleting menu pixmap, width %d", pixDict.find(p->winId())->width());
 
-        // Make sure no popupmenus are shown. There shouldn't be any because
-        // the user just clicked "Apply", but there can be tear offs ;-)
-        // We just close them so the pixmaps are deleted and regenerated.
-        QWidgetList *list = QApplication::topLevelWidgets();
-        QWidgetListIt it( *list );
-        QWidget *w;
-        while ((w=it.current()) != 0 ){
-            ++it;
-            if(w->inherits("QPopupMenu")){
-                w->close();
-            }
-        }
+            pixDict.remove(p->winId());
+            if ( !p->inherits("QPopupMenu")) 
+                p->setBackgroundMode(QWidget::PaletteBackground);
 
-        reloadSettings();
+          	QObjectList *ol = p-> queryList("QWidget");
+			for ( QObjectListIt it( *ol ); it. current ( ); ++it ) {
+				QWidget *wid = (QWidget *) it.current ( );
 
-        // Now repaint menubar if needed
-        if(shadowText != oldShadow){
-            it.toFirst();
-            while ((w=it.current()) != 0 ){
-                ++it;
-                if(w->inherits("QMenuBar")){
-                    w->repaint();
+				wid-> setBackgroundMode( QWidget::PaletteBackground );
                 }
+			delete ol;
             }
         }
-    }
-    else if(id == MOSFET_BUTTON_CHANGE){
-        qWarning("In mosfet button change");
-        // really, this should be in LiquidStyle, but what the hell? ;-)
-        QWidgetList *list = QApplication::allWidgets();
-        QWidgetListIt it( *list );
-        QWidget *w;
-        while ((w=it.current()) != 0 ){
-            ++it;
-            if(w->inherits("QPushButton")){
-                ((LiquidStyle*)parent())->unapplyCustomAttributes((QPushButton *)w);
-            }
-        }
-        ((LiquidStyle*)parent())->loadCustomButtons();
-        it.toFirst();
-        while ((w=it.current()) != 0 ){
-            ++it;
-            if(w->inherits("QPushButton")){
-                ((LiquidStyle*)parent())->applyCustomAttributes((QPushButton *)w);
-            }
-        }
+    return(false);
+}
 
-    }
+
+static int qt_version ( )
+{
+	const char *qver = qVersion ( );
+	return ( qver [0] - '0' ) * 100 + ( qver [2] - '0' ) * 10 + ( qver [4] - '0' );
 }
 
+
 LiquidStyle::LiquidStyle()
-    :KStyle()
+    :QWindowsStyle()
 {
+    setName ( "LiquidStyle" );
+
+	oldqte = ( qt_version ( ) < 234 );
+	flatTBButtons = false;
+
     btnMaskBmp = QBitmap(37, 26, buttonmask_bits, true);
     btnMaskBmp.setMask(btnMaskBmp);
     htmlBtnMaskBmp = QBitmap(37, 26, htmlbuttonmask_bits, true);
@@ -207,12 +191,8 @@
     btnDict.setAutoDelete(true);
     bevelFillDict.setAutoDelete(true);
     smallBevelFillDict.setAutoDelete(true);
-    customBtnColorList.setAutoDelete(true);
-    customBtnIconList.setAutoDelete(true);
-    customBtnLabelList.setAutoDelete(true);
 
     rMatrix.rotate(270.0);
-    highcolor = QPixmap::defaultDepth() > 8;
     btnBorderPix = new QPixmap;
     btnBorderPix->convertFromImage(qembed_findImage("buttonfill"));
     btnBlendPix = new QPixmap;
@@ -572,131 +552,119 @@
     case HTMLBtnBorderDown:
         pixmaps[HTMLBtnBorderDown] = processEmbedded("htmlbtnborder", btnHoverH, btnHoverS, btnHoverV);
         break;
+
     case HTMLCB:
         pixmaps[HTMLCB] = processEmbedded("htmlcheckbox", bH, bS, bV);
         break;
+    case HTMLCBHover:
+        pixmaps[HTMLCBHover] = processEmbedded("htmlcheckbox", btnHoverH, btnHoverS, btnHoverV);
+        break;
     case HTMLCBDown:
         pixmaps[HTMLCBDown] = processEmbedded("htmlcheckboxdown", btnH, btnS, btnV);
         break;
-    case HTMLCBHover:
-        pixmaps[HTMLCBHover] = processEmbedded("htmlcheckbox", btnH, btnS, btnV);
-        break;
     case HTMLCBDownHover:
-        pixmaps[HTMLCBDownHover] = processEmbedded("htmlcheckboxdown",
-                                                   btnHoverH, btnHoverS,
-                                                   btnHoverV);
+        pixmaps[HTMLCBDownHover] = processEmbedded("htmlcheckboxdown", btnHoverH, btnHoverS, btnHoverV);
         break;
+
     case HTMLRadio:
         pixmaps[HTMLRadio] = processEmbedded("htmlradio", bH, bS, bV);
+		break;
+    case HTMLRadioHover:
+        pixmaps[HTMLRadioHover] = processEmbedded("htmlradio", btnHoverH, btnHoverS, btnHoverV);
+		break;
     case HTMLRadioDown:
         pixmaps[HTMLRadioDown] = processEmbedded("htmlradiodown", btnH, btnS, btnV);
-    case HTMLRadioHover:
-        pixmaps[HTMLRadioHover] = processEmbedded("htmlradio", btnH, btnS, btnV);
+		break;
     case HTMLRadioDownHover:
-        pixmaps[HTMLRadioDownHover] = processEmbedded("htmlradiodown", 
-                                                      btnHoverH, btnHoverS,
-                                                      btnHoverV);
+        pixmaps[HTMLRadioDownHover] = processEmbedded("htmlradiodown", btnHoverH, btnHoverS, btnHoverV);
+		break;
+
+    case RadioOff:
+        pixmaps[RadioOff] = processEmbedded("radio", bH, bS, bV /*, true*/);
+        break;
+    case RadioOffHover:
+        pixmaps[RadioOffHover] = processEmbedded("radio", btnHoverH, btnHoverS, btnHoverV /*, true*/);
+        break;
     case RadioOn:
-        pixmaps[RadioOn] = processEmbedded("radio_down", btnH, btnS, btnV, true);
+        pixmaps[RadioOn] = processEmbedded("radio_down", btnH, btnS, btnV /*, true*/);
         break;
     case RadioOnHover:
-        pixmaps[RadioOnHover] = processEmbedded("radio_down", btnHoverH, btnHoverS,
-                                                btnHoverV, true);
+        pixmaps[RadioOnHover] = processEmbedded("radio_down", btnHoverH, btnHoverS, btnHoverV /*, true*/);
         break;
-    case RadioOffHover:
-        pixmaps[RadioOffHover] = processEmbedded("radio", btnH, btnS, btnV, true);
+
+    case Tab:
+        pixmaps[Tab] = processEmbedded("tab", bH, bS, bV /*, true*/);
         break;
     case TabDown:
-        pixmaps[TabDown] = processEmbedded("tab", btnH, btnS, btnV, true);
+        pixmaps[TabDown] = processEmbedded("tab", btnH, btnS, btnV /*, true*/);
         break;
     case TabFocus:
-        pixmaps[TabFocus] = processEmbedded("tab", btnHoverH, btnHoverS,
-                                            btnHoverS, true);
-        break;
-    case CBDown:
-        pixmaps[CBDown] = processEmbedded("checkboxdown", btnH, btnS, btnV, true);
+        pixmaps[TabFocus] = processEmbedded("tab", btnHoverH, btnHoverS, btnHoverV /*, true*/);
         break;
-    case CBDownHover:
-        pixmaps[CBDownHover] = processEmbedded("checkboxdown", btnHoverH,
-                                               btnHoverS, btnHoverV, true);
+
+	case CB:
+        pixmaps[CB] = processEmbedded("checkbox", bH, bS, bV /*, true*/);
         break;
     case CBHover:
-        pixmaps[CBHover] = processEmbedded("checkbox", btnH, btnS, btnV, true);
+        pixmaps[CBHover] = processEmbedded("checkbox", btnHoverH, btnHoverS, btnHoverV /*, true*/);
         break;
-    case HSlider:
-        pixmaps[HSlider] = processEmbedded("sliderarrow", btnH, btnS, btnV, true);
+    case CBDown:
+        pixmaps[CBDown] = processEmbedded("checkboxdown", btnH, btnS, btnV /*, true*/);
+        break;
+    case CBDownHover:
+        pixmaps[CBDownHover] = processEmbedded("checkboxdown", btnHoverH, btnHoverS, btnHoverV /*, true*/);
         break;
+
     case VSlider:
-        pixmaps[VSlider] = processEmbedded("sliderarrow", btnH, btnS, btnV, true);
+        pixmaps[VSlider] = processEmbedded("sliderarrow", btnH, btnS, btnV, true );
         *pixmaps[VSlider] = pixmaps[VSlider]->xForm(rMatrix);
         break;
-    case RadioOff:
-        pixmaps[RadioOff] = processEmbedded("radio", bH, bS, bV, true);
-        break;
-    case Tab:
-        pixmaps[Tab] = processEmbedded("tab", bH, bS, bV, true);
-        break;
-    case CB:
-        pixmaps[CB] = processEmbedded("checkbox", bH, bS, bV, true);
-        break;
     case VSBSliderTop:
-        pixmaps[VSBSliderTop] = processEmbedded("sbslider_top", btnH, btnS, btnV, true);
+    case VSBSliderTopHover:
+        pixmaps[item] = processEmbedded("sbslider_top", btnH, btnS, btnV /*, true*/);
         break;
     case VSBSliderBtm:
-        pixmaps[VSBSliderBtm] = processEmbedded("sbslider_btm", btnH, btnS, btnV, true);
+    case VSBSliderBtmHover:
+        pixmaps[item] = processEmbedded("sbslider_btm", btnH, btnS, btnV /*, true*/);
         break;
     case VSBSliderMid:
-        pixmaps[VSBSliderMid] = processEmbedded("sbslider_mid", btnH, btnS, btnV);
+    case VSBSliderMidHover:
+        pixmaps[item] = processEmbedded("sbslider_mid", btnH, btnS, btnV);
         break;
-    case VSBSliderTopHover:
-        pixmaps[VSBSliderTopHover] = processEmbedded("sbslider_top", btnHoverH, btnHoverS, btnHoverV, true);
+	case VSBSliderTopBg:
+        pixmaps[VSBSliderTopBg] = processEmbedded("sbslider_top", bH, bS, bV /*, true*/);
         break;
-    case VSBSliderBtmHover:
-        pixmaps[VSBSliderBtmHover] = processEmbedded("sbslider_btm", btnHoverH, btnHoverS, btnHoverV, true);
+    case VSBSliderBtmBg:
+        pixmaps[VSBSliderBtmBg] = processEmbedded("sbslider_btm", bH, bS, bV /*, true*/);
         break;
-    case VSBSliderMidHover:
-        pixmaps[VSBSliderMidHover] = processEmbedded("sbslider_mid", btnHoverH, btnHoverS, btnHoverV);
+    case VSBSliderMidBg:
+        pixmaps[VSBSliderMidBg] = processEmbedded("sbslider_mid", bH, bS, bV);
         break;
 
-    case HSBSliderTop:
-        pixmaps[HSBSliderTop] = processEmbedded("sbslider_top", btnH, btnS, btnV, true);
-        *pixmaps[HSBSliderTop] = pixmaps[HSBSliderTop]->xForm(rMatrix);
-        break;
-    case HSBSliderBtm:
-        pixmaps[HSBSliderBtm] = processEmbedded("sbslider_btm", btnH, btnS, btnV, true);
-        *pixmaps[HSBSliderBtm] = pixmaps[HSBSliderBtm]->xForm(rMatrix);
-        break;
-    case HSBSliderMid:
-        pixmaps[HSBSliderMid] = processEmbedded("sbslider_mid", btnH, btnS, btnV);
-        *pixmaps[HSBSliderMid] = pixmaps[HSBSliderMid]->xForm(rMatrix);
+	case HSlider:
+        pixmaps[HSlider] = processEmbedded("sliderarrow", btnH, btnS, btnV /*, true*/);
         break;
+    case HSBSliderTop:
     case HSBSliderTopHover:
-        pixmaps[HSBSliderTopHover] = processEmbedded("sbslider_top", btnHoverH, btnHoverS, btnHoverV, true);
-        *pixmaps[HSBSliderTopHover] = pixmaps[HSBSliderTopHover]->xForm(rMatrix);
+        pixmaps[item] = processEmbedded("sbslider_top", btnH, btnS, btnV, true );
+        *pixmaps[item] = pixmaps[item]->xForm(rMatrix);
         break;
+    case HSBSliderBtm:
     case HSBSliderBtmHover:
-        pixmaps[HSBSliderBtmHover] = processEmbedded("sbslider_btm", btnHoverH, btnHoverS, btnHoverV, true);
-        *pixmaps[HSBSliderBtmHover] = pixmaps[HSBSliderBtmHover]->xForm(rMatrix);
+        pixmaps[item] = processEmbedded("sbslider_btm", btnH, btnS, btnV, true );
+        *pixmaps[item] = pixmaps[item]->xForm(rMatrix);
         break;
+    case HSBSliderMid:
     case HSBSliderMidHover:
-        pixmaps[HSBSliderMidHover] = processEmbedded("sbslider_mid", btnHoverH, btnHoverS, btnHoverV);
-        *pixmaps[HSBSliderMidHover] = pixmaps[HSBSliderMidHover]->xForm(rMatrix);
-        break;
-    case VSBSliderTopBg:
-        pixmaps[VSBSliderTopBg] = processEmbedded("sbslider_top", bH, bS, bV, true);
-        break;
-    case VSBSliderBtmBg:
-        pixmaps[VSBSliderBtmBg] = processEmbedded("sbslider_btm", bH, bS, bV, true);
-        break;
-    case VSBSliderMidBg:
-        pixmaps[VSBSliderMidBg] = processEmbedded("sbslider_mid", bH, bS, bV);
+        pixmaps[item] = processEmbedded("sbslider_mid", btnH, btnS, btnV);
+        *pixmaps[item] = pixmaps[item]->xForm(rMatrix);
         break;
     case HSBSliderTopBg:
-        pixmaps[HSBSliderTopBg] = processEmbedded("sbslider_top", bH, bS, bV, true);
+        pixmaps[HSBSliderTopBg] = processEmbedded("sbslider_top", bH, bS, bV, true );
         *pixmaps[HSBSliderTopBg] = pixmaps[HSBSliderTopBg]->xForm(rMatrix);
         break;
     case HSBSliderBtmBg:
-        pixmaps[HSBSliderBtmBg] = processEmbedded("sbslider_btm", bH, bS, bV, true);
+        pixmaps[HSBSliderBtmBg] = processEmbedded("sbslider_btm", bH, bS, bV, true );
         *pixmaps[HSBSliderBtmBg] = pixmaps[HSBSliderBtmBg]->xForm(rMatrix);
         break;
     case HSBSliderMidBg:
@@ -711,7 +679,6 @@
 
 void LiquidStyle::polish(QPalette &appPal)
 {
-
     int i;
     for(i=0; i < BITMAP_ITEMS; ++i){
         if(pixmaps[i]){
@@ -719,31 +686,28 @@
             pixmaps[i] = NULL;
         }
     }
-    QWidgetList *list = QApplication::allWidgets();
-    QWidgetListIt it( *list );
-    QWidget *w;
-    while ((w=it.current()) != 0 ){
-        ++it;
-        if(w->inherits("QPushButton")){
-            unapplyCustomAttributes((QPushButton *)w);
-        }
-    }
-
-    loadCustomButtons();
-    lowLightVal = 100 + (2*KGlobalSettings::contrast()+4)*10;
+    lowLightVal = 100 + (2* /*KGlobalSettings::contrast()*/ 3 +4)*10;
     btnDict.clear();
     btnBorderDict.clear();
     bevelFillDict.clear();
     smallBevelFillDict.clear();
 
-    KConfig *config = KGlobal::config();
-    QString oldGrp = config->group();
-    QPalette pal = QApplication::palette();
+    Config config ( "qpe" );
+    config. setGroup ( "Liquid-Style" );
+	int contrast = config. readNumEntry ( "StippleContrast", 5 );
+	if ( contrast < 0 )
+		contrast = 0;
+	else if ( contrast > 10 )
+		contrast = 10;
+
+//    QPalette pal = QApplication::palette();
 
     // button color stuff
-    config->setGroup("General");
-    QColor c = config->readColorEntry("buttonBackground", &Qt::lightGray);
-    if(c == config->readColorEntry("background", &Qt::lightGray)){
+    config. setGroup ( "Appearance" );
+    QColor c = oldqte ? QColor ( config. readEntry("Button", ( Qt::lightGray ). name ( ))) 
+                      : appPal. color ( QPalette::Active, QColorGroup::Button );
+    if ( c == ( oldqte ?  QColor ( config. readEntry ( "background", ( Qt::lightGray ). name ( )))
+                       : appPal. color ( QPalette::Active, QColorGroup::Background ))) {
         // force button color to be different from background
         QBrush btnBrush(QColor(200, 202, 228));
         appPal.setBrush(QColorGroup::Button, btnBrush);
@@ -778,8 +742,8 @@
         adjustHSV(*pix, h, s, v);
         smallBevelFillDict.insert(c.rgb(), pix);
     }
-    pagerHoverBrush.setColor(c);
-    pagerHoverBrush.setPixmap(*pix);
+//    pagerHoverBrush.setColor(c);
+//    pagerHoverBrush.setPixmap(*pix);
 
     c = c.dark(120);
     pix = smallBevelFillDict.find(c.rgb()); // better be NULL ;-)
@@ -790,19 +754,13 @@
         adjustHSV(*pix, h, s, v);
         smallBevelFillDict.insert(c.rgb(), pix);
     }
-    pagerBrush.setColor(c);
-    pagerBrush.setPixmap(*pix);
+//    pagerBrush.setColor(c);
+//    pagerBrush.setPixmap(*pix);
 
     // background color stuff
-    c = config->readColorEntry("background", &Qt::lightGray);
-    if(qstrcmp(kapp->argv()[0], "kicker") == 0){
-        appPal.setColor(QColorGroup::Mid, menuBrush.color().dark(110));
-        appPal.setColor(QColorGroup::Dark, menuBrush.color().dark(130));
-        appPal.setColor(QColorGroup::Midlight, menuBrush.color().light(110));
-        appPal.setColor(QColorGroup::Light, menuBrush.color().light(115));
-        menuBrush.setColor(c); // hack - used for kicker applets
-        appPal.setBrush(QColorGroup::Background, menuBrush);
-    }
+    c = oldqte ? QColor ( config. readEntry ( "Background", ( Qt::lightGray ).name ( )))
+               : appPal. color ( QPalette::Active, QColorGroup::Background );
+
     c.hsv(&bH, &bS, &bV);
     c.light(120).hsv(&bHoverH, &bHoverS, &bHoverV);
 
@@ -817,101 +775,50 @@
     wallPaper.fill(c.rgb());
     painter.begin(&wallPaper);
     for(i=0; i < 32; i+=4){
-        painter.setPen(c.dark(105));
+        painter.setPen(c.dark(100 + contrast));
         painter.drawLine(0, i, 32, i);
-        painter.setPen(c.dark(103));
+        painter.setPen(c.dark(100 + 3 * contrast / 5 ) );
         painter.drawLine(0, i+1, 32, i+1);
     };
     painter.end();
     bgBrush.setColor(c);
     bgBrush.setPixmap(wallPaper);
-    if(qstrcmp(kapp->argv()[0], "kicker") != 0 &&
-       qstrcmp(kapp->argv()[0], "ksplash") != 0){
         appPal.setBrush(QColorGroup::Background, bgBrush);
-    }
-
-    // lineedits
-    c = config->readColorEntry("windowBackground", &Qt::white);
-    QPixmap basePix;
-    basePix.resize(32, 32);
-    basePix.fill(c.rgb());
-    painter.begin(&basePix);
-    painter.setPen(c.dark(105));
-    for(i=0; i < 32; i+=4){
-        painter.drawLine(0, i, 32, i);
-        painter.drawLine(0, i+1, 32, i+1);
-    };
-    painter.end();
-    baseBrush.setColor(c);
-    baseBrush.setPixmap(basePix);
-    it.toFirst();
-    while ((w=it.current()) != 0 ){
-        ++it;
-        if(w->inherits("QLineEdit")){
-            QPalette pal = w->palette();
-            pal.setBrush(QColorGroup::Base, baseBrush);
-            w->setPalette(pal);
-        }
-        else if(w->inherits("QPushButton")){
-            applyCustomAttributes((QPushButton *)w);
-        }
-    }
-
-    config->setGroup(oldGrp);
 }
 
 void LiquidStyle::polish(QWidget *w)
 {
     if(w->inherits("QMenuBar")){
-        ((QFrame*)w)->setLineWidth(0);
-        w->setBackgroundMode(QWidget::NoBackground);
+        //((QFrame*)w)->setLineWidth(0);
+        w->setBackgroundMode(QWidget::PaletteBackground);
+        w->setBackgroundOrigin(QWidget::ParentOrigin);
+        return;
+    }
+    if(w->inherits("QToolBar")){
+        w->installEventFilter(this);
+        w->setBackgroundMode(QWidget::PaletteBackground);
+        w->setBackgroundOrigin(QWidget::WidgetOrigin);
         return;
     }
     if(w->inherits("QPopupMenu"))
         w->setBackgroundMode(QWidget::NoBackground);
+    else if(w-> testWFlags(Qt::WType_Popup) && 
+            !w->inherits("QListBox") && 
+            ( qstrcmp ( w-> name(), "automatic what's this? widget" ) != 0 )) {
+    	w->installEventFilter(menuHandler);
+    }
 
     if(w->isTopLevel()){
-        if(!w->inherits("QPopupMenu") &&
-           qstrcmp(kapp->argv()[0], "kicker") == 0){
-            qWarning("Got panel toplevel %s", w->className());
-            // force extensions and child panels to use proper palette.
-            if(w->inherits("Panel")){
-                qWarning("Setting panel palette");
-                w->setPalette(kapp->palette());
-            }
-            else{
-                // reset palette for everything else
-                QPalette pal = kapp->palette();
-                pal.setBrush(QColorGroup::Background, bgBrush);
-                pal.setColor(QColorGroup::Mid, bgBrush.color().dark(130));
-                pal.setColor(QColorGroup::Dark, bgBrush.color().dark(150));
-                pal.setColor(QColorGroup::Midlight, bgBrush.color().light(110));
-                pal.setColor(QColorGroup::Light, bgBrush.color().light(120));
-                w->setPalette(pal);
-            }
-        }
         return;
     }
-    if(qstrcmp(kapp->argv()[0], "kicker") == 0 &&
-       w->inherits("KPanelExtension")){ // FIXME - doesn't work
-        w->setPalette(kapp->palette());
-    }
 
-    if(w->inherits("QComboBox") ||
-       w->inherits("QLineEdit") || w->inherits("QRadioButton") ||
-       w->inherits("QCheckBox") || w->inherits("QScrollBar") ||
-       w->isA("AppletHandle") || w->inherits("KMiniPagerButton") ||
-       w->inherits("TaskContainer")){
+    if(w->inherits("QRadioButton") || w->inherits("QCheckBox") || w->inherits("QProgressBar")) {
         w->installEventFilter(this);
     }
-    if(w->inherits("QLineEdit")){
-        QPalette pal = w->palette();
-        pal.setBrush(QColorGroup::Base, baseBrush);
-        w->setPalette(pal);
-    }
-    if(w->inherits("QPushButton")){
-        applyCustomAttributes((QPushButton *)w);
-        w->installEventFilter(this);
+
+    if(w->inherits("QButton") || w-> inherits("QComboBox")){
+    	w-> setBackgroundMode ( QWidget::PaletteBackground );
+    	w->setBackgroundOrigin ( QWidget::ParentOrigin);
     }
 
     bool isViewport = qstrcmp(w->name(), "qt_viewport") == 0 ||
@@ -942,11 +849,20 @@
         w->setMouseTracking(true);
         w->installEventFilter(this);
     }
+    if(w-> inherits("QToolButton")) {
+        if (w->parent()->inherits("QToolBar")) {
+    	    ((QToolButton*)w)->setAutoRaise (flatTBButtons);
+    	    if ( flatTBButtons )
+    		    w->setBackgroundOrigin(QWidget::ParentOrigin);
+    	}
+    	w-> installEventFilter ( this );
+    }
+    if(w-> inherits("QToolBarSeparator")&&w->parent()->inherits("QToolBar")) {
+    	((QFrame *) w)-> setFrameShape ( QFrame::NoFrame );
+    }
     if(w->ownPalette() && !w->inherits("QButton") && !w->inherits("QComboBox")){
         return;
     }
-    if(w->inherits("PanelButtonBase"))
-        return;
 
     if(w->parent() && w->parent()->isWidgetType() && !((QWidget*)w->parent())->
        palette().active().brush(QColorGroup::Background).pixmap()){
@@ -954,16 +870,21 @@
         return;
     }
     if(!isViewport && !isViewportChild && !w->testWFlags(WType_Popup) &&
-       !w->inherits("KDesktop") && !w->inherits("PasswordDlg")){
+	   !( !w-> inherits("QLineEdit") && w-> parent() && w-> parent()-> isWidgetType ( ) && w-> parent()-> inherits ( "QMultiLineEdit" ))) {
         if(w->backgroundMode() == QWidget::PaletteBackground ||
            w->backgroundMode() == QWidget::PaletteButton){
-            w->setBackgroundMode(QWidget::X11ParentRelative);
+            w->setBackgroundMode(w->parentWidget()->backgroundMode( )/*QWidget::X11ParentRelative*/);
+            w->setBackgroundOrigin(QWidget::ParentOrigin);
+//			w->setBackgroundMode(QWidget::NoBackground);
         }
     }
-    if(w->inherits("KToolBar")){
-        w->installEventFilter(this);
-        //w->setBackgroundMode(QWidget::NoBackground);
-        return;
+    if ( !w-> inherits("QFrame") || (((QFrame*) w)-> frameShape () == QFrame::NoFrame ))
+	    w-> setBackgroundOrigin ( QWidget::ParentOrigin );	    
+	else if ( w-> inherits("QFrame") )
+	    w->setBackgroundOrigin ( QWidget::WidgetOrigin );
+
+	if ( w->parentWidget()->inherits ( "QWidgetStack" )) {
+	    w->setBackgroundOrigin ( QWidget::WidgetOrigin );
     }
 }
 
@@ -977,6 +898,11 @@
 
     if(w->inherits("QPopupMenu"))
         w->setBackgroundMode(QWidget::PaletteButton);
+    else if(w-> testWFlags(Qt::WType_Popup) && 
+            !w->inherits("QListBox") &&
+            ( qstrcmp ( w-> name(), "automatic what's this? widget" ) != 0 )) {
+    	w->removeEventFilter(menuHandler);
+    }
 
     if(w->isTopLevel())
         return;
@@ -986,7 +912,7 @@
         ((qstrcmp(w->parent()->name(), "qt_viewport") == 0) ||
          (qstrcmp(w->parent()->name(), "qt_clipped_viewport") == 0));
 
-    w->setPalette(QApplication::palette());
+    w->unsetPalette();
     if(w->backgroundMode() == QWidget::X11ParentRelative || isViewportChild){
         if(w->inherits("QPushButton"))
             w->setBackgroundMode(QWidget::PaletteButton);
@@ -997,16 +923,12 @@
     if(isViewportChild)
         w->setAutoMask(false);
 
-    if(w->inherits("QPushButton")){
-        unapplyCustomAttributes((QPushButton *)w);
-        w->removeEventFilter(this);
+/*
+    if(w->inherits("QPushButton") || w-> inherits("QComboBox")){
+    	w-> setBackgroundMode ( PaletteBackground );
     }
-
-    if(w->inherits("QComboBox") ||
-       w->inherits("QLineEdit") || w->inherits("QRadioButton") ||
-       w->inherits("QCheckBox") || w->inherits("QScrollBar") ||
-       w->isA("AppletHandle") || w->inherits("KMiniPagerButton") ||
-       w->inherits("TaskContainer")){
+*/
+    if( w->inherits("QRadioButton") || w->inherits("QCheckBox") || w->inherits("QProgressBar")) {
         w->removeEventFilter(this);
     }
     if(w->inherits("QButton") || w->inherits("QComboBox")){
@@ -1014,9 +936,12 @@
             w->setAutoMask(false);
         }
     }
-    if(w->inherits("KToolBar")){
+    if(w-> inherits("QToolButton")) {
+    	w-> removeEventFilter ( this );
+    }
+    if(w->inherits("QToolBar")){
         w->removeEventFilter(this);
-        //w->setBackgroundMode(QWidget::PaletteBackground);
+        w->setBackgroundMode(QWidget::PaletteBackground);
         return;
     }
     if(w->inherits("QHeader")){
@@ -1028,22 +953,118 @@
 void LiquidStyle::polish(QApplication *app)
 {
 
-    KStyle::polish(app);
+    QWindowsStyle::polish(app);
     menuAni = app->isEffectEnabled(UI_AnimateMenu);
     menuFade = app->isEffectEnabled(UI_FadeMenu);
     if(menuAni)
         app->setEffectEnabled(UI_AnimateMenu, false);
     if(menuFade)
         app->setEffectEnabled(UI_FadeMenu, false);
+	
+    qt_set_draw_menu_bar_impl((QDrawMenuBarItemImpl) &LiquidStyle::drawMenuBarItem);
+    
+    Config config ( "qpe" );
+    config. setGroup ( "Liquid-Style" );
+    
+//    if ( config. readBoolEntry ( "WinDecoration", true ))	
+//	    QApplication::qwsSetDecoration ( new LiquidDecoration ( ));
+	    
+	flatTBButtons = config. readBoolEntry ( "FlatToolButtons", false );
 }
 
 void LiquidStyle::unPolish(QApplication *app)
 {
-    KStyle::unPolish(app);
+    QWindowsStyle::unPolish(app);
     app->setEffectEnabled(UI_AnimateMenu, menuAni);
     app->setEffectEnabled(UI_FadeMenu, menuFade);
+
+    qt_set_draw_menu_bar_impl ( 0 );
+    
+//    QApplication::qwsSetDecoration ( new QPEDecoration ( ));
 }
 
+
+/* !! HACK !! Beware
+ * 
+ * TT forgot to make the QProgressBar widget styleable in Qt 2.x
+ * So the only way to customize the drawing, is to intercept the 
+ * paint event - since we have to use protected functions, we need
+ * to derive a "hack" class from QProgressBar and do the painting
+ * in there.
+ * 
+ * - sandman
+ */
+
+class HackProgressBar : public QProgressBar {
+public:
+	HackProgressBar ( );
+	
+	void paint ( QPaintEvent *event, const QColorGroup &g, QPixmap *pix )
+	{
+		QPainter p( this );
+
+		if ( !contentsRect().contains( event->rect() ) ) {
+			p.save();
+			p.setClipRegion( event->region().intersect(frameRect()) );
+			drawFrame( &p);
+			p.restore();
+		}
+		if ( event->rect().intersects( contentsRect() ))  {
+			p.setClipRegion( event->region().intersect( contentsRect() ) );
+
+			int x, y, w, h;
+			contentsRect ( ). rect ( &x, &y, &w, &h );
+
+			int prog = progress ( );
+			int total = totalSteps ( );
+			if ( prog < 0 )
+				prog = 0;
+			if ( total <= 0 )
+				total = 1;
+			int bw = w * prog / total;
+			if ( bw > w )
+				bw = w;
+
+			p.setPen(g.button().dark(130));
+			p.drawRect(x, y, bw, h);
+			p.setPen(g.button().light(120));
+			p.drawRect(x+1, y+1, bw-2, h-2);
+
+			if(bw >= 4 && h >= 4 && pix)
+				p.drawTiledPixmap(x+2, y+2, bw-4, h-4, *pix);
+			
+			if ( progress ( )>= 0 && totalSteps ( ) > 0 ) {			
+				QString pstr;
+				pstr. sprintf ( "%d%%", 100 * progress()/totalSteps ());
+				p. setPen ( g.text());//g.highlightedText ( ));
+				p. drawText (x,y,w-1,h-1,AlignCenter,pstr);
+			}
+		}
+	}
+};
+
+
+/*
+ * The same for QToolButton:
+ * TT hardcoded the drawing of the focus rect ...
+ *
+ * - sandman
+ */
+
+
+class HackToolButton : public QToolButton {
+public:
+	HackToolButton ( );
+	
+	void paint ( QPaintEvent *ev )
+	{
+		erase ( ev-> region ( ));
+		QPainter p ( this );
+		style ( ). drawToolButton ( this, &p );
+		drawButtonLabel ( &p );
+	}
+};
+
 /*
  * This is a fun method ;-) Here's an overview. KToolBar grabs resize to
  * force everything to erase and repaint on resize. This is going away, I'm
@@ -1063,7 +1084,7 @@
  */
 bool LiquidStyle::eventFilter(QObject *obj, QEvent *ev)
 {
-    if(obj->inherits("KToolBar")){
+    if(obj->inherits("QToolBar")){
         if(ev->type() == QEvent::Resize){
             const QObjectList *tbChildList = obj->children();
             QObjectListIt it(*tbChildList);
@@ -1076,116 +1097,27 @@
 
         }
     }
-    else if(obj->inherits("KMiniPagerButton")){
-        QButton *btn = (QButton *)obj;
-        if(ev->type() == QEvent::Paint){
-            if(!(btn->isOn() || btn->isDown())){
-                QPalette pal = btn->palette();
-                pal.setBrush(QColorGroup::Dark, btn == highlightWidget ?
-                             pagerHoverBrush : pagerBrush);
-                btn->setPalette(pal);
-            }
-            else{
-                QPalette pal = btn->palette();
-                pal.setBrush(QColorGroup::Dark,
-                             QApplication::palette().active().brush(QColorGroup::Dark));
-                btn->setPalette(pal);
-
-            }
-        }
-        else if(ev->type() == QEvent::Enter){
-            highlightWidget = btn;
-            btn->repaint(false);
-        }
-        else if(ev->type() == QEvent::Leave){
-            highlightWidget = NULL;
-            btn->repaint(false);
-        }
-
-    }
-    else if(obj->inherits("QPushButton") || obj->inherits("QComboBox") ||
-            obj->isA("AppletHandle")){
-        QWidget *btn = (QWidget *)obj;
-        if(ev->type() == QEvent::Enter){
-            if(btn->isEnabled()){
-                highlightWidget = btn;
-                btn->repaint(false);
-            }
-        }
-        else if(ev->type() == QEvent::Leave){
-            if(btn == highlightWidget){
-                highlightWidget = NULL;
-                btn->repaint(false);
-            }
-        }
-    }
-    else if(obj->inherits("TaskContainer")){
-        QButton *btn = (QButton *)obj;
-        QPalette pal = btn->palette();
-        if(ev->type() == QEvent::Enter){
-            pal.setColor(QColorGroup::Background, pal.active().button().light(110));
-            btn->setPalette(pal);
-        }
-        else if(ev->type() == QEvent::Leave){
-            pal.setColor(QColorGroup::Background,
-                         QApplication::palette().active().background());
-            btn->setPalette(pal);
-        }
-    }
-    else if(obj->inherits("QToolButton") && !obj->inherits("KToolBarButton")){
-        QToolButton *btn = (QToolButton *)btn;
-        if(!btn->autoRaise()){
+    else if(obj->inherits("QToolButton")){
+        QToolButton *btn = (QToolButton *)obj;
+        if(ev->type() == QEvent::FocusIn ){ // && !btn-> autoRaise () 
             if(btn->isEnabled()){
                 highlightWidget = btn;
                 btn->repaint(false);
+                
+	        	qDebug ( "TB FOCUS IN [%p]", btn );
             }
         }
-        else if(ev->type() == QEvent::Leave){
-            QWidget *btn = (QWidget *)obj;
+        else if(ev->type() == QEvent::FocusOut ){
             if(btn == highlightWidget){
                 highlightWidget = NULL;
                 btn->repaint(false);
+                
+                qDebug ( "TB FOCUS OUT [%p]", btn );
             }
         }
-        else
-            highlightWidget = NULL;
-    }
-    else if(obj->inherits("QScrollBar")){
-        QScrollBar *sb = (QScrollBar *)obj;
-        if(ev->type() == QEvent::Enter){
-            if(sb->isEnabled()){
-                highlightWidget = sb;
-                sb->repaint(false);
-            }
-        }
-        else if(ev->type() == QEvent::Leave){
-            if(sb == highlightWidget && !sb->draggingSlider()){
-                highlightWidget = NULL;
-                sb->repaint(false);
-            }
-        }
-        else if(ev->type() == QEvent::MouseButtonRelease){
-            QMouseEvent *me = (QMouseEvent *)ev;
-            if(sb == highlightWidget && !sb->rect().contains(me->pos())){
-                highlightWidget = NULL;
-                sb->repaint(false);
-            }
-        }
-    }
-    else if(obj->inherits("QLineEdit")){
-        if(obj->parent() && obj->parent()->inherits("QComboBox")){
-            QWidget *btn = (QComboBox *)obj->parent();
-            if(ev->type() == QEvent::Enter){
-                if (btn->isEnabled()){
-                    highlightWidget = btn;
-                    btn->repaint(false);
-                }
-            }
-            else if(ev->type() == QEvent::Leave){
-                if (btn == highlightWidget)
-                    highlightWidget = NULL;
-                btn->repaint(false);
-            }
+        else if(ev->type() == QEvent::Paint) {
+        	(( HackToolButton *) btn )-> paint ((QPaintEvent *) ev );
+        	return true;
         }
     }
     else if(obj->inherits("QRadioButton") || obj->inherits("QCheckBox")){
@@ -1201,6 +1133,7 @@
             QSize sz = isRadio ? exclusiveIndicatorSize()
                 : indicatorSize();
 
+/*
             if(btn->hasFocus()){
                 QRect r = QRect(0, 0, btn->width(), btn->height());
                 p.setPen(btn->colorGroup().button().dark(140));
@@ -1209,6 +1142,7 @@
                 p.drawLine(r.right(), r.y()+1, r.right(), r.bottom()-1);
                 p.drawLine(r.x()+1, r.bottom(), r.right()-1, r.bottom());
             }
+*/
             int x = 0;
             int y = (btn->height()-lsz.height()+fm.height()-sz.height())/2;
             if(isRadio)
@@ -1228,36 +1162,6 @@
             p.end();
             return(true);
         }
-        // for hover, just redraw the indicator (not the text)
-        else if((ev->type() == QEvent::Enter && btn->isEnabled()) ||
-                (ev->type() == QEvent::Leave && btn == highlightWidget)){
-            QButton *btn = (QButton *)obj;
-            bool isRadio = obj->inherits("QRadioButton");
-
-            if(ev->type() == QEvent::Enter)
-                highlightWidget = btn;
-            else 
-                highlightWidget = NULL;
-            QFontMetrics fm = btn->fontMetrics();
-            QSize lsz = fm.size(ShowPrefix, btn->text());
-            QSize sz = isRadio ? exclusiveIndicatorSize()
-                : indicatorSize();
-            int x = 0;
-            int y = (btn->height()-lsz.height()+fm.height()-sz.height())/2;
-            //if(btn->autoMask())
-            //    btn->erase(x+1, y+1, sz.width()-2, sz.height()-2);
-            QPainter p;
-            p.begin(btn);
-            if(isRadio)
-                drawExclusiveIndicator(&p, x, y, sz.width(), sz.height(),
-                                       btn->colorGroup(), btn->isOn(),
-                                       btn->isDown(), btn->isEnabled());
-            else
-                drawIndicator(&p, x, y, sz.width(), sz.height(),
-                              btn->colorGroup(), btn->state(), btn->isDown(),
-                              btn->isEnabled());
-            p.end();
-        }
     }
     else if(obj->inherits("QHeader")){
         QHeader *hw = (QHeader *)obj;
@@ -1290,7 +1194,24 @@
             }
         }
     }
-    return(false);
+    else if (obj-> inherits( "QProgressBar" )) {
+    	if ( ev->type() == QEvent::Paint ) {
+    		HackProgressBar *p = (HackProgressBar *) obj;
+    		const QColorGroup &g = p-> colorGroup ( );
+    		
+			QPixmap *pix = bevelFillDict.find(g.button().dark(120).rgb());
+			if(!pix){
+				int h, s, v;
+				g.button().dark(120).hsv(&h, &s, &v);
+				pix = new QPixmap(*bevelFillPix);
+				adjustHSV(*pix, h, s, v);
+				bevelFillDict.insert(g.button().dark(120).rgb(), pix);
+			}
+    		p-> paint ((QPaintEvent *) ev, g, pix );
+    		return true;    		
+    	}
+	}    		
+	return false ;
 }
 
 void LiquidStyle::drawButton(QPainter *p, int x, int y, int w, int h,
@@ -1325,8 +1246,11 @@
         }
 
         p->drawTiledPixmap(x+2, y+2, w-4, h-4, *pix);
+        qDebug ( "DRAW TOOLBUTTON IN PIXMAP" );
     }
     else{
+    	qDebug ( "DRAW TOOLBUTTON sunken=%d/high=%p/device=%p", sunken, highlightWidget,p->device() );
+    
         drawClearBevel(p, x, y, w, h, sunken ? g.button() :
                        highlightWidget == p->device() ? g.button().light(110) :
                        g.background(), g.background());
@@ -1340,11 +1264,6 @@
     QColorGroup g = btn->colorGroup();
 
 
-    QColor testColor;
-    if(btn->parent() && btn->parent()->isWidgetType()){
-        testColor = p->backgroundColor(); // remove me
-    }
-
     //int dw = buttonDefaultIndicatorWidth();
     if(btn->hasFocus() || btn->isDefault()){
         QColor c = btn->hasFocus() ? g.button().light(110) : g.background();
@@ -1488,7 +1407,20 @@
                                  const QColorGroup &g, bool sunken,
                                  bool edit, bool, const QBrush *)
 {
-    bool isHover = highlightWidget == painter->device();
+    bool isActive = false;
+    if (( painter->device()->devType() == QInternal::Widget ) &&
+        (
+         ( qApp-> focusWidget ( ) == painter-> device ( )) ||
+         (
+          edit &&
+          ((QWidget *) painter-> device ( ))-> inherits ( "QComboBox" ) && 
+          ( qApp-> focusWidget ( ) == ((QComboBox *) painter->device())->lineEdit ( ))
+         )
+        )
+      ) {
+    	isActive = true;
+    }
+    	
     bool isMasked = false;
     if(painter->device()->devType() == QInternal::Widget)
         isMasked = ((QWidget*)painter->device())->autoMask();
@@ -1498,7 +1430,7 @@
 
     drawRoundButton(&p, g.button(), g.background(), 0, 0, w, h, false,
                     sunken, false, isMasked);
-    if(!isHover){
+    if(!isActive){
         p.setClipRect(0, 0, w-17, h);
         drawRoundButton(&p, g.background(), g.background(), 0, 0, w, h, false,
                         sunken, false, isMasked);
@@ -1550,16 +1482,17 @@
     return(QRect(x+9, y+3, w - (h / 3) - 20, h-6));
 }
 
-QRect LiquidStyle::comboButtonFocusRect(int x, int y, int w, int h)
+QRect LiquidStyle::comboButtonFocusRect(int /*x*/, int /*y*/, int /*w*/, int /*h*/)
 {
-    return(QRect(x+5, y+3, w-(h/3)-13, h-5));
+	return QRect ( );
+	
+//    return(QRect(x+5, y+3, w-(h/3)-13, h-5));
 }
 
 void LiquidStyle::drawScrollBarControls(QPainter *p, const QScrollBar *sb,
                                        int sliderStart, uint controls,
                                        uint activeControl)
 {
-    bool isHover = highlightWidget == p->device();
     int sliderMin, sliderMax, sliderLength, buttonDim;
     scrollBarMetrics( sb, sliderMin, sliderMax, sliderLength, buttonDim );
 
@@ -1596,7 +1529,7 @@
         if(sbBuffer.size() != sb->size())
             sbBuffer.resize(sb->size());
     }
-    subB.setRect( subX,subY,buttonDim,buttonDim );
+    subB.setRect( subX,subY,0,0); // buttonDim,buttonDim );
     addB.setRect( addX,addY,buttonDim,buttonDim );
     if(horiz)
         subHC.setRect(addX-buttonDim,addY,buttonDim,buttonDim );
@@ -1624,7 +1557,7 @@
     QPainter painter;
     if(!horiz){
         painter.begin(&sbBuffer);
-        QRect bgR(0, subB.bottom()+1, sb->width(), (len-(buttonDim*3))+1);
+        QRect bgR(0, subB.bottom()+1, sb->width(), (len-(buttonDim*2))+1);
         if(sliderR.height() >= 8){
             painter.drawPixmap(bgR.x()+1, bgR.y(), *vsbSliderFillPix, 0, 0,
                           13, 8);
@@ -1648,25 +1581,15 @@
         }
         if(controls & Slider){
             if(sliderR.height() >= 16){
-                painter.drawPixmap(sliderR.x()+1, sliderR.y(),
-                                   isHover ? *getPixmap(VSBSliderTopHover):
-                                   *getPixmap(VSBSliderTop));
+                painter.drawPixmap(sliderR.x()+1, sliderR.y(), *getPixmap(VSBSliderTop));
                 painter.drawTiledPixmap(sliderR.x()+1, sliderR.y()+8, 13,
-                                        sliderR.height()-16, isHover ?
-                                        *getPixmap(VSBSliderMidHover) :
-                                        *getPixmap(VSBSliderMid));
-                painter.drawPixmap(sliderR.x()+1, sliderR.bottom()-8,
-                                   isHover ? *getPixmap(VSBSliderBtmHover) :
-                                   *getPixmap(VSBSliderBtm));
+                                        sliderR.height()-16, *getPixmap(VSBSliderMid));
+                painter.drawPixmap(sliderR.x()+1, sliderR.bottom()-8, *getPixmap(VSBSliderBtm));
             }
             else if(sliderR.height() >= 8){
                 int m = sliderR.height()/2;
-                painter.drawPixmap(sliderR.x()+1, sliderR.y(),
-                                   isHover ? *getPixmap(VSBSliderTopHover):
-                                   *getPixmap(VSBSliderTop), 0, 0, 13, m);
-                painter.drawPixmap(sliderR.x()+1, sliderR.y()+m,
-                                   isHover ? *getPixmap(VSBSliderBtmHover):
-                                   *getPixmap(VSBSliderBtm), 0, 8-m, 13, m);
+                painter.drawPixmap(sliderR.x()+1, sliderR.y(), *getPixmap(VSBSliderTop), 0, 0, 13, m);
+                painter.drawPixmap(sliderR.x()+1, sliderR.y()+m, *getPixmap(VSBSliderBtm), 0, 8-m, 13, m);
             }
             else{
                 painter.setPen(g.button().dark(210));
@@ -1674,7 +1597,6 @@
                               13, sliderR.height());
                 painter.drawTiledPixmap(sliderR.x()+2, sliderR.y()+1,
                                         11, sliderR.height()-2,
-                                        isHover ? *getPixmap(VSBSliderMidHover) :
                                         *getPixmap(VSBSliderMid), 1, 0);
             }
         }
@@ -1690,7 +1612,7 @@
     }
     else{
         painter.begin(&sbBuffer);
-        QRect bgR(subB.right()+1, 0, (len-(buttonDim*3))+1, sb->height());
+        QRect bgR(subB.right()+1, 0, (len-(buttonDim*2))+1, sb->height());
         if(sliderR.width() >= 8){
             painter.drawPixmap(bgR.x(), bgR.y()+1, *vsbSliderFillPix, 0, 0,
                                8, 13);
@@ -1715,22 +1637,17 @@
         if(controls & Slider){
             if(sliderR.width() >= 16){
                 painter.drawPixmap(sliderR.x(), sliderR.y()+1,
-                                   isHover ? *getPixmap(HSBSliderTopHover) :
                                    *getPixmap(HSBSliderTop));
                 painter.drawTiledPixmap(sliderR.x()+8, sliderR.y()+1, sliderR.width()-16,
-                                        13, isHover ? *getPixmap(HSBSliderMidHover) :
-                                        *getPixmap(HSBSliderMid));
-                painter.drawPixmap(sliderR.right()-8, sliderR.y()+1, isHover ?
-                                   *getPixmap(HSBSliderBtmHover) :
+                                        13, *getPixmap(HSBSliderMid));
+                painter.drawPixmap(sliderR.right()-8, sliderR.y()+1, 
                                    *getPixmap(HSBSliderBtm));
             }
             else if(sliderR.width() >= 8){
                 int m = sliderR.width()/2;
                 painter.drawPixmap(sliderR.x(), sliderR.y()+1,
-                                   isHover ? *getPixmap(HSBSliderTopHover) :
                                    *getPixmap(HSBSliderTop), 0, 0, m, 13);
-                painter.drawPixmap(sliderR.right()-8, sliderR.y()+1, isHover ?
-                                   *getPixmap(HSBSliderBtmHover) :
+                painter.drawPixmap(sliderR.right()-8, sliderR.y()+1, 
                                    *getPixmap(HSBSliderBtm), 8-m, 0, m, 13);
             }
             else{
@@ -1738,8 +1655,7 @@
                 drawRoundRect(&painter, sliderR.x(), sliderR.y()+1,
                               sliderR.width(), 13);
                 painter.drawTiledPixmap(sliderR.x()+1, sliderR.y()+2,
-                                        sliderR.width()-2, 11, isHover ?
-                                        *getPixmap(HSBSliderMidHover) :
+                                        sliderR.width()-2, 11, 
                                         *getPixmap(HSBSliderMid), 0, 1);
             }
         }
@@ -1761,10 +1677,10 @@
                    addB.width()-8, addB.height()-8, g, !maxed);
     }
     if ( controls & SubLine ) {
-        drawSBButton(p, subB, g, activeControl == SubLine);
-        drawArrow( p, horiz ? LeftArrow : UpArrow,
-                   false, subB.x()+4, subB.y()+4,
-                   subB.width()-8, subB.height()-8, g, !maxed);
+     //   drawSBButton(p, subB, g, activeControl == SubLine);
+     //   drawArrow( p, horiz ? LeftArrow : UpArrow,
+     //              false, subB.x()+4, subB.y()+4,
+     //              subB.width()-8, subB.height()-8, g, !maxed);
         drawSBButton(p, subHC, g, activeControl == SubLine);
         drawArrow( p, horiz ? LeftArrow : UpArrow,
                    false, subHC.x()+4, subHC.y()+4,
@@ -1865,8 +1781,8 @@
     else
 	buttonDim = ( length - b*2 )/2 - 1;
 
-    sliderMin = b + buttonDim;
-    maxLength  = length - b*2 - buttonDim*3;
+    sliderMin = b + 0; // buttonDim;
+    maxLength  = length - b*2 - buttonDim*2; // 3;
 
     if ( sb->maxValue() == sb->minValue() ) {
 	sliderLength = maxLength;
@@ -1914,31 +1830,31 @@
     return(QSize(16, 16));
 }
 
-void LiquidStyle::drawExclusiveIndicator(QPainter *p, int x, int y, int w,
-                                        int h, const QColorGroup &g, bool on,
+void LiquidStyle::drawExclusiveIndicator(QPainter *p, int x, int y, int /*w*/,
+                                        int /*h*/, const QColorGroup &/*g*/, bool on,
                                         bool down, bool)
 {
-    bool isHover = highlightWidget == p->device();
+    bool isActive = ( p->device()->devType() == QInternal::Widget ) && ( qApp-> focusWidget ( ) == p-> device ( ));
     bool isMasked = p->device() && p->device()->devType() == QInternal::Widget
         && ((QWidget*)p->device())->autoMask();
 
     if(isMasked){
         if(on || down){
-            p->drawPixmap(x, y, isHover ? *getPixmap(HTMLRadioDownHover) :
+            p->drawPixmap(x, y, isActive ? *getPixmap(HTMLRadioDownHover) :
                           *getPixmap(HTMLRadioDown));
         }
         else
-            p->drawPixmap(x, y, isHover ? *getPixmap(HTMLRadioHover) :
+            p->drawPixmap(x, y, isActive ? *getPixmap(HTMLRadioHover) :
                           *getPixmap(HTMLRadio));
 
     }
     else{
         if(on || down){
-            p->drawPixmap(x, y, isHover ? *getPixmap(RadioOnHover) :
+            p->drawPixmap(x, y, isActive ? *getPixmap(RadioOnHover) :
                           *getPixmap(RadioOn));
         }
         else
-            p->drawPixmap(x, y, isHover ? *getPixmap(RadioOffHover) :
+            p->drawPixmap(x, y, isActive ? *getPixmap(RadioOffHover) :
                           *getPixmap(RadioOff));
     }
 }
@@ -1957,25 +1873,25 @@
     return(QSize(20, 22));
 }
 
-void LiquidStyle::drawIndicator(QPainter *p, int x, int y, int w, int h,
-                            const QColorGroup &g, int state, bool down, bool)
+void LiquidStyle::drawIndicator(QPainter *p, int x, int y, int /*w*/, int /*h*/,
+                            const QColorGroup &/*g*/, int state, bool /*down*/, bool)
 {
-    bool isHover = highlightWidget == p->device();
+    bool isActive = ( p->device()->devType() == QInternal::Widget ) && ( qApp-> focusWidget ( ) == p-> device ( ));
     bool isMasked = p->device() && p->device()->devType() == QInternal::Widget
         && ((QWidget*)p->device())->autoMask();
     if(isMasked){
         if(state != QButton::Off){
-            p->drawPixmap(x, y, isHover ? *getPixmap(HTMLCBDownHover) :
+            p->drawPixmap(x, y, isActive ? *getPixmap(HTMLCBDownHover) :
                           *getPixmap(HTMLCBDown));
         }
         else
-            p->drawPixmap(x, y, isHover ? *getPixmap(HTMLCBHover) :
+            p->drawPixmap(x, y, isActive ? *getPixmap(HTMLCBHover) :
                           *getPixmap(HTMLCB));
 
     }
     else{
         if(state != QButton::Off){
-            p->drawPixmap(x, y, isHover ? *getPixmap(CBDownHover) :
+            p->drawPixmap(x, y, isActive ? *getPixmap(CBDownHover) :
                           *getPixmap(CBDown));
             /*  Todo - tristate
              if(state == QButton::On){
@@ -1992,12 +1908,12 @@
              }*/
         }
         else
-            p->drawPixmap(x, y, isHover ? *getPixmap(CBHover) : *getPixmap(CB));
+            p->drawPixmap(x, y, isActive ? *getPixmap(CBHover) : *getPixmap(CB));
     }
 }
 
-void LiquidStyle::drawIndicatorMask(QPainter *p, int x, int y, int w, int h,
-                                   int state)
+void LiquidStyle::drawIndicatorMask(QPainter *p, int x, int y, int /*w*/, int /*h*/,
+                                   int /*state*/)
 {
     // needed for some reason by KHtml, even tho it's all filled ;P
     p->drawPixmap(x, y, *getPixmap(HTMLCB)->mask());
@@ -2005,18 +1921,17 @@
 }
 
 void LiquidStyle::drawSlider(QPainter *p, int x, int y, int w, int h,
-                         const QColorGroup &g, Orientation orient,
+                         const QColorGroup &/*g*/, Orientation orient,
                          bool, bool)
 {
     QWidget *parent = (QWidget *)p->device();
     p->setBrushOrigin(parent->pos());
-    p->fillRect(x, y, w, h,
-                QApplication::palette().active().brush(QColorGroup::Background));
+    parent->erase(x, y, w, h);
     p->drawPixmap(x, y, orient == Qt::Horizontal ? *getPixmap(HSlider) :
                   *getPixmap(VSlider));
 }
 
-void LiquidStyle::drawSliderMask(QPainter *p, int x, int y, int w, int h,
+void LiquidStyle::drawSliderMask(QPainter *p, int x, int y, int /*w*/, int /*h*/,
                              Orientation orient, bool, bool)
 {
     p->drawPixmap(x, y, orient == Qt::Horizontal ? *getPixmap(HSlider)->mask() :
@@ -2065,243 +1980,76 @@
     p->drawLineSegments(a);
 }
 
-void LiquidStyle::drawKBarHandle(QPainter *p, int x, int y, int w, int h,
-                             const QColorGroup &g, KToolBarPos,
-                             QBrush *)
-{
-    p->setPen(g.button().dark(120));
-    int x2 = x+w-1;
-    int y2 = y+h-1;
-    p->drawLine(x+1, y, x2-1, y);
-    p->drawLine(x+1, y2, x2-1, y2);
-    p->drawLine(x, y+1, x, y2-1);
-    p->drawLine(x2, y+1, x2, y2-1);
-
-    p->setPen(g.background());
-    p->drawPoint(x, y);
-    p->drawPoint(x2, y);
-    p->drawPoint(x, y2);
-    p->drawPoint(x2, y2);
-
-
-
-   // p->drawRect(x, y, w, h);
-    QPixmap *pix = bevelFillDict.find(g.button().rgb());
-    if(!pix){
-        int h, s, v;
-        g.button().hsv(&h, &s, &v);
-        pix = new QPixmap(*bevelFillPix);
-        adjustHSV(*pix, h, s, v);
-        bevelFillDict.insert(g.button().rgb(), pix);
-    }
-
-    p->drawTiledPixmap(x+1, y+1, w-2, h-2, *pix);
-}
-
-void LiquidStyle::drawKMenuBar(QPainter *p, int x, int y, int w, int h,
-                           const QColorGroup &g, bool mac, QBrush *)
-{
-    if(p->device() && p->device()->devType() == QInternal::Widget &&
-       ((KMenuBar *)p->device())->isTopLevelMenu()){
-        p->setPen(Qt::black);
-        p->drawRect(x, y, w, h);
-        p->drawTiledPixmap(x+1, y+1, w-2, h-2, *menuPix);
-        // left
-        p->drawLine(x+1, y+1, x+1, y+5);
-        p->drawLine(x+2, y+1, x+2, y+3);
-        p->drawLine(x+3, y+1, x+3, y+2);
-        p->drawLine(x+4, y+1, x+6, y+1);
-        // right
-        int x2 = x+w-1;
-        p->drawLine(x2-1, y+1, x2-1, y+5);
-        p->drawLine(x2-2, y+1, x2-2, y+3);
-        p->drawLine(x2-3, y+1, x2-3, y+2);
-        p->drawLine(x2-4, y+1, x2-6, y+1);
-    }
-    else{
-        qDrawShadePanel(p, x, y, w, h, g, false, 1,
-                        &g.brush(QColorGroup::Background));
-    }
 
-}
-
-void LiquidStyle::drawKToolBar(QPainter *p, int x, int y, int w, int h,
-                           const QColorGroup &g, KToolBarPos, QBrush *)
+void LiquidStyle::drawMenuBarItem(QPainter *p, int x, int y, int w, int h,
+                            QMenuItem *mi, QColorGroup &g, bool /*enabled*/, bool active )
 {
-    //p->fillRect(x, y, w, h, g.brush(QColorGroup::Background));
-}
-
-void LiquidStyle::drawKToolBarButton(QPainter *p, int x, int y, int w, int h,
-                                    const QColorGroup &g, bool sunken,
-                                    bool raised, bool enabled, bool popup,
-                                    KToolButtonType icontext,
-                                    const QString& btext, const QPixmap *pixmap,
-                                    QFont *font, QWidget *btn)
-{
-    int dx, dy;
-
-    QFontMetrics fm(*font);
-
-    QToolBar* toolbar = 0;
-    if(btn->parent() && btn->parent()->isWidgetType() && btn->parent()->inherits("QToolBar"))
-        toolbar = static_cast<QToolBar*>(btn->parent());
-
-    --w, --h;
-    if(sunken)
-        ++x, ++y;
-
-    QColor btnColor(sunken ?  g.button() : raised ? g.button().light(110) :
-                    g.background());
-    drawClearBevel(p, x, y, w, h, btnColor, g.background());
-
-    p->setPen(g.text());
-
-    if (icontext == Icon){ // icon only
-        if (pixmap){
-            dx = ( w - pixmap->width() ) / 2;
-            dy = ( h - pixmap->height() ) / 2;
-            if ( sunken )
-            {
-                ++dx;
-                ++dy;
-            }
-            p->drawPixmap( x+dx, y+dy, *pixmap );
-        }
-    }
-    else if (icontext == IconTextRight){ // icon and text (if any)
-        if (pixmap){
-            dx = 4;
-            dy = ( h - pixmap->height() ) / 2;
-            if ( sunken ){
-                ++dx;
-                ++dy;
-            }
-            p->drawPixmap( x+dx, y+dy, *pixmap );
-        }
-        if (!btext.isNull()){
-            int tf = AlignVCenter|AlignLeft;
-            if (pixmap)
-                dx= 4 + pixmap->width() + 2;
-            else
-                dx= 4;
-            dy = 0;
-            if ( sunken ){
-                ++dx;
-                ++dy;
-            }
-            if (font)
-                p->setFont(*font);
-            if(raised)
-                p->setPen(KGlobalSettings::toolBarHighlightColor());
-            p->drawText(x+dx, y+dy, w-dx, h, tf, btext);
-        }
-    }
-    else if (icontext == Text){ // only text, even if there is a icon
-        if (!btext.isNull()){
-            int tf = AlignVCenter|AlignLeft;
-            if (!enabled)
-                p->setPen(g.dark());
-            dx= (w - fm.width(btext)) / 2;
-            dy= (h - fm.lineSpacing()) / 2;
-            if ( sunken ){
-                ++dx;
-                ++dy;
-            }
-            if (font)
-                p->setFont(*font);
-            if(raised)
-                p->setPen(KGlobalSettings::toolBarHighlightColor());
-            p->drawText(x+dx, y+dy, fm.width(btext), fm.lineSpacing(), tf, btext);
-        }
-    }
-    else if (icontext == IconTextBottom){
-        if (pixmap){
-            dx = (w - pixmap->width()) / 2;
-            dy = (h - fm.lineSpacing() - pixmap->height()) / 2;
-            if ( sunken ){
-                ++dx;
-                ++dy;
-            }
-            p->drawPixmap( x+dx, y+dy, *pixmap );
-        }
-        if (!btext.isNull()){
-            int tf = AlignBottom|AlignHCenter;
-            dy= pixmap->height();
-            dx = 2;
-            if ( sunken ){
-                ++dx;
-                ++dy;
-            }
-            if (font)
-                p->setFont(*font);
-            if(raised)
-                p->setPen(KGlobalSettings::toolBarHighlightColor());
-            p->drawText(x, y, w, h-3, tf, btext);
-        }
-    }
-    if (popup){
-        if (enabled)
-            qDrawArrow (p, Qt::DownArrow, Qt::WindowsStyle, false, w-5, h-5, 0, 0,
-                        g, true);
-        else
-            qDrawArrow (p, Qt::DownArrow, Qt::WindowsStyle, false, w-5, h-5,
-                        0, 0, g, false);
+    if(active){
+        x -= 2; // Bug in Qt/E 
+        y -= 2;
+        w += 2;
+        h += 2;
     }
-}
-
 
-void LiquidStyle::drawKMenuItem(QPainter *p, int x, int y, int w, int h,
-                            const QColorGroup &g, bool active, QMenuItem *mi,
-                            QBrush *)
-{
-    if ( p->font() == KGlobalSettings::generalFont() )
-        p->setFont( KGlobalSettings::menuFont() );
+    QWidget *parent = (QWidget *)p->device();
+    p->setBrushOrigin(parent->pos());
+    parent->erase(x, y, w, h);
 
     if(menuHandler->useShadowText()){
         QColor shadow;
         if(p->device() && p->device()->devType() == QInternal::Widget &&
-           ((QWidget *)p->device())->inherits("KMenuBar")){
-            shadow = ((KMenuBar*)p->device())->isTopLevel() ? g.button().dark(130) :
+           ((QWidget *)p->device())->inherits("QMenuBar")){
+            shadow = ((QMenuBar*)p->device())->isTopLevel() ? g.button().dark(130) :
                 g.background().dark(130);
         }
         else
             shadow = g.background().dark(130);
 
+		QPixmap *dummy = 0;
+		
+		if ( mi-> pixmap ( ) && !mi-> pixmap ( )-> isNull ( )) {
+			dummy = new QPixmap ( mi-> pixmap ( )-> size ( ));
+			QBitmap dummy_mask ( dummy-> size ( ));
+			dummy_mask. fill ( color1 );
+			dummy-> setMask ( dummy_mask );
+		}
+
         if(active){
             drawClearBevel(p, x+1, y+1, w-1, h-1, g.button(), g.background());
             QApplication::style().drawItem(p, x+1, y+1, w, h,
                                            AlignCenter|ShowPrefix|DontClip|SingleLine,
-                                           g, mi->isEnabled(), NULL, mi->text(),
+                                           g, mi->isEnabled(), dummy, mi->text(),
                                            -1, &shadow);
             QApplication::style().drawItem(p, x, y, w, h,
                                            AlignCenter|ShowPrefix|DontClip|SingleLine,
-                                           g, mi->isEnabled(), NULL, mi->text(),
+                                           g, mi->isEnabled(), mi-> pixmap ( ), mi->text(),
                                            -1, &g.text());
         }
         else{
             QApplication::style().drawItem(p, x+1, y+1, w, h,
                                            AlignCenter|ShowPrefix|DontClip|SingleLine,
-                                           g, mi->isEnabled(), NULL, mi->text(),
+                                           g, mi->isEnabled(), dummy, mi->text(),
                                            -1, &shadow);
             QApplication::style().drawItem(p, x, y, w, h,
                                            AlignCenter|ShowPrefix|DontClip|SingleLine,
-                                           g, mi->isEnabled(), NULL, mi->text(),
+                                           g, mi->isEnabled(), mi-> pixmap ( ), mi->text(),
                                            -1, &g.text());
         }
+        delete dummy;
     }
     else{
         if(active)
             drawClearBevel(p, x+1, y+1, w-1, h-1, g.button(), g.background());
         QApplication::style().drawItem(p, x, y, w, h,
                                        AlignCenter|ShowPrefix|DontClip|SingleLine,
-                                       g, mi->isEnabled(), NULL, mi->text(),
+                                       g, mi->isEnabled(), mi-> pixmap ( ), mi->text(),
                                        -1, &g.text());
     }
 }
 
 void LiquidStyle::drawPopupPanel(QPainter *p, int x, int y, int w, int h,
-                                 const QColorGroup &g, int lineWidth,
-                                 const QBrush * fill)
+                                 const QColorGroup &g, int /*lineWidth*/,
+                                 const QBrush * /*fill*/)
 {
     QColor c;
     switch(menuHandler->transType()){
@@ -2336,8 +2084,6 @@
 
     maxpmw = QMAX( maxpmw, 20 );
 
-    if ( p->font() == KGlobalSettings::generalFont() )
-        p->setFont( KGlobalSettings::menuFont() );
 
     bool dis = !enabled;
     QColorGroup itemg = dis ? pal.disabled() : pal.active();
@@ -2363,7 +2109,7 @@
             p->fillRect(x, y, w, h, menuBrush);
         }
         else{
-            KPixmap *pix = menuHandler->pixmap(((QWidget*)p->device())->winId());
+            QPixmap *pix = menuHandler->pixmap(((QWidget*)p->device())->winId());
             if(pix)
                 p->drawPixmap(x, y, *pix, x, y, w, h);
         }
@@ -2508,25 +2254,6 @@
     return h;
 }
 
-void LiquidStyle::drawKProgressBlock(QPainter *p, int x, int y, int w, int h,
-                                    const QColorGroup &g, QBrush *fill)
-{
-    p->setPen(g.button().dark(130));
-    p->drawRect(x, y, w, h);
-    p->setPen(g.button().light(120));
-    p->drawRect(x+1, y+1, w-2, h-2);
-    if(w >= 4 && h >= 4){
-        QPixmap *pix = bevelFillDict.find(g.button().dark(120).rgb());
-        if(!pix){
-            int h, s, v;
-            g.button().dark(120).hsv(&h, &s, &v);
-            pix = new QPixmap(*bevelFillPix);
-            adjustHSV(*pix, h, s, v);
-            bevelFillDict.insert(g.button().dark(120).rgb(), pix);
-        }
-        p->drawTiledPixmap(x+2, y+2, w-4, h-4, *pix);
-    }
-}
 
 void LiquidStyle::drawFocusRect(QPainter *p, const QRect &r,
                             const QColorGroup &g, const QColor *c,
@@ -2536,29 +2263,29 @@
     if(p->device()->devType() == QInternal::Widget){
         // if so does it use a special focus rectangle?
         QWidget *w = (QWidget *)p->device();
-        if(w->inherits("QPushButton") || w->inherits("QSlider")){
+        if(w->inherits("QPushButton") || w->inherits("QSlider") || w->inherits("QComboBox") || w->inherits("QToolButton" )){
             return;
         }
         else{
-            KStyle::drawFocusRect(p, r, g, c, atBorder);
+            QWindowsStyle::drawFocusRect(p, r, g, c, atBorder);
         }
     }
     else
-        KStyle::drawFocusRect(p, r, g, c, atBorder);
+        QWindowsStyle::drawFocusRect(p, r, g, c, atBorder);
 
 }
 
 void LiquidStyle::polishPopupMenu(QPopupMenu *mnu)
 {
     mnu->installEventFilter(menuHandler);
-    KStyle::polishPopupMenu(mnu);
+    QWindowsStyle::polishPopupMenu(mnu);
 }
 
 void LiquidStyle::drawTab(QPainter *p, const QTabBar *tabBar, QTab *tab,
                       bool selected)
 {
     if(tabBar->shape() != QTabBar::RoundedAbove){
-        KStyle::drawTab(p, tabBar, tab, selected);
+        QWindowsStyle::drawTab(p, tabBar, tab, selected);
         return;
     }
     QPixmap tilePix;
@@ -2671,7 +2398,7 @@
         vFrame = 8; // was 10
     }
     else
-        KStyle::tabbarMetrics(t, hFrame, vFrame, overlap);
+        QWindowsStyle::tabbarMetrics(t, hFrame, vFrame, overlap);
 }
 
 
@@ -2699,7 +2426,7 @@
         p->drawLine(x+1, y+1, x+1, y2-1);
     }
     else if(lineWidth != 2 || !sunken)
-        KStyle::drawPanel(p, x, y, w, h, g, sunken, lineWidth, fill);
+        QWindowsStyle::drawPanel(p, x, y, w, h, g, sunken, lineWidth, fill);
     else{
         QPen oldPen = p->pen();
         int x2 = x+w-1;
@@ -2726,105 +2453,6 @@
     }
 }
 
-void LiquidStyle::drawKickerAppletHandle(QPainter *p, int x, int y, int w, int h,
-                                      const QColorGroup &g, QBrush *)
-{
-    p->fillRect(x, y, w, h, g.brush(QColorGroup::Background));
-    drawClearBevel(p, x, y, w, h, highlightWidget == p->device() ?
-                   g.button().light(120) : g.button(), g.button());
-    /*
-    if(h > w){
-        int y2 = y+h-1;
-
-        p->setPen(g.light());
-
-        p->drawLine(x+1, y+2, x+1, y2-2);
-        p->drawLine(x+4, y+2, x+4, y2-2);
-
-        p->setPen(g.dark());
-        p->drawLine(x+2, y+2, x+2, y2-2);
-        p->drawLine(x+5, y+2, x+5, y2-2);
-
-    }
-    else{
-        int x2 = x+w-1;
-
-        p->setPen(g.light());
-
-        p->drawLine(x+2, y+1, x2-2, y+1);
-        p->drawLine(x+2, y+4, x2-2, y+4);
-
-        p->setPen(g.dark());
-        p->drawLine(x+2, y+2, x2-2, y+2);
-        p->drawLine(x+2, y+5, x2-2, y+5);
-    }*/
-
-}
-
-void LiquidStyle::drawKickerTaskButton(QPainter *p, int x, int y, int w, int h,
-                                  const QColorGroup &g,
-                                  const QString &text, bool sunken,
-                                  QPixmap *pixmap, QBrush *)
-{
-    p->fillRect(x, y, w, h, g.brush(QColorGroup::Button));
-    drawClearBevel(p, x, y, w, h, sunken ? g.button() : g.background(), g.button());
-    p->setPen(g.buttonText()); // Kicker doesn't set this ;-)
-
-    if(text.isNull() && !pixmap)
-        return;
-
-    const int pxWidth = 20;
-    int textPos = pxWidth;
-    QRect br(buttonRect(x, y, w, h));
-
-    if (sunken)
-        p->translate(1,1);
-
-    if ( pixmap && !pixmap->isNull() ) {
-        int dx = ( pxWidth - pixmap->width() ) / 2;
-        int dy = ( h - pixmap->height() ) / 2;
-        p->drawPixmap( br.x()+dx, dy, *pixmap );
-    }
-
-    QString s = text;
-    static const QString &modStr = KGlobal::staticQString(
-           QString::fromUtf8("[") + i18n("modified") + QString::fromUtf8("]"));
-
-    int modStrPos = s.find(modStr);
-
-    if (-1 != modStrPos) {
-
-      // +1 because we include a space after the closing brace.
-      s.remove(modStrPos, modStr.length()+1);
-
-      QPixmap modPixmap = SmallIcon("modified");
-
-      int dx = (pxWidth   - modPixmap.width())  / 2;
-      int dy = (h  - modPixmap.height()) / 2;
-
-      p->drawPixmap(br.x() + textPos + dx, dy, modPixmap);
-
-      textPos += pxWidth;
-    }
-
-    if (!s.isEmpty()){
-        if (p->fontMetrics().width(s) > br.width() - textPos) {
-
-            int maxLen = br.width() - textPos - p->fontMetrics().width("...");
-
-            while ((!s.isEmpty()) && (p->fontMetrics().width(s) > maxLen))
-                s.truncate(s.length() - 1);
-
-            s.append("...");
-        }
-
-        p->setPen(g.buttonText());
-
-        p->drawText(br.x()+ textPos, -1, w-textPos, h,
-                    AlignLeft|AlignVCenter, s);
-    }
-
-}
 
 void LiquidStyle::adjustHSV(QPixmap &pix, int h, int s, int v)
 {
@@ -2988,110 +2616,5 @@
     }
 }
 
-// I'm debating if to use QValueList or QList here. I like QValueList better,
-// but QList handles pointers which is good for a lot of empty icons...
-
-void LiquidStyle::loadCustomButtons()
-{
-    return; // TODO
-    customBtnColorList.clear();
-    customBtnIconList.clear();
-    customBtnLabelList.clear();
-
-    KConfig *config = KGlobal::config();
-    QString oldGrp = config->group();
-    config->setGroup("MosfetButtons");
-
-    QStrList iconList, colorList; //temp, we store QPixmaps and QColors
-    iconList.setAutoDelete(true);
-    colorList.setAutoDelete(true);
-    config->readListEntry("Labels", customBtnLabelList);
-    config->readListEntry("Icons", iconList);
-    config->readListEntry("Colors", colorList);
-
-    const char *labelStr = customBtnLabelList.first();
-    const char *colorStr = colorList.first();
-    const char *iconStr = iconList.first();
-
-    KIconLoader *ldr = KGlobal::iconLoader();
-    while(labelStr != NULL){
-        QColor *c = new QColor;
-        c->setNamedColor(QString(colorStr));
-        customBtnColorList.append(c);
-
-        QString tmpStr(iconStr);
-        if(!tmpStr.isEmpty()){
-            QPixmap *pixmap =
-                new QPixmap(ldr->loadIcon(tmpStr, KIcon::Small));
-            if(pixmap->isNull()){
-                delete pixmap;
-                customBtnIconList.append(NULL);
-            }
-            else
-                customBtnIconList.append(pixmap);
-        }
-        else
-            customBtnIconList.append(NULL);
-
-        labelStr = customBtnLabelList.next();
-        colorStr = colorList.next();
-        iconStr = iconList.next();
-    }
-    config->setGroup(oldGrp);
-}
-
-void LiquidStyle::applyCustomAttributes(QPushButton *btn)
-{
-    return; // TODO
-    QString str = btn->text();
-    if(str.isEmpty())
-        return;
-    while(str.contains('&') != 0)
-        str = str.remove(str.find('&'), 1);
-
-    const char *s;
-    int idx = 0;
-    for(s = customBtnLabelList.first(); s != NULL;
-        ++idx, s = customBtnLabelList.next()){
-        if(qstricmp(s, str.latin1()) == 0){
-            QPalette pal = btn->palette();
-            pal.setColor(QColorGroup::Button,
-                         *customBtnColorList.at(idx));
-            btn->setPalette(pal);
-            /*
-            if(customBtnIconList.at(idx) != NULL){
-                QPixmap *pix = customBtnIconList.at(idx);
-                btn->setIconSet(QIconSet(*pix));
-            }*/
-            break;
-        }
-    }
-}
-
-void LiquidStyle::unapplyCustomAttributes(QPushButton *btn)
-{
-    return; // TODO
-    QString str = btn->text();
-    if(str.isEmpty())
-        return;
-    while(str.contains('&') != 0)
-        str = str.remove(str.find('&'), 1);
-
-    const char *s;
-    for(s = customBtnLabelList.first(); s != NULL; s = customBtnLabelList.next()){
-        if(qstricmp(s, str.latin1()) == 0){
-            btn->setPalette(QApplication::palette());
-            btn->setIconSet(QIconSet());
-            break;
-        }
-    }
-}
-
-#include "liquid.moc"
-
-
-
-
-
 
 /* vim: set noet sw=8 ts=8: */
--- -	2002-11-21 20:45:47.000000000 +0100
+++ plugin.cpp	2002-11-18 18:11:41.000000000 +0100
@@ -1,29 +1,84 @@
+#include <qapplication.h>
+
 #include "liquid.h"
-#include <klocale.h>
+#include "liquidset.h"
+#include "plugin.h"
+
+
+
+LiquidInterface::LiquidInterface ( ) :  ref ( 0 )
+{
+	m_widget = 0;
+}
+    
+LiquidInterface::~LiquidInterface ( )
+{
+}
+        
+QStyle *LiquidInterface::style ( )
+{
+	return new LiquidStyle ( );
+}
 
-extern "C" {
-    KStyle* allocate();
-    int minor_version();
-    int major_version();
-    const char *description();
+QString LiquidInterface::name ( ) const
+{
+	return qApp-> translate ( "Styles", "Liquid" );
 }
 
-KStyle* allocate()
+QString LiquidInterface::description ( ) const
 {
-    return(new LiquidStyle);
+	return qApp-> translate ( "Styles", "High Performance Liquid style by Mosfet" );
 }
 
-int minor_version()
+bool LiquidInterface::hasSettings ( ) const
 {
-    return(0);
+	return true;
 }
 
-int major_version()
+QWidget *LiquidInterface::create ( QWidget *parent, const char *name )
 {
-    return(1);
+	m_widget = new LiquidSettings ( parent, name ? name : "LIQUID-SETTINGS" );
+		
+	return m_widget;
 }
 
-const char *description()
+bool LiquidInterface::accept ( )
 {
-    return(i18n("High performance liquid plugin").utf8());
+	if ( !m_widget )
+		return false;
+
+	return m_widget-> writeConfig ( );
 }
+
+void LiquidInterface::reject ( )
+{
+}
+
+
+QRESULT LiquidInterface::queryInterface ( const QUuid &uuid, QUnknownInterface **iface )
+{
+	*iface = 0;
+	
+	if ( uuid == IID_QUnknown )
+		*iface = this;
+	else if ( uuid == IID_Style )
+		*iface = this;
+	else if ( uuid == IID_StyleExtended ) 
+		*iface = this;
+	
+	if ( *iface )
+		(*iface)-> addRef ( );
+		
+	return QS_OK;
+}
+
+Q_EXPORT_INTERFACE()
+{
+	Q_CREATE_INSTANCE( LiquidInterface )
+}
+
+
+// For Sharp ROM
+ 
+extern "C" { QStyle *allocate ( ) { return new LiquidStyle ( ); } }
+extern "C" { void drawmenubaritem ( QStyle *sty, QPainter *p, int x, int y, int w, int h, QMenuItem *mi, QColorGroup &g, bool enabled, bool active ) { return ((LiquidStyle *) sty )-> drawMenuBarItem ( p, x, y, w, h, mi, g, enabled, active ); } }
