--- src/kernel/qsoundqss_qws.cpp.orig	Wed Jan 30 12:49:24 2002
+++ src/kernel/qsoundqss_qws.cpp	Wed Jan 30 12:47:41 2002
@@ -142,6 +142,19 @@ public:
 	return wavedata_remaining < 0 || !max;
     }
 private:
+    int getOneSample() 
+    {
+	int sample;
+	if ( chunkdata.wBitsPerSample == 8 ) {
+	    sample = (data[out++] - 128) * 128;
+	    wavedata_remaining--;
+	} else {
+	    sample = ((short*)data)[out/2];
+	    out += 2;
+	    wavedata_remaining -= 2;
+	}
+	return sample;
+    }
     void getSample(int& l, int& r)
     {
 	l = r = 0;
@@ -152,38 +165,22 @@ private:
 		if ( out >= max ) {
 		    max = dev->readBlock((char*)data,
 			(uint)QMIN(sound_buffer_size,wavedata_remaining));
-		    wavedata_remaining -= max;
 		    out = 0;
 		    if ( max <= 0 ) {
 			max = 0;
 			return;
 		    }
 		}
-		if ( chunkdata.wBitsPerSample == 8 ) {
-		    l = (data[out++] - 128) * 128;
-		} else {
-		    l = ((short*)data)[out/2];
-		    out += 2;
-		}
+		l = getOneSample();
 		if ( sound_stereo ) {
 		    if ( chunkdata.channels == 1 ) {
 			r = l;
 		    } else {
-			if ( chunkdata.wBitsPerSample == 8 ) {
-			    r = (data[out++] - 128) * 128;
-			} else {
-			    r = ((short*)data)[out/2];
-			    out += 2;
-			}
+			r = getOneSample();
 		    }
 		} else {
 		    if ( chunkdata.channels == 2 ) {
-			if ( chunkdata.wBitsPerSample == 8 ) {
-			    r = (data[out++] - 128) * 128;
-			} else {
-			    r = ((short*)data)[out/2];
-			    out += 2;
-			}
+			r = getOneSample();
 			l = l + r;
 		    }
 		}

--- src/kernel/qpixmap_qws.cpp.orig	Mon Mar 11 17:00:03 2002
+++ src/kernel/qpixmap_qws.cpp	Mon Mar 11 17:01:05 2002
@@ -585,6 +585,13 @@ QPixmap QPixmap::xForm( const QWMatrix &
     QWMatrix mat( 1, 0, 0, 1, -xmin, -ymin );	// true matrix
     mat = matrix * mat;
 
+    // calculate new width and height
+    QPointArray a(  QRect( 0,0,ws,hs ) );
+    a = mat.map(  a );
+    QRect r = a.boundingRect().normalize();
+    w = r.width();
+    h = r.height();
+
     if ( matrix.m12() == 0.0F  && matrix.m21() == 0.0F &&
 	 matrix.m11() >= 0.0F  && matrix.m22() >= 0.0F &&
 	 depth() == defaultDepth() // ### stretchBlt limitation
@@ -593,11 +600,6 @@ QPixmap QPixmap::xForm( const QWMatrix &
 	if ( mat.m11() == 1.0F && mat.m22() == 1.0F )
 	    return *this;			// identity matrix
 
-	h = qRound( mat.m22()*hs );
-	w = qRound( mat.m11()*ws );
-	h = QABS( h );
-	w = QABS( w );
-
 	if(w==0 || h==0) {
 	    return *this;
 	}
@@ -618,12 +620,6 @@ QPixmap QPixmap::xForm( const QWMatrix &
 	}
 	return pm;
 
-    } else {					// rotation or shearing
-	QPointArray a( QRect(0,0,ws,hs) );
-	a = mat.map( a );
-	QRect r = a.boundingRect().normalize();
-	w = r.width();
-	h = r.height();
     }
     bool invertible;
     mat = mat.invert( &invertible );		// invert matrix
