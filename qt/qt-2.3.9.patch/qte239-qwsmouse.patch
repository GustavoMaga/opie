#
# Patch managed by http://www.holgerschurig.de/patcher.html
#

--- qt-2.3.9-snapshot-20041211/src/kernel/qwsmouse_qws.cpp~tslib.patch
+++ qt-2.3.9-snapshot-20041211/src/kernel/qwsmouse_qws.cpp
@@ -7,6 +7,14 @@
 **
 ** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
 **
+** Portions Copyright (C) 2003 Texas Instruments, Inc.
+**      Rights to said portions for use under the GPL and QPL licenses
+**     are hereby granted to Trolltech AS.
+**
+** Portions Copyright (C) 2004 Holger Hans Peter Freyther <freyther@handhelds.org>
+**      Rights to said portions for use under the GPL and QPL licenses
+**      are hereby granted to Trolltech AS.
+**
 ** This file is part of the kernel module of the Qt GUI Toolkit.
 **
 ** This file may be distributed and/or modified under the terms of the
@@ -60,6 +68,10 @@
 #include <linux/tpanel.h>
 #endif
 
+#ifdef QWS_TSLIB
+#include <tslib.h>
+#endif
+
 //#define QT_QWS_K2
 
 #if defined(QT_QWS_IPAQ) || defined(QT_QWS_K2)
@@ -1124,6 +1136,221 @@
     return sent;
 }
 
+
+class QTSLibHandler : public QCalibratedMouseHandler
+{
+    Q_OBJECT
+public:
+    QTSLibHandler();
+    ~QTSLibHandler();
+
+    virtual void clearCalibration();
+    virtual void calibrate( QWSPointerCalibrationData * );
+
+    static int sortByX( const void*, const void* );
+    static int sortByY( const void*, const void* );
+private:
+    void openTs();
+    void closeTs();
+    void interpolateSample();
+
+private:
+    bool raw : 1;
+#ifdef QWS_TSLIB
+    struct tsdev *ts;
+#endif
+    QSocketNotifier *m_notify;
+
+private slots:
+    void readMouseData();
+};
+
+QTSLibHandler::QTSLibHandler()
+    : raw(false), m_notify(0l)
+{
+    openTs();
+}
+
+QTSLibHandler::~QTSLibHandler()
+{
+    closeTs();
+}
+
+void QTSLibHandler::openTs()
+{
+#ifdef QWS_TSLIB
+    char *tsdevice;
+
+    if( ( tsdevice = getenv( "TSLIB_TSDEVICE" ) ) != NULL ) {
+        ts = ts_open( tsdevice, 1 );
+    } else {
+        ts = ts_open( "/dev/ts", 1 );
+    }
+
+    if (!ts) {
+        qWarning( "Cannot open touchscreen (%s)", strerror( errno ) );
+        return;
+    }
+
+    if (ts_config( ts )) {
+        qWarning( "Cannot configure touchscreen (%s)", strerror( errno ) );
+        return;
+    }
+
+
+    m_notify = new QSocketNotifier( ts_fd(ts), QSocketNotifier::Read, this );
+    connect( m_notify, SIGNAL(activated(int)), this, SLOT(readMouseData()));
+#endif
+}
+
+void QTSLibHandler::closeTs()
+{
+#ifdef QWS_TSLIB
+    if (ts)
+        ts_close(ts);
+
+    delete m_notify;
+    m_notify = 0; ts = 0;
+    raw = false;
+#endif
+
+}
+
+void QTSLibHandler::clearCalibration()
+{
+    raw = true;
+}
+
+
+void QTSLibHandler::calibrate( QWSPointerCalibrationData *cd )
+{
+    QPoint dev_tl = cd->devPoints[ QWSPointerCalibrationData::TopLeft ];
+    QPoint dev_br = cd->devPoints[ QWSPointerCalibrationData::BottomRight ];
+    QPoint screen_tl = cd->screenPoints[ QWSPointerCalibrationData::TopLeft ];
+    QPoint screen_br = cd->screenPoints[ QWSPointerCalibrationData::BottomRight ];
+    int a, b, c, d, e, f, s;
+
+    s = 1 << 16;
+
+    a = s * (screen_tl.x() - screen_br.x() ) / (dev_tl.x() - dev_br.x());
+    b = 0;
+    c = s * screen_tl.x() - a * dev_tl.x();
+
+    d = 0;
+    e = s * (screen_tl.y() - screen_br.y() ) / (dev_tl.y() - dev_br.y());
+    f = s * screen_tl.y() - e * dev_tl.y();
+
+    QString calFile = "/etc/pointercal";
+#ifndef QT_NO_TEXTSTREAM
+    QFile file( calFile );
+    if ( file.open( IO_WriteOnly ) ) {
+        QTextStream t( &file );
+        t << a << " " << b << " " << c << " ";
+        t << d << " " << e << " " << f << " " << s;
+       file.flush(); closeTs();
+       openTs();
+    } else
+#endif
+    {
+        qDebug( "Could not save calibration: %s", calFile.latin1() );
+    }
+}
+
+void QTSLibHandler::readMouseData()
+{
+#ifdef QWS_TSLIB
+    if(!qt_screen)
+        return;
+
+    /*
+     * After clear Calibration
+     * we're in raw mode and do some easy median
+     * search.
+     */
+    if (raw )
+        return interpolateSample();
+
+    static struct ts_sample sample;
+    static int ret;
+
+    /*
+     * Ok. We need to see if we can read more than one event
+     * We do this not to lose an update.
+     */
+    while ( true ) {
+        if ((ret = ts_read(ts, &sample, 1)) != 1 )
+            return;
+
+
+        QPoint pos( sample.x, sample.y );
+        emit mouseChanged( pos, sample.pressure != 0 ? 1 : 0 );
+    }
+#endif
+}
+
+
+/*
+ * Lets take all down events and then sort them
+ * and take the event in the middle.
+ *
+ * inspired by testutils.c
+ */
+void QTSLibHandler::interpolateSample() {
+    static struct ts_sample samples[25];
+    int index = 0;
+    int ret;
+
+    do {
+        /* fill only the last sample again */
+        if ( index >= 25 )
+            index = 24;
+
+        /* we're opened non-blocking */
+        if((ret= ts_read_raw(ts, &samples[index], 1 ) ) !=  1 ) {
+            /* no event yet, so try again */
+            if (ret==-1 ) {
+                index--;
+                continue;
+            }
+        }
+    }while (samples[index++].pressure != 0);
+
+    /*
+     * index is maximal 25  and we at least one sample
+     */
+    if( index >= 25 )
+        index = 24;
+    int x, y;
+
+    /*
+     * now let us use the median value
+     * even index does not have an item in the middle
+     * so let us take the average of n/2 and (n/2)-1 as the middle
+     */
+    int m = index/2;
+    ::qsort(samples, index, sizeof(ts_sample), QTSLibHandler::sortByX);
+    x = (index % 2 ) ? samples[m].x :
+        ( samples[m-1].x + samples[m].x )/2;
+
+    ::qsort(samples, index, sizeof(ts_sample), QTSLibHandler::sortByY);
+    y = (index % 2 ) ? samples[m].y :
+        ( samples[m-1].y + samples[m].y )/2;
+
+    emit mouseChanged( QPoint(x, y), 1 );
+    emit mouseChanged( QPoint(0, 0), 0 );
+}
+
+int QTSLibHandler::sortByX( const void* one, const void* two) {
+    return reinterpret_cast<const struct ts_sample*>(one)->x -
+           reinterpret_cast<const struct ts_sample*>(two)->x;
+}
+
+int QTSLibHandler::sortByY( const void* one, const void* two) {
+    return reinterpret_cast<const struct ts_sample*>(one)->y -
+           reinterpret_cast<const struct ts_sample*>(two)->y;
+}
+
+
 /*
  * Handler for /dev/tpanel Linux kernel driver
  */
@@ -1731,7 +1958,9 @@
 
        case TPanel:
 #if defined(QWS_CUSTOMTOUCHPANEL)
-           handler = new QCustomTPanelHandlerPrivate(mouseProtocol,mouseDev);
+            handler = new QCustomTPanelHandlerPrivate(mouseProtocol,mouseDev);
+#elif defined(QWS_TSLIB)
+            handler = new QTSLibHandler();
 #elif defined(QT_QWS_YOPY)
            handler = new QYopyTPanelHandlerPrivate(mouseProtocol,mouseDev);
 #elif defined(QT_QWS_IPAQ) || defined(QT_QWS_SL5XXX) || defined(QT_QWS_K2)
--- qt-2.3.9-snapshot-20041211/configure~tslib.patch
+++ qt-2.3.9-snapshot-20041211/configure
@@ -406,6 +406,9 @@
    -kde)
        KDE=yes
        ;;
+   -tslib)
+       TSLIB=YES
+       ;;
    -no-g++-exceptions)
        GPLUSPLUS_EXCEPTIONS=no
        ;;
@@ -1290,6 +1293,9 @@
                         set to point to a KDE 2 installation.
                          See http://www.kde.org
 
+    -tslib ............. Use the TSLib (touchscreen access library) mouse handler
+                         by default, instead of the normal device default.
+
     -no-g++-exceptions . Disable exceptions on platforms using the GNU C++
                         compiler by using the -fno-exceptions flag.
 
@@ -1353,6 +1359,13 @@
 [ "x$SM" = "xno" ] && QT_CXX="${QT_CXX} -DQT_NO_SM_SUPPORT"
 [ "x$XFT" = "xyes" ] && QT_CXX="${QT_CXX} -DQT_XFT"
 [ "x$XFT" = "xno" ] && QT_CXX="${QT_CXX} -DQT_NO_XKB"
+
+if [ "x$TSLIB" = "xyes" ]
+then
+   QT_CXX="${QT_CXX} -DQWS_TSLIB"
+   QT_LIBS="${QT_LIBS} -lts"
+fi
+
 if [ "x$THREAD" = "xyes" ]
 then
    cat >src-mt.mk <<EOF
