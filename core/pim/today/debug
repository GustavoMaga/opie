# 1 "today.cpp"

# 1 "today.h" 1



# 1 "todaybase.h" 1
 










# 1 "/opt/Qtopia/include/qvariant.h" 1
 








































# 1 "/opt/Qtopia/include/qstring.h" 1
 









































# 1 "/opt/Qtopia/include/qcstring.h" 1
 









































# 1 "/opt/Qtopia/include/qarray.h" 1
 








































# 1 "/opt/Qtopia/include/qgarray.h" 1
 








































# 1 "/opt/Qtopia/include/qshared.h" 1
 








































# 1 "/opt/Qtopia/include/qglobal.h" 1
 












































 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

# 100 "/opt/Qtopia/include/qglobal.h"


# 138 "/opt/Qtopia/include/qglobal.h"






 
 

 




 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 


 

# 190 "/opt/Qtopia/include/qglobal.h"

















# 280 "/opt/Qtopia/include/qglobal.h"



 
 













 
 
 
 
 
 
 
 
 
 

# 323 "/opt/Qtopia/include/qglobal.h"
















 
 
 
 
 
 




 
 
 
























typedef unsigned char	uchar;
typedef unsigned short	ushort;
typedef unsigned	uint;
typedef unsigned long	ulong;
typedef char	       *pchar;
typedef uchar	       *puchar;
typedef const char     *pcchar;


 
 
 


const bool FALSE = 0;
const bool TRUE = !0;














 
 
 





inline int qRound( double d )
{
    return d > 0.0 ? int(d+0.5) : int(d-0.5);
}


 
 
 

 
 

typedef signed char	INT8;			 
typedef unsigned char	UINT8;			 
typedef short		INT16;			 
typedef unsigned short	UINT16;			 
typedef int		INT32;			 
typedef unsigned int	UINT32;			 


typedef signed char	Q_INT8;			 
typedef unsigned char	Q_UINT8;		 
typedef short		Q_INT16;		 
typedef unsigned short	Q_UINT16;		 
typedef int		Q_INT32;		 
typedef unsigned int	Q_UINT32;		 
typedef long		Q_INT64;		 
typedef unsigned long	Q_UINT64;		 

 
 
 

class QDataStream;








# 1 "/opt/Qtopia/include/qfeatures.h" 1
 







































 



 
 
 
 
 



# 1 "/opt/Qtopia/include/qconfig.h" 1
 
 






















 

 
 
 
 













 

 
 


 

 





 






 



 
 
 











 

 


 


 



 






# 53 "/opt/Qtopia/include/qfeatures.h" 2




 
 


 








 







 


 

 


 
 


 

 


 


 
 








 





 
 





 
 










 





 
 





 
 




 

 



 
 



 
# 172 "/opt/Qtopia/include/qfeatures.h"


 
 




 
 








 






 

 






 


 
















 












 






 






 
 


 

 






 








 

 


 







 






     



     





 


 


 















 


 

 






 


 
 


 
 


 
 


 
 


                                        
 
 


 








 


 
 


 
 


 
 




 



 


 
 


 
 


 
 


 

 


 

 











 


 

 




 

 


 
















     














 


 
 


 
 


 
 












 


 

 
 


 
 


 
 





 






 






 






 
 


 

 








 


 
 


 
 


 

 


 


 






 






 


# 600 "/opt/Qtopia/include/qfeatures.h"







 





 





# 628 "/opt/Qtopia/include/qfeatures.h"



















 











 

















# 686 "/opt/Qtopia/include/qfeatures.h"







 





 


 
# 720 "/opt/Qtopia/include/qfeatures.h"









# 738 "/opt/Qtopia/include/qfeatures.h"















 





 





 











 





 


 
 





 




















# 823 "/opt/Qtopia/include/qfeatures.h"



     



     













 


 

 





 





 





 





 


 






























     



     











 


























     













     






     



















# 457 "/opt/Qtopia/include/qglobal.h" 2



 
 
 

# 482 "/opt/Qtopia/include/qglobal.h"









 
 
 

  const char *qVersion();
  bool qSysInfo( int *wordSize, bool *bigEndian );


 
 
 












 
 
 
 
 





# 541 "/opt/Qtopia/include/qglobal.h"



 
 
 





 
 
 




  void qDebug( const char *, ... )	 

    __attribute__ ((format (printf, 1, 2)))

;

  void qWarning( const char *, ... )	 

    __attribute__ ((format (printf, 1, 2)))

;

  void qFatal( const char *, ... )	 

    __attribute__ ((format (printf, 1, 2)))

;


 
 

 

  void debug( const char *, ... )	 

    __attribute__ ((format (printf, 1, 2)))

;

  void warning( const char *, ... )	 

    __attribute__ ((format (printf, 1, 2)))

;

  void fatal( const char *, ... )	 

    __attribute__ ((format (printf, 1, 2)))

;

 














  bool qt_check_pointer( bool c, const char *, int );







enum QtMsgType { QtDebugMsg, QtWarningMsg, QtFatalMsg };

typedef void (*msg_handler)(QtMsgType, const char *);
  msg_handler qInstallMsgHandler( msg_handler );


  void qSuppressObsoleteWarnings( bool = TRUE );



  void qObsolete( const char *obj, const char *oldfunc,
			 const char *newfunc );
  void qObsolete( const char *obj, const char *oldfunc );
  void qObsolete( const char *message );




# 42 "/opt/Qtopia/include/qshared.h" 2




struct QShared
{
    QShared()		{ count = 1; }
    void ref()		{ count++; }
    bool deref()	{ return !--count; }
    uint count;
};



# 42 "/opt/Qtopia/include/qgarray.h" 2




class   QGArray					 
{
friend class QBuffer;
public:
     
    struct array_data : public QShared {	 
	array_data()	{ data=0; len=0; }
	char *data;				 
	uint  len;
    };
    QGArray();
protected:
    QGArray( int, int );			 
    QGArray( int size );			 
    QGArray( const QGArray &a );		 
    virtual ~QGArray();

    QGArray    &operator=( const QGArray &a ) { return assign( a ); }

    virtual void detach()	{ duplicate(*this); }

    char       *data()	 const	{ return shd->data; }
    uint	nrefs()	 const	{ return shd->count; }
    uint	size()	 const	{ return shd->len; }
    bool	isEqual( const QGArray &a ) const;

    bool	resize( uint newsize );

    bool	fill( const char *d, int len, uint sz );

    QGArray    &assign( const QGArray &a );
    QGArray    &assign( const char *d, uint len );
    QGArray    &duplicate( const QGArray &a );
    QGArray    &duplicate( const char *d, uint len );
    void	store( const char *d, uint len );

    array_data *sharedBlock()	const		{ return shd; }
    void	setSharedBlock( array_data *p ) { shd=(array_data*)p; }

    QGArray    &setRawData( const char *d, uint len );
    void	resetRawData( const char *d, uint len );

    int		find( const char *d, uint index, uint sz ) const;
    int		contains( const char *d, uint sz ) const;
    
    void	sort( uint sz );
    int		bsearch( const char *d, uint sz ) const;

    char       *at( uint index ) const;

    bool	setExpand( uint index, const char *d, uint sz );

protected:
    virtual array_data *newData();
    virtual void deleteData( array_data *p );

private:
    static void msg_index( uint );
    array_data *shd;
};


inline char *QGArray::at( uint index ) const
{

    if ( index >= size() ) {
	msg_index( index );
	index = 0;
    }

    return &shd->data[index];
}



# 42 "/opt/Qtopia/include/qarray.h" 2




template<class type> class   QArray : public QGArray
{
public:
    typedef type* Iterator;
    typedef const type* ConstIterator;
    typedef type ValueType;

protected:
    QArray( int, int ) : QGArray( 0, 0 ) {}

public:
    QArray() {}
    QArray( int size ) : QGArray(size*sizeof(type)) {}
    QArray( const QArray<type> &a ) : QGArray(a) {}
   ~QArray() {}
    QArray<type> &operator=(const QArray<type> &a)
				{ return (QArray<type>&)QGArray::assign(a); }
    type *data()    const	{ return (type *)QGArray::data(); }
    uint  nrefs()   const	{ return QGArray::nrefs(); }
    uint  size()    const	{ return QGArray::size()/sizeof(type); }
    uint  count()   const 	{ return size(); }
    bool  isEmpty() const	{ return QGArray::size() == 0; }
    bool  isNull()  const	{ return QGArray::data() == 0; }
    bool  resize( uint size )	{ return QGArray::resize(size*sizeof(type)); }
    bool  truncate( uint pos )	{ return QGArray::resize(pos*sizeof(type)); }
    bool  fill( const type &d, int size = -1 )
	{ return QGArray::fill((char*)&d,size,sizeof(type) ); }
    void  detach()		{ QGArray::detach(); }
    QArray<type>   copy() const
	{ QArray<type> tmp; return tmp.duplicate(*this); }
    QArray<type>& assign( const QArray<type>& a )
	{ return (QArray<type>&)QGArray::assign(a); }
    QArray<type>& assign( const type *a, uint n )
	{ return (QArray<type>&)QGArray::assign((char*)a,n*sizeof(type)); }
    QArray<type>& duplicate( const QArray<type>& a )
	{ return (QArray<type>&)QGArray::duplicate(a); }
    QArray<type>& duplicate( const type *a, uint n )
	{ return (QArray<type>&)QGArray::duplicate((char*)a,n*sizeof(type)); }
    QArray<type>& setRawData( const type *a, uint n )
	{ return (QArray<type>&)QGArray::setRawData((char*)a,
						     n*sizeof(type)); }
    void resetRawData( const type *a, uint n )
	{ QGArray::resetRawData((char*)a,n*sizeof(type)); }
    int	 find( const type &d, uint i=0 ) const
	{ return QGArray::find((char*)&d,i,sizeof(type)); }
    int	 contains( const type &d ) const
	{ return QGArray::contains((char*)&d,sizeof(type)); }
    void sort() { QGArray::sort(sizeof(type)); }
    int  bsearch( const type &d ) const
	{ return QGArray::bsearch((const char*)&d,sizeof(type)); }
    type& operator[]( int i ) const
	{ return (type &)(*(type *)QGArray::at(i*sizeof(type))); }
    type& at( uint i ) const
	{ return (type &)(*(type *)QGArray::at(i*sizeof(type))); }
	 operator const type*() const { return (const type *)QGArray::data(); }
    bool operator==( const QArray<type> &a ) const { return isEqual(a); }
    bool operator!=( const QArray<type> &a ) const { return !isEqual(a); }
    Iterator begin() { return data(); }
    Iterator end() { return data() + size(); }
    ConstIterator begin() const { return data(); }
    ConstIterator end() const { return data() + size(); }
};



# 43 "/opt/Qtopia/include/qcstring.h" 2







# 1 "/usr/include/string.h" 1 3
 

















 






# 1 "/usr/include/features.h" 1 3
 




















 






























































 




















 





 



 







 
# 142 "/usr/include/features.h" 3


 









 








 



























# 208 "/usr/include/features.h" 3


































 



 


 








 




 
















 


# 1 "/usr/include/sys/cdefs.h" 1 3
 




















 




 






 





 








 



# 65 "/usr/include/sys/cdefs.h" 3


 





 




 









 







 

















 















 







 






 








 








 








 











 










 







 




 


















# 283 "/usr/include/features.h" 2 3



 








 





 

 








# 1 "/usr/include/gnu/stubs.h" 1 3
 



















# 312 "/usr/include/features.h" 2 3




# 26 "/usr/include/string.h" 2 3


extern "C" { 

 


# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 1 3






 


# 19 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3



 


 





 


# 61 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 





 


















 





 

 

# 131 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 


































typedef unsigned int size_t;






















 




 

# 271 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


# 283 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 

# 317 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3




 





















# 33 "/usr/include/string.h" 2 3



 
extern void *memcpy (void *__restrict __dest,
		     __const void *__restrict __src, size_t __n) throw () ;
 

extern void *memmove (void *__dest, __const void *__src, size_t __n)
     throw () ;

 



extern void *memccpy (void *__restrict __dest, __const void *__restrict __src,
		      int __c, size_t __n)
     throw () ;



 
extern void *memset (void *__s, int __c, size_t __n) throw () ;

 
extern int memcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw ()   ;

 
extern void *memchr (__const void *__s, int __c, size_t __n)
      throw ()   ;

# 73 "/usr/include/string.h" 3



 
extern char *strcpy (char *__restrict __dest, __const char *__restrict __src)
     throw () ;
 
extern char *strncpy (char *__restrict __dest,
		      __const char *__restrict __src, size_t __n) throw () ;

 
extern char *strcat (char *__restrict __dest, __const char *__restrict __src)
     throw () ;
 
extern char *strncat (char *__restrict __dest, __const char *__restrict __src,
		      size_t __n) throw () ;

 
extern int strcmp (__const char *__s1, __const char *__s2)
     throw ()   ;
 
extern int strncmp (__const char *__s1, __const char *__s2, size_t __n)
     throw ()   ;

 
extern int strcoll (__const char *__s1, __const char *__s2)
     throw ()   ;
 
extern size_t strxfrm (char *__restrict __dest,
		       __const char *__restrict __src, size_t __n) throw () ;

# 116 "/usr/include/string.h" 3



 
extern char *strdup (__const char *__s) throw ()   ;


 







# 152 "/usr/include/string.h" 3


 
extern char *strchr (__const char *__s, int __c) throw ()   ;
 
extern char *strrchr (__const char *__s, int __c) throw ()   ;







 

extern size_t strcspn (__const char *__s, __const char *__reject)
     throw ()   ;
 

extern size_t strspn (__const char *__s, __const char *__accept)
     throw ()   ;
 
extern char *strpbrk (__const char *__s, __const char *__accept)
     throw ()   ;
 
extern char *strstr (__const char *__haystack, __const char *__needle)
     throw ()   ;







 
extern char *strtok (char *__restrict __s, __const char *__restrict __delim)
     throw () ;

 

extern char *__strtok_r (char *__restrict __s,
			 __const char *__restrict __delim,
			 char **__restrict __save_ptr) throw () ;

extern char *strtok_r (char *__restrict __s, __const char *__restrict __delim,
		       char **__restrict __save_ptr) throw () ;


# 214 "/usr/include/string.h" 3



 
extern size_t strlen (__const char *__s) throw ()   ;









 
extern char *strerror (int __errnum) throw () ;

 

extern char *strerror_r (int __errnum, char *__buf, size_t __buflen) throw () ;


 

extern void __bzero (void *__s, size_t __n) throw () ;


 
extern void bcopy (__const void *__src, void *__dest, size_t __n) throw () ;

 
extern void bzero (void *__s, size_t __n) throw () ;

 
extern int bcmp (__const void *__s1, __const void *__s2, size_t __n)
     throw ()   ;

 
extern char *index (__const char *__s, int __c) throw ()   ;

 
extern char *rindex (__const char *__s, int __c) throw ()   ;

 

extern int ffs (int __i) throw ()  __attribute__ ((__const__));

 









 
extern int strcasecmp (__const char *__s1, __const char *__s2)
     throw ()   ;

 
extern int strncasecmp (__const char *__s1, __const char *__s2, size_t __n)
     throw ()   ;


# 289 "/usr/include/string.h" 3



 

extern char *strsep (char **__restrict __stringp,
		     __const char *__restrict __delim) throw () ;


# 332 "/usr/include/string.h" 3




# 361 "/usr/include/string.h" 3



} 


# 50 "/opt/Qtopia/include/qcstring.h" 2



 



# 71 "/opt/Qtopia/include/qcstring.h"



 



  void *qmemmove( void *dst, const void *src, uint len );





  char *qstrdup( const char * );

  inline uint cstrlen( const char *str )
{ return strlen(str); }

  inline uint qstrlen( const char *str )
{ return str ? strlen(str) : 0; }

  inline char *cstrcpy( char *dst, const char *src )
{ return strcpy(dst,src); }

  inline char *qstrcpy( char *dst, const char *src )
{ return src ? strcpy(dst, src) : 0; }

  char *qstrncpy( char *dst, const char *src, uint len );

  inline int cstrcmp( const char *str1, const char *str2 )
{ return strcmp(str1,str2); }

  inline int qstrcmp( const char *str1, const char *str2 )
{ return (str1 && str2) ? strcmp(str1,str2) : (int)((long)str2 - (long)str1); }

  inline int cstrncmp( const char *str1, const char *str2, uint len )
{ return strncmp(str1,str2,len); }

  inline int qstrncmp( const char *str1, const char *str2, uint len )
{ return (str1 && str2) ? strncmp(str1,str2,len) :
			  (int)((long)str2 - (long)str1); }

  int qstricmp( const char *, const char * );

  int qstrnicmp( const char *, const char *, uint len );

 
 
 
 
























 

  Q_UINT16 qChecksum( const char *s, uint len );

 






typedef QArray<char> QByteArray;


 



  QDataStream &operator<<( QDataStream &, const QByteArray & );
  QDataStream &operator>>( QDataStream &, QByteArray & );




 



class QRegExp;

class   QCString : public QByteArray	 
{
public:
    QCString() {}				 
    QCString( int size );			 
    QCString( const QCString &s ) : QByteArray( s ) {}
    QCString( const char *str );		 
    QCString( const char *str, uint maxlen );	 

    QCString    &operator=( const QCString &s ); 
    QCString    &operator=( const char *str );	 

    bool	isNull()	const;
    bool	isEmpty()	const;
    uint	length()	const;
    bool	resize( uint newlen );
    bool	truncate( uint pos );
    bool	fill( char c, int len = -1 );

    QCString	copy()	const;

    QCString    &sprintf( const char *format, ... );

    int		find( char c, int index=0, bool cs=TRUE ) const;
    int		find( const char *str, int index=0, bool cs=TRUE ) const;
    int		find( const QRegExp &, int index=0 ) const;
    int		findRev( char c, int index=-1, bool cs=TRUE) const;
    int		findRev( const char *str, int index=-1, bool cs=TRUE) const;
    int		findRev( const QRegExp &, int index=-1 ) const;
    int		contains( char c, bool cs=TRUE ) const;
    int		contains( const char *str, bool cs=TRUE ) const;
    int		contains( const QRegExp & ) const;

    QCString	left( uint len )  const;
    QCString	right( uint len ) const;
    QCString	mid( uint index, uint len=0xffffffff) const;

    QCString	leftJustify( uint width, char fill=' ', bool trunc=FALSE)const;
    QCString	rightJustify( uint width, char fill=' ',bool trunc=FALSE)const;

    QCString	lower() const;
    QCString	upper() const;

    QCString	stripWhiteSpace()	const;
    QCString	simplifyWhiteSpace()	const;

    QCString    &insert( uint index, const char * );
    QCString    &insert( uint index, char );
    QCString    &append( const char * );
    QCString    &prepend( const char * );
    QCString    &remove( uint index, uint len );
    QCString    &replace( uint index, uint len, const char * );
    QCString    &replace( const QRegExp &, const char * );

    short	toShort( bool *ok=0 )	const;
    ushort	toUShort( bool *ok=0 )	const;
    int		toInt( bool *ok=0 )	const;
    uint	toUInt( bool *ok=0 )	const;
    long	toLong( bool *ok=0 )	const;
    ulong	toULong( bool *ok=0 )	const;
    float	toFloat( bool *ok=0 )	const;
    double	toDouble( bool *ok=0 )	const;

    QCString    &setStr( const char *s );
    QCString    &setNum( short );
    QCString    &setNum( ushort );
    QCString    &setNum( int );
    QCString    &setNum( uint );
    QCString    &setNum( long );
    QCString    &setNum( ulong );
    QCString    &setNum( float, char f='g', int prec=6 );
    QCString    &setNum( double, char f='g', int prec=6 );

    bool	setExpand( uint index, char c );

		operator const char *() const;
    QCString    &operator+=( const char *str );
    QCString    &operator+=( char c );
};


 



  QDataStream &operator<<( QDataStream &, const QCString & );
  QDataStream &operator>>( QDataStream &, QCString & );


 



inline QCString &QCString::operator=( const QCString &s )
{ return (QCString&)assign( s ); }

inline QCString &QCString::operator=( const char *str )
{ return (QCString&)duplicate( str, qstrlen(str)+1 ); }

inline bool QCString::isNull() const
{ return data() == 0; }

inline bool QCString::isEmpty() const
{ return data() == 0 || *data() == '\0'; }

inline uint QCString::length() const
{ return qstrlen( data() ); }

inline bool QCString::truncate( uint pos )
{ return resize(pos+1); }

inline QCString QCString::copy() const
{ return QCString( data() ); }

inline QCString &QCString::prepend( const char *s )
{ return insert(0,s); }

inline QCString &QCString::append( const char *s )
{ return operator+=(s); }

inline QCString &QCString::setNum( short n )
{ return setNum((long)n); }

inline QCString &QCString::setNum( ushort n )
{ return setNum((ulong)n); }

inline QCString &QCString::setNum( int n )
{ return setNum((long)n); }

inline QCString &QCString::setNum( uint n )
{ return setNum((ulong)n); }

inline QCString &QCString::setNum( float n, char f, int prec )
{ return setNum((double)n,f,prec); }

inline QCString::operator const char *() const
{ return (const char *)data(); }


 



  inline bool operator==( const QCString &s1, const QCString &s2 )
{ return qstrcmp(s1.data(),s2.data()) == 0; }

  inline bool operator==( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) == 0; }

  inline bool operator==( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) == 0; }

  inline bool operator!=( const QCString &s1, const QCString &s2 )
{ return qstrcmp(s1.data(),s2.data()) != 0; }

  inline bool operator!=( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) != 0; }

  inline bool operator!=( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) != 0; }

  inline bool operator<( const QCString &s1, const QCString& s2 )
{ return qstrcmp(s1.data(),s2.data()) < 0; }

  inline bool operator<( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) < 0; }

  inline bool operator<( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) < 0; }

  inline bool operator<=( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) <= 0; }

  inline bool operator<=( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) <= 0; }

  inline bool operator>( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) > 0; }

  inline bool operator>( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) > 0; }

  inline bool operator>=( const QCString &s1, const char *s2 )
{ return qstrcmp(s1.data(),s2) >= 0; }

  inline bool operator>=( const char *s1, const QCString &s2 )
{ return qstrcmp(s1,s2.data()) >= 0; }

  inline QCString operator+( const QCString &s1, const QCString &s2 )
{
    QCString tmp( s1.data() );
    tmp += s2;
    return tmp;
}

  inline QCString operator+( const QCString &s1, const char *s2 )
{
    QCString tmp( s1.data() );
    tmp += s2;
    return tmp;
}

  inline QCString operator+( const char *s1, const QCString &s2 )
{
    QCString tmp( s1 );
    tmp += s2;
    return tmp;
}

  inline QCString operator+( const QCString &s1, char c2 )
{
    QCString tmp( s1.data() );
    tmp += c2;
    return tmp;
}

  inline QCString operator+( char c1, const QCString &s2 )
{
    QCString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}


# 43 "/opt/Qtopia/include/qstring.h" 2




 



class QRegExp;
class QString;
class QCharRef;

class   QChar {
public:
    QChar();
    QChar( char c );
    QChar( uchar c );
    QChar( uchar c, uchar r );
    QChar( const QChar& c );
    QChar( ushort rc );
    QChar( short rc );
    QChar( uint rc );
    QChar( int rc );

    static const  QChar null;             
    static const  QChar replacement;      
    static const  QChar byteOrderMark;      
    static const  QChar byteOrderSwapped;      
    static const  QChar nbsp;             

     

    enum Category
    {
	NoCategory,

	Mark_NonSpacing,	   
	Mark_SpacingCombining,	   
	Mark_Enclosing,		   

	Number_DecimalDigit,	   
	Number_Letter,		   
	Number_Other,		   

	Separator_Space,	   
	Separator_Line,		   
	Separator_Paragraph,	   

	Other_Control,		   
	Other_Format,		   
	Other_Surrogate,	   
	Other_PrivateUse,	   
	Other_NotAssigned,	   

	Letter_Uppercase,	   
	Letter_Lowercase,	   
	Letter_Titlecase,	   
	Letter_Modifier,	   
	Letter_Other,		   

	Punctuation_Connector,	   
	Punctuation_Dask,	   
	Punctuation_Open,	   
	Punctuation_Close,	   
	Punctuation_InitialQuote,  
	Punctuation_FinalQuote,	   
	Punctuation_Other,	   

	Symbol_Math,		   
	Symbol_Currency,	   
	Symbol_Modifier,	   
	Symbol_Other		   
    };

    enum Direction
    {
	DirL, DirR, DirEN, DirES, DirET, DirAN, DirCS, DirB, DirS, DirWS, DirON,
	DirLRE, DirLRO, DirAL, DirRLE, DirRLO, DirPDF, DirNSM, DirBN
    };

    enum Decomposition
    {
        Single, Canonical, Font, NoBreak, Initial, Medial,
        Final, Isolated, Circle, Super, Sub, Vertical,
        Wide, Narrow, Small, Square, Compat, Fraction
    };

    enum Joining
    {
	OtherJoining, Dual, Right, Center
    };

     

    int digitValue() const;
    QChar lower() const;
    QChar upper() const;

    Category category() const;
    Direction direction() const;
    Joining joining() const;
    bool mirrored() const;
    QChar mirroredChar() const;
    QString decomposition() const;
    Decomposition decompositionTag() const;

    char latin1() const { return rw ? 0 : cl; }
    ushort unicode() const { return (rw << 8) | cl; }

     
    operator char() const { return latin1(); }


    bool isNull() const { return unicode()==0; }
    bool isPrint() const;
    bool isPunct() const;
    bool isSpace() const;
    bool isMark() const;
    bool isLetter() const;
    bool isNumber() const;
    bool isLetterOrNumber() const;
    bool isDigit() const;

    uchar& cell() { return cl; }
    uchar& row() { return rw; }
    uchar cell() const { return cl; }
    uchar row() const { return rw; }

    static bool networkOrdered() { return (int)net_ordered == 1; }

    friend inline int operator==( char ch, QChar c );
    friend inline int operator==( QChar c, char ch );
    friend inline int operator==( QChar c1, QChar c2 );
    friend inline int operator!=( QChar c1, QChar c2 );
    friend inline int operator!=( char ch, QChar c );
    friend inline int operator!=( QChar c, char ch );
    friend inline int operator<=( QChar c, char ch );
    friend inline int operator<=( char ch, QChar c );
    friend inline int operator<=( QChar c1, QChar c2 );

private:

     
     
    uchar rw;
    uchar cl;



    enum { net_ordered = 1 };
# 201 "/opt/Qtopia/include/qstring.h"

}  ;

inline QChar::QChar()
{
    rw = 0; cl = 0;



}
inline QChar::QChar( char c )
{
    rw = 0; cl = (uchar)c;



}
inline QChar::QChar( uchar c )
{
    rw = 0; cl = c;



}
inline QChar::QChar( uchar c, uchar r )
{
    rw = r; cl = c;



}
inline QChar::QChar( const QChar& c )
{
    rw = c.rw; cl = c.cl;



}
inline QChar::QChar( ushort rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}
inline QChar::QChar( short rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}
inline QChar::QChar( uint rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}
inline QChar::QChar( int rc )
{
    rw = (uchar)((rc>>8)&0xff); cl = (uchar)(rc&0xff);



}


inline int operator==( char ch, QChar c )
{
    return ch == c.cl && !c.rw;
}

inline int operator==( QChar c, char ch )
{
    return ch == c.cl && !c.rw;
}

inline int operator==( QChar c1, QChar c2 )
{
    return c1.cl == c2.cl
	&& c1.rw == c2.rw;
}

inline int operator!=( QChar c1, QChar c2 )
{
    return c1.cl != c2.cl
	|| c1.rw != c2.rw;
}

inline int operator!=( char ch, QChar c )
{
    return ch != c.cl || c.rw;
}

inline int operator!=( QChar c, char ch )
{
    return ch != c.cl || c.rw;
}

inline int operator<=( QChar c, char ch )
{
    return !(ch < c.cl || c.rw);
}

inline int operator<=( char ch, QChar c )
{
    return ch <= c.cl || c.rw;
}

inline int operator<=( QChar c1, QChar c2 )
{
    return c1.rw > c2.rw
	? FALSE
	: c1.rw < c2.rw
	    ? TRUE
	    : c1.cl <= c2.cl;
}

inline int operator>=( QChar c, char ch ) { return ch <= c; }
inline int operator>=( char ch, QChar c ) { return c <= ch; }
inline int operator>=( QChar c1, QChar c2 ) { return c2 <= c1; }
inline int operator<( QChar c, char ch ) { return !(ch<=c); }
inline int operator<( char ch, QChar c ) { return !(c<=ch); }
inline int operator<( QChar c1, QChar c2 ) { return !(c2<=c1); }
inline int operator>( QChar c, char ch ) { return !(ch>=c); }
inline int operator>( char ch, QChar c ) { return !(c>=ch); }
inline int operator>( QChar c1, QChar c2 ) { return !(c2>=c1); }

 
struct   QStringData : public QShared {
    QStringData() :
	unicode(0), ascii(0), len(0), maxl(0), dirtyascii(0) { ref(); }
    QStringData(QChar *u, uint l, uint m) :
	unicode(u), ascii(0), len(l), maxl(m), dirtyascii(0) { }

    ~QStringData() { if ( unicode ) delete[] ((char*)unicode);
                     if ( ascii ) delete[] ascii; }

    void deleteSelf();
    QChar *unicode;
    char *ascii;
    uint len;
    uint maxl:30;
    uint dirtyascii:1;
};


class   QString
{
public:
    QString();					 
    QString( QChar );				 
    QString( const QString & );			 
    QString( const QByteArray& );		 
    QString( const QChar* unicode, uint length );  

    QString( const char *str );			 

    ~QString();

    QString    &operator=( const QString & );	 

    QString    &operator=( const char * );	 

    QString    &operator=( const QCString& );	 
    QString    &operator=( QChar c );
    QString    &operator=( char c );

    static const  QString null;

    bool	isNull()	const;
    bool	isEmpty()	const;
    uint	length()	const;
    void	truncate( uint pos );




    void	fill( QChar c, int len = -1 );

    QString	copy()	const;

    QString arg(long a, int fieldwidth=0, int base=10) const;
    QString arg(ulong a, int fieldwidth=0, int base=10) const;
    QString arg(int a, int fieldwidth=0, int base=10) const;
    QString arg(uint a, int fieldwidth=0, int base=10) const;
    QString arg(short a, int fieldwidth=0, int base=10) const;
    QString arg(ushort a, int fieldwidth=0, int base=10) const;
    QString arg(char a, int fieldwidth=0) const;
    QString arg(QChar a, int fieldwidth=0) const;
    QString arg(const QString& a, int fieldwidth=0) const;
    QString arg(double a, int fieldwidth=0, char fmt='g', int prec=-1) const;

    QString    &sprintf( const char* format, ... )

	__attribute__ ((format (printf, 2, 3)))

	;

    int		find( QChar c, int index=0, bool cs=TRUE ) const;
    int		find( char c, int index=0, bool cs=TRUE ) const;
    int		find( const QString &str, int index=0, bool cs=TRUE ) const;
    int		find( const QRegExp &, int index=0 ) const;

    int		find( const char* str, int index=0 ) const;

    int		findRev( QChar c, int index=-1, bool cs=TRUE) const;
    int		findRev( char c, int index=-1, bool cs=TRUE) const;
    int		findRev( const QString &str, int index=-1, bool cs=TRUE) const;
    int		findRev( const QRegExp &, int index=-1 ) const;

    int		findRev( const char* str, int index=-1 ) const;

    int		contains( QChar c, bool cs=TRUE ) const;
    int		contains( char c, bool cs=TRUE ) const
		    { return contains(QChar(c), cs); }

    int		contains( const char* str, bool cs=TRUE ) const;

    int		contains( const QString &str, bool cs=TRUE ) const;
    int		contains( const QRegExp & ) const;

    QString	left( uint len )  const;
    QString	right( uint len ) const;
    QString	mid( uint index, uint len=0xffffffff) const;

    QString	leftJustify( uint width, QChar fill=' ', bool trunc=FALSE)const;
    QString	rightJustify( uint width, QChar fill=' ',bool trunc=FALSE)const;

    QString	lower() const;
    QString	upper() const;

    QString	stripWhiteSpace()	const;
    QString	simplifyWhiteSpace()	const;

    QString    &insert( uint index, const QString & );
    QString    &insert( uint index, const QChar*, uint len );
    QString    &insert( uint index, QChar );
    QString    &insert( uint index, char c ) { return insert(index,QChar(c)); }
    QString    &append( char );
    QString    &append( QChar );
    QString    &append( const QString & );
    QString    &prepend( char );
    QString    &prepend( QChar );
    QString    &prepend( const QString & );
    QString    &remove( uint index, uint len );
    QString    &replace( uint index, uint len, const QString & );
    QString    &replace( uint index, uint len, const QChar*, uint clen );
    QString    &replace( const QRegExp &, const QString & );

    short	toShort( bool *ok=0, int base=10 )	const;
    ushort	toUShort( bool *ok=0, int base=10 )	const;
    int		toInt( bool *ok=0, int base=10 )	const;
    uint	toUInt( bool *ok=0, int base=10 )	const;
    long	toLong( bool *ok=0, int base=10 )	const;
    ulong	toULong( bool *ok=0, int base=10 )	const;
    float	toFloat( bool *ok=0 )	const;
    double	toDouble( bool *ok=0 )	const;

    QString    &setNum( short, int base=10 );
    QString    &setNum( ushort, int base=10 );
    QString    &setNum( int, int base=10 );
    QString    &setNum( uint, int base=10 );
    QString    &setNum( long, int base=10 );
    QString    &setNum( ulong, int base=10 );
    QString    &setNum( float, char f='g', int prec=6 );
    QString    &setNum( double, char f='g', int prec=6 );

    static QString number( long, int base=10 );
    static QString number( ulong, int base=10);
    static QString number( int, int base=10 );
    static QString number( uint, int base=10);
    static QString number( double, char f='g', int prec=6 );

    void	setExpand( uint index, QChar c );

    QString    &operator+=( const QString &str );
    QString    &operator+=( QChar c );
    QString    &operator+=( char c );

     
    QChar at( uint i ) const
	{ return i<d->len ? d->unicode[i] : QChar::null; }
    QChar operator[]( int i ) const { return at((uint)i); }
    QCharRef at( uint i );
    QCharRef operator[]( int i );

    QChar constref(uint i) const
	{ return at(i); }
    QChar& ref(uint i)
	{  
	    if (d->count!=1 || i>=d->len)
		subat(i);
	    d->dirtyascii=1;
	    return d->unicode[i];
	}

    const QChar* unicode() const { return d->unicode; }
    const char* ascii() const;
    const char* latin1() const;
    static QString fromLatin1(const char*, int len=-1);

    QCString utf8() const;
    static QString fromUtf8(const char*, int len=-1);

    QCString local8Bit() const;
    static QString fromLocal8Bit(const char*, int len=-1);
    bool operator!() const;

    operator const char *() const { return latin1(); }


    QString &setUnicode( const QChar* unicode, uint len );
    QString &setUnicodeCodes( const ushort* unicode_as_ushorts, uint len );
    QString &setLatin1( const char*, int len=-1 );

    int compare( const QString& s ) const;
    static int compare( const QString& s1, const QString& s2 )
	{ return s1.compare(s2); }


    friend   QDataStream &operator>>( QDataStream &, QString & );

     
    void compose();
    QChar::Direction basicDirection();
    QString visual(int index = 0, int len = -1);


    const char* data() const { return latin1(); }


    bool startsWith( const QString& ) const;

private:
    QString( int size, bool   );	 

    void deref();
    void real_detach();
    void setLength( uint pos );
    void subat( uint );
    bool findArg(int& pos, int& len) const;

    static QChar* asciiToUnicode( const char*, uint * len, uint maxlen=(uint)-1 );
    static QChar* asciiToUnicode( const QByteArray&, uint * len );
    static char* unicodeToAscii( const QChar*, uint len );

    QStringData *d;
    static QStringData* shared_null;
    static QStringData* makeSharedNull();

    friend class QConstString;
    QString(QStringData* dd, bool  ) : d(dd) { }
};

class   QCharRef {
    friend class QString;
    QString& s;
    uint p;
    QCharRef(QString* str, uint pos) : s(*str), p(pos) { }

public:
     

     

    ushort unicode() const { return s.constref(p).unicode(); }
    char latin1() const { return s.constref(p).latin1(); }

     
    QCharRef operator=(char c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(uchar c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(QChar c ) { s.ref(p)=c; return *this; }
    QCharRef operator=(const QCharRef& c ) { s.ref(p)=c.unicode(); return *this; }
    QCharRef operator=(ushort rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(short rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(uint rc ) { s.ref(p)=rc; return *this; }
    QCharRef operator=(int rc ) { s.ref(p)=rc; return *this; }

    operator QChar () const { return s.constref(p); }

     
    bool isNull() const { return unicode()==0; }
    bool isPrint() const { return s.constref(p).isPrint(); }
    bool isPunct() const { return s.constref(p).isPunct(); }
    bool isSpace() const { return s.constref(p).isSpace(); }
    bool isMark() const { return s.constref(p).isMark(); }
    bool isLetter() const { return s.constref(p).isLetter(); }
    bool isNumber() const { return s.constref(p).isNumber(); }
    bool isLetterOrNumber() { return s.constref(p).isLetterOrNumber(); }
    bool isDigit() const { return s.constref(p).isDigit(); }

    int digitValue() const { return s.constref(p).digitValue(); }
    QChar lower() { return s.constref(p).lower(); }
    QChar upper() { return s.constref(p).upper(); }

    QChar::Category category() const { return s.constref(p).category(); }
    QChar::Direction direction() const { return s.constref(p).direction(); }
    QChar::Joining joining() const { return s.constref(p).joining(); }
    bool mirrored() const { return s.constref(p).mirrored(); }
    QChar mirroredChar() const { return s.constref(p).mirroredChar(); }
    QString decomposition() const { return s.constref(p).decomposition(); }
    QChar::Decomposition decompositionTag() const { return s.constref(p).decompositionTag(); }

     
    uchar cell() const { return s.constref(p).cell(); }
    uchar row() const { return s.constref(p).row(); }

};

inline QCharRef QString::at( uint i ) { return QCharRef(this,i); }
inline QCharRef QString::operator[]( int i ) { return at((uint)i); }


class   QConstString : private QString {
public:
    QConstString( QChar* unicode, uint length );
    ~QConstString();
    const QString& string() const { return *this; }
};


 



  QDataStream &operator<<( QDataStream &, const QString & );
  QDataStream &operator>>( QDataStream &, QString & );


 



 
 
 
 
 
inline QString::QString() :
    d(shared_null ? shared_null : makeSharedNull())
{
    d->ref();
}
 
inline QString::~QString()
{
    if ( d->deref() ) {
	if ( d == shared_null )
	    shared_null = 0;
	d->deleteSelf();
    }
}

inline QString &QString::operator=( QChar c )
{ return *this = QString(c); }

inline QString &QString::operator=( char c )
{ return *this = QString(QChar(c)); }

inline bool QString::isNull() const
{ return unicode() == 0; }

inline bool QString::operator!() const
{ return isNull(); }

inline uint QString::length() const
{ return d->len; }

inline bool QString::isEmpty() const
{ return length() == 0; }

inline QString QString::copy() const
{ return QString( *this ); }

inline QString &QString::prepend( const QString & s )
{ return insert(0,s); }

inline QString &QString::prepend( QChar c )
{ return insert(0,c); }

inline QString &QString::prepend( char c )
{ return insert(0,c); }

inline QString &QString::append( const QString & s )
{ return operator+=(s); }

inline QString &QString::append( QChar c )
{ return operator+=(c); }

inline QString &QString::append( char c )
{ return operator+=(c); }

inline QString &QString::setNum( short n, int base )
{ return setNum((long)n, base); }

inline QString &QString::setNum( ushort n, int base )
{ return setNum((ulong)n, base); }

inline QString &QString::setNum( int n, int base )
{ return setNum((long)n, base); }

inline QString &QString::setNum( uint n, int base )
{ return setNum((ulong)n, base); }

inline QString &QString::setNum( float n, char f, int prec )
{ return setNum((double)n,f,prec); }

inline QString QString::arg(int a, int fieldwidth, int base) const
{ return arg((long)a, fieldwidth, base); }

inline QString QString::arg(uint a, int fieldwidth, int base) const
{ return arg((ulong)a, fieldwidth, base); }

inline QString QString::arg(short a, int fieldwidth, int base) const
{ return arg((long)a, fieldwidth, base); }

inline QString QString::arg(ushort a, int fieldwidth, int base) const
{ return arg((ulong)a, fieldwidth, base); }

inline int QString::find( char c, int index, bool cs ) const
{ return find(QChar(c), index, cs); }

inline int QString::findRev( char c, int index, bool cs) const
{ return findRev( QChar(c), index, cs ); }



inline int QString::find( const char* str, int index ) const
{ return find(QString::fromLatin1(str), index); }

inline int QString::findRev( const char* str, int index ) const
{ return findRev(QString::fromLatin1(str), index); }



 



  bool operator!=( const QString &s1, const QString &s2 );
  bool operator<( const QString &s1, const QString &s2 );
  bool operator<=( const QString &s1, const QString &s2 );
  bool operator==( const QString &s1, const QString &s2 );
  bool operator>( const QString &s1, const QString &s2 );
  bool operator>=( const QString &s1, const QString &s2 );

  bool operator!=( const QString &s1, const char *s2 );
  bool operator<( const QString &s1, const char *s2 );
  bool operator<=( const QString &s1, const char *s2 );
  bool operator==( const QString &s1, const char *s2 );
  bool operator>( const QString &s1, const char *s2 );
  bool operator>=( const QString &s1, const char *s2 );
  bool operator!=( const char *s1, const QString &s2 );
  bool operator<( const char *s1, const QString &s2 );
  bool operator<=( const char *s1, const QString &s2 );
  bool operator==( const char *s1, const QString &s2 );
 
  bool operator>=( const char *s1, const QString &s2 );


  inline QString operator+( const QString &s1, const QString &s2 )
{
    QString tmp( s1 );
    tmp += s2;
    return tmp;
}


  inline QString operator+( const QString &s1, const char *s2 )
{
    QString tmp( s1 );
    tmp += QString::fromLatin1(s2);
    return tmp;
}

  inline QString operator+( const char *s1, const QString &s2 )
{
    QString tmp = QString::fromLatin1( s1 );
    tmp += s2;
    return tmp;
}


  inline QString operator+( const QString &s1, QChar c2 )
{
    QString tmp( s1 );
    tmp += c2;
    return tmp;
}

  inline QString operator+( const QString &s1, char c2 )
{
    QString tmp( s1 );
    tmp += c2;
    return tmp;
}

  inline QString operator+( QChar c1, const QString &s2 )
{
    QString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}

  inline QString operator+( char c1, const QString &s2 )
{
    QString tmp;
    tmp += c1;
    tmp += s2;
    return tmp;
}










# 42 "/opt/Qtopia/include/qvariant.h" 2





class QString;
class QCString;
class QFont;
class QPixmap;
class QBrush;
class QRect;
class QPoint;
class QImage;
class QSize;
class QColor;
class QPalette;
class QColorGroup;
class QIconSet;
class QDataStream;
class QPointArray;
class QRegion;
class QBitmap;
class QCursor;
class QStringList;
class QSizePolicy;
 
 
class QVariant;
class QVariantPrivate;
template <class T> class QValueList;
template <class T> class QValueListConstIterator;
template <class T> class QValueListNode;
template <class Key, class T> class QMap;
template <class Key, class T> class QMapConstIterator;


class   QVariant
{
public:
    enum Type {
	Invalid,
	Map,
	List,
	String,
	StringList,
	Font,
	Pixmap,
	Brush,
	Rect,
	Size,
	Color,
	Palette,
	ColorGroup,
	IconSet,
	Point,
	Image,
	Int,
	UInt,
	Bool,
	Double,
	CString,
	PointArray,
	Region,
	Bitmap,
	Cursor,
	SizePolicy
    };

    QVariant();
    ~QVariant();
    QVariant( const QVariant& );
    QVariant( QDataStream& s );

    QVariant( const QString& );
    QVariant( const QCString& );
    QVariant( const char* );
    QVariant( const QStringList& );
    QVariant( const QFont& );
    QVariant( const QPixmap& );
    QVariant( const QImage& );
    QVariant( const QBrush& );
    QVariant( const QPoint& );
    QVariant( const QRect& );
    QVariant( const QSize& );
    QVariant( const QColor& );
    QVariant( const QPalette& );
    QVariant( const QColorGroup& );
    QVariant( const QIconSet& );
    QVariant( const QPointArray& );
    QVariant( const QRegion& );
    QVariant( const QBitmap& );
    QVariant( const QCursor& );
    QVariant( const QValueList<QVariant>& );
    QVariant( const QMap<QString,QVariant>& );
    QVariant( int );
    QVariant( uint );
     
    QVariant( bool, int );
    QVariant( double );
    QVariant( QSizePolicy );

    QVariant& operator= ( const QVariant& );
    bool operator==( const QVariant& ) const;
    bool operator!=( const QVariant& ) const;

    Type type() const;
    const char* typeName() const;

    bool canCast( Type ) const;

    bool isValid() const;

    void clear();

    const QString toString() const;
    const QCString toCString() const;
    const QStringList toStringList() const;
    const QFont toFont() const;
    const QPixmap toPixmap() const;
    const QImage toImage() const;
    const QBrush toBrush() const;
    const QPoint toPoint() const;
    const QRect toRect() const;
    const QSize toSize() const;
    const QColor toColor() const;
    const QPalette toPalette() const;
    const QColorGroup toColorGroup() const;
    const QIconSet toIconSet() const;
    const QPointArray toPointArray() const;
    const QBitmap toBitmap() const;
    const QRegion toRegion() const;
    const QCursor toCursor() const;
    int toInt() const;
    uint toUInt() const;
    bool toBool() const;
    double toDouble() const;
    const QValueList<QVariant> toList() const;
    const QMap<QString,QVariant> toMap() const;
    QSizePolicy toSizePolicy() const;

    QValueListConstIterator<QVariant> listBegin() const;
    QValueListConstIterator<QVariant> listEnd() const;
    QValueListConstIterator<QString> stringListBegin() const;
    QValueListConstIterator<QString> stringListEnd() const;
    QMapConstIterator<QString,QVariant> mapBegin() const;
    QMapConstIterator<QString,QVariant> mapEnd() const;
    QMapConstIterator<QString,QVariant> mapFind( const QString& ) const;

    QString& asString();
    QCString& asCString();
    QStringList& asStringList();
    QFont& asFont();
    QPixmap& asPixmap();
    QImage& asImage();
    QBrush& asBrush();
    QPoint& asPoint();
    QRect& asRect();
    QSize& asSize();
    QColor& asColor();
    QPalette& asPalette();
    QColorGroup& asColorGroup();
    QIconSet& asIconSet();
    QPointArray& asPointArray();
    QBitmap& asBitmap();
    QRegion& asRegion();
    QCursor& asCursor();
    int& asInt();
    uint& asUInt();
    bool& asBool();
    double& asDouble();
    QValueList<QVariant>& asList();
    QMap<QString,QVariant>& asMap();
    QSizePolicy& asSizePolicy();

    void load( QDataStream& );
    void save( QDataStream& ) const;

    static const char* typeToName( Type typ );
    static Type nameToType( const char* name );

private:
    void detach();

    QVariantPrivate* d;
};

class QVariantPrivate : public QShared
{
public:
    QVariantPrivate();
    QVariantPrivate( QVariantPrivate* );
    ~QVariantPrivate();

    void clear();

    QVariant::Type typ;
    union
    {
	uint u;
	int i;
	bool b;
	double d;
	void *ptr;
    } value;
};

 

# 1 "/opt/Qtopia/include/qvaluelist.h" 1
 









































# 1 "/opt/Qtopia/include/qdatastream.h" 1
 








































# 1 "/opt/Qtopia/include/qiodevice.h" 1
 













































 






 




 









 





 












class   QIODevice					 
{
public:
    QIODevice();
    virtual ~QIODevice();

    int		 flags()  const { return ioMode; }
    int		 mode()	  const { return ioMode & 0x00ff ; }
    int		 state()  const { return ioMode & 0xf000 ; }

    bool	 isDirectAccess()     const { return ((ioMode & 0x0100 )     == 0x0100 ); }
    bool	 isSequentialAccess() const { return ((ioMode & 0x0200 ) == 0x0200 ); }
    bool	 isCombinedAccess()   const { return ((ioMode & 0x0300 )   == 0x0300 ); }
    bool	 isBuffered()	      const { return ((ioMode & 0x0040 )        != 0x0040 ); }
    bool	 isRaw()	      const { return ((ioMode & 0x0040 )        == 0x0040 ); }
    bool	 isSynchronous()      const { return ((ioMode & 0x0080 )      != 0x0080 ); }
    bool	 isAsynchronous()     const { return ((ioMode & 0x0080 )      == 0x0080 ); }
    bool	 isTranslated()	      const { return ((ioMode & 0x0010 )  == 0x0010 ); }
    bool	 isReadable()	      const { return ((ioMode & 0x0001 )   == 0x0001 ); }
    bool	 isWritable()	      const { return ((ioMode & 0x0002 )  == 0x0002 ); }
    bool	 isReadWrite()	      const { return ((ioMode & 0x0003 )  == 0x0003 ); }
    bool	 isInactive()	      const { return state() == 0; }
    bool	 isOpen()	      const { return state() == 0x1000 ; }

    int		 status() const { return ioSt; }
    void	 resetStatus()	{ ioSt = 0 ; }

    virtual bool open( int mode ) = 0;
    virtual void close() = 0;
    virtual void flush() = 0;

    virtual uint size()	  const = 0;
    virtual int	 at()	  const;
    virtual bool at( int );
    virtual bool atEnd()  const;
    bool	 reset() { return at(0); }

    virtual int	 readBlock( char *data, uint maxlen ) = 0;
    virtual int	 writeBlock( const char *data, uint len ) = 0;
    virtual int	 readLine( char *data, uint maxlen );
    int writeBlock( const QByteArray& data );
    QByteArray readAll();

    virtual int	 getch() = 0;
    virtual int	 putch( int ) = 0;
    virtual int	 ungetch( int ) = 0;

protected:
    void	 setFlags( int f ) { ioMode = f; }
    void	 setType( int );
    void	 setMode( int );
    void	 setState( int );
    void	 setStatus( int );
    int		 ioIndex;

private:
    int		 ioMode;
    int		 ioSt;

private:	 

    QIODevice( const QIODevice & );
    QIODevice &operator=( const QIODevice & );

};



# 42 "/opt/Qtopia/include/qdatastream.h" 2





class   QDataStream				 
{
public:
    QDataStream();
    QDataStream( QIODevice * );
    QDataStream( QByteArray, int mode );
    virtual ~QDataStream();

    QIODevice	*device() const;
    void	 setDevice( QIODevice * );
    void	 unsetDevice();

    bool	 atEnd() const;
    bool	 eof() const;

    enum ByteOrder { BigEndian, LittleEndian };
    int		 byteOrder()	const;
    void	 setByteOrder( int );

    bool	 isPrintableData() const;
    void	 setPrintableData( bool );

    int		 version() const;
    void	 setVersion( int );

    QDataStream &operator>>( Q_INT8 &i );
    QDataStream &operator>>( Q_UINT8 &i );
    QDataStream &operator>>( Q_INT16 &i );
    QDataStream &operator>>( Q_UINT16 &i );
    QDataStream &operator>>( Q_INT32 &i );
    QDataStream &operator>>( Q_UINT32 &i );
    QDataStream &operator>>( Q_INT64 &i );
    QDataStream &operator>>( Q_UINT64 &i );

    QDataStream &operator>>( float &f );
    QDataStream &operator>>( double &f );
    QDataStream &operator>>( char *&str );

    QDataStream &operator<<( Q_INT8 i );
    QDataStream &operator<<( Q_UINT8 i );
    QDataStream &operator<<( Q_INT16 i );
    QDataStream &operator<<( Q_UINT16 i );
    QDataStream &operator<<( Q_INT32 i );
    QDataStream &operator<<( Q_UINT32 i );
    QDataStream &operator<<( Q_INT64 i );
    QDataStream &operator<<( Q_UINT64 i );
    QDataStream &operator<<( float f );
    QDataStream &operator<<( double f );
    QDataStream &operator<<( const char *str );

    QDataStream &readBytes( char *&, uint &len );
    QDataStream &readRawBytes( char *, uint len );

    QDataStream &writeBytes( const char *, uint len );
    QDataStream &writeRawBytes( const char *, uint len );

private:
    QIODevice	*dev;
    bool	 owndev;
    int		 byteorder;
    bool	 printable;
    bool	 noswap;
    int		 ver;

private:	 

    QDataStream( const QDataStream & );
    QDataStream &operator=( const QDataStream & );

};


 



inline QIODevice *QDataStream::device() const
{ return dev; }

inline bool QDataStream::atEnd() const
{ return dev ? dev->atEnd() : TRUE; }

inline bool QDataStream::eof() const
{ return atEnd(); }

inline int QDataStream::byteOrder() const
{ return byteorder; }

inline bool QDataStream::isPrintableData() const
{ return printable; }

inline void QDataStream::setPrintableData( bool p )
{ printable = p; }

inline int QDataStream::version() const
{ return ver; }

inline void QDataStream::setVersion( int v )
{ ver = v; }

inline QDataStream &QDataStream::operator>>( Q_UINT8 &i )
{ return *this >> (Q_INT8&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT16 &i )
{ return *this >> (Q_INT16&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT32 &i )
{ return *this >> (Q_INT32&)i; }

inline QDataStream &QDataStream::operator>>( Q_UINT64 &i )
{ return *this >> (Q_INT64&)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT8 i )
{ return *this << (Q_INT8)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT16 i )
{ return *this << (Q_INT16)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT32 i )
{ return *this << (Q_INT32)i; }

inline QDataStream &QDataStream::operator<<( Q_UINT64 i )
{ return *this << (Q_INT64)i; }




# 43 "/opt/Qtopia/include/qvaluelist.h" 2







template <class T>
class   QValueListNode
{
public:
    QValueListNode( const T& t ) : data( t ) { }
    QValueListNode() { }





    QValueListNode<T>* next;
    QValueListNode<T>* prev;
    T data;
};

template<class T>
class   QValueListIterator
{
 public:
     


    typedef QValueListNode<T>* NodePtr;

     


    NodePtr node;

     


    QValueListIterator() : node( 0 ) {}
    QValueListIterator( NodePtr p ) : node( p ) {}
    QValueListIterator( const QValueListIterator<T>& it ) : node( it.node ) {}

    bool operator==( const QValueListIterator<T>& it ) const { return node == it.node; }
    bool operator!=( const QValueListIterator<T>& it ) const { return node != it.node; }
    const T& operator*() const { return node->data; }
    T& operator*() { return node->data; }

     
     

    QValueListIterator<T>& operator++() {
	node = node->next;
	return *this;
    }

    QValueListIterator<T> operator++(int) {
	QValueListIterator<T> tmp = *this;
	node = node->next;
	return tmp;
    }

    QValueListIterator<T>& operator--() {
	node = node->prev;
	return *this;
    }

    QValueListIterator<T> operator--(int) {
	QValueListIterator<T> tmp = *this;
	node = node->prev;
	return tmp;
    }
};

template<class T>
class   QValueListConstIterator
{
 public:
     


    typedef QValueListNode<T>* NodePtr;

     


    NodePtr node;

     


    QValueListConstIterator() : node( 0 ) {}
    QValueListConstIterator( NodePtr p ) : node( p ) {}
    QValueListConstIterator( const QValueListConstIterator<T>& it ) : node( it.node ) {}
    QValueListConstIterator( const QValueListIterator<T>& it ) : node( it.node ) {}

    bool operator==( const QValueListConstIterator<T>& it ) const { return node == it.node; }
    bool operator!=( const QValueListConstIterator<T>& it ) const { return node != it.node; }
    const T& operator*() const { return node->data; }

     
     

    QValueListConstIterator<T>& operator++() {
	node = node->next;
	return *this;
    }

    QValueListConstIterator<T> operator++(int) {
	QValueListConstIterator<T> tmp = *this;
	node = node->next;
	return tmp;
    }

    QValueListConstIterator<T>& operator--() {
	node = node->prev;
	return *this;
    }

    QValueListConstIterator<T> operator--(int) {
	QValueListConstIterator<T> tmp = *this;
	node = node->prev;
	return tmp;
    }
};

template <class T>
class   QValueListPrivate : public QShared
{
public:
     


    typedef QValueListIterator<T> Iterator;
    typedef QValueListConstIterator<T> ConstIterator;
    typedef QValueListNode<T> Node;
    typedef QValueListNode<T>* NodePtr;

     


    QValueListPrivate() { node = new Node; node->next = node->prev = node; nodes = 0; }
    QValueListPrivate( const QValueListPrivate<T>& _p ) : QShared() {
	node = new Node; node->next = node->prev = node; nodes = 0;
	Iterator b( _p.node->next );
	Iterator e( _p.node );
	Iterator i( node );
	while( b != e )
	    insert( i, *b++ );
    }

    void derefAndDelete()  
    {
	if ( deref() )
	    delete this;
    }





    ~QValueListPrivate() {
	NodePtr p = node->next;
	while( p != node ) {
	    NodePtr x = p->next;
	    delete p;
	    p = x;
	}
	delete node;
    }

    Iterator insert( Iterator it, const T& x ) {
	NodePtr p = new Node( x );
	p->next = it.node;
	p->prev = it.node->prev;
	it.node->prev->next = p;
	it.node->prev = p;
	nodes++;
	return p;
    }

    Iterator remove( Iterator it ) {
	((  it.node != node  ) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","it.node != node","/opt/Qtopia/include/qvaluelist.h",226)) ;
	NodePtr next = it.node->next;
	NodePtr prev = it.node->prev;
	prev->next = next;
	next->prev = prev;
	delete it.node;
	nodes--;
	return Iterator( next );
    }

    NodePtr find( NodePtr start, const T& x ) const {
	ConstIterator first( start );
	ConstIterator last( node );
	while( first != last) {
	    if ( *first == x )
		return first.node;
	    ++first;
	}
	return last.node;
    }

    int findIndex( NodePtr start, const T& x ) const {
	ConstIterator first( start );
	ConstIterator last( node );
	int pos = 0;
	while( first != last) {
	    if ( *first == x )
		return pos;
	    ++first;
	    ++pos;
	}
	return -1;
    }

    uint contains( const T& x ) const {
	uint result = 0;
	Iterator first = Iterator( node->next );
	Iterator last = Iterator( node );
	while( first != last) {
	    if ( *first == x )
		++result;
	    ++first;
	}
	return result;
    }

    void remove( const T& x ) {
	Iterator first = Iterator( node->next );
	Iterator last = Iterator( node );
	while( first != last) {
	    if ( *first == x )
		first = remove( first );
	    else
		++first;
	}
    }

    NodePtr at( uint i ) const {
	((  i <= nodes  ) ? (void)0 : qWarning("ASSERT: \"%s\" in %s (%d)","i <= nodes","/opt/Qtopia/include/qvaluelist.h",284)) ;
	NodePtr p = node->next;
	for( uint x = 0; x < i; ++x )
	    p = p->next;
	return p;
    }

    void clear() {
	nodes = 0;
	NodePtr p = node->next;
	while( p != node ) {
	    NodePtr next = p->next;
	    delete p;
	    p = next;
	}
	node->next = node->prev = node;
    }

    NodePtr node;
    uint nodes;
};

template <class T>
class   QValueList
{
public:
     


    typedef QValueListIterator<T> Iterator;
    typedef QValueListConstIterator<T> ConstIterator;
    typedef T ValueType;

     


    QValueList() { sh = new QValueListPrivate<T>; }
    QValueList( const QValueList<T>& l ) { sh = l.sh; sh->ref(); }
    ~QValueList() { sh->derefAndDelete(); }

    QValueList<T>& operator= ( const QValueList<T>& l )
    {
	l.sh->ref();
	sh->derefAndDelete();
	sh = l.sh;
	return *this;
    }

    QValueList<T> operator+ ( const QValueList<T>& l ) const
    {
	QValueList<T> l2( *this );
	for( ConstIterator it = l.begin(); it != l.end(); ++it )
	    l2.append( *it );
	return l2;
    }

    QValueList<T>& operator+= ( const QValueList<T>& l )
    {
	for( ConstIterator it = l.begin(); it != l.end(); ++it )
	    append( *it );
	return *this;
    }

    bool operator== ( const QValueList<T>& l ) const
    {
	if ( count() != l.count() )
	    return FALSE;
	ConstIterator it2 = begin();
	ConstIterator it = l.begin();
	for( ; it != l.end(); ++it, ++it2 )
	    if ( !( *it == *it2 ) )
		return FALSE;
	return TRUE;
    }

    bool operator!= ( const QValueList<T>& l ) const { return !( *this == l ); }

    Iterator begin() { detach(); return Iterator( sh->node->next ); }
    ConstIterator begin() const { return ConstIterator( sh->node->next ); }
    Iterator end() { detach(); return Iterator( sh->node ); }
    ConstIterator end() const { return ConstIterator( sh->node ); }
    Iterator fromLast() { detach(); return Iterator( sh->node->prev ); }
    ConstIterator fromLast() const { return ConstIterator( sh->node->prev ); }

    bool isEmpty() const { return ( sh->nodes == 0 ); }

    Iterator insert( Iterator it, const T& x ) { detach(); return sh->insert( it, x ); }

    Iterator append( const T& x ) { detach(); return sh->insert( end(), x ); }
    Iterator prepend( const T& x ) { detach(); return sh->insert( begin(), x ); }

    Iterator remove( Iterator it ) { detach(); return sh->remove( it ); }
    void remove( const T& x ) { detach(); sh->remove( x ); }

    T& first() { detach(); return sh->node->next->data; }
    const T& first() const { return sh->node->next->data; }
    T& last() { detach(); return sh->node->prev->data; }
    const T& last() const { return sh->node->prev->data; }

    T& operator[] ( uint i ) { detach(); return sh->at(i)->data; }
    const T& operator[] ( uint i ) const { return sh->at(i)->data; }
    Iterator at( uint i ) { detach(); return Iterator( sh->at(i) ); }
    ConstIterator at( uint i ) const { return ConstIterator( sh->at(i) ); }
    Iterator find ( const T& x ) { detach(); return Iterator( sh->find( sh->node->next, x) ); }
    ConstIterator find ( const T& x ) const { return ConstIterator( sh->find( sh->node->next, x) ); }
    Iterator find ( Iterator it, const T& x ) { detach(); return Iterator( sh->find( it.node, x ) ); }
    ConstIterator find ( ConstIterator it, const T& x ) const { return ConstIterator( sh->find( it.node, x ) ); }
    int findIndex( const T& x ) const { return sh->findIndex( sh->node->next, x) ; }
    uint contains( const T& x ) const { return sh->contains( x ); }

    uint count() const { return sh->nodes; }

    void clear() { if ( sh->count == 1 ) sh->clear(); else { sh->deref(); sh = new QValueListPrivate<T>; } }


    QValueList<T>& operator+= ( const T& x )
    {
	append( x );
	return *this;
    }
    QValueList<T>& operator<< ( const T& x )
    {
	append( x );
	return *this;
    }


protected:
     


    void detach() { if ( sh->count > 1 ) { sh->deref(); sh = new QValueListPrivate<T>( *sh ); } }

     


    QValueListPrivate<T>* sh;
};


template<class T>
inline QDataStream& operator>>( QDataStream& s, QValueList<T>& l )
{
    l.clear();
    Q_UINT32 c;
    s >> c;
    for( Q_UINT32 i = 0; i < c; ++i )
    {
	T t;
	s >> t;
	l.append( t );
    }
    return s;
}

template<class T>
inline QDataStream& operator<<( QDataStream& s, const QValueList<T>& l )
{
    s << (Q_UINT32)l.count();
    QValueListConstIterator<T> it = l.begin();
    for( ; it != l.end(); ++it )
	s << *it;
    return s;
}


# 250 "/opt/Qtopia/include/qvariant.h" 2

# 1 "/opt/Qtopia/include/qstringlist.h" 1
 










































# 1 "/opt/Qtopia/include/qregexp.h" 1
 












































class   QRegExp
{
public:
    QRegExp();
    QRegExp( const QString &, bool caseSensitive=TRUE, bool wildcard=FALSE );
    QRegExp( const QRegExp & );
   ~QRegExp();
    QRegExp    &operator=( const QRegExp & );
    QRegExp    &operator=( const QString &pattern );

    bool	operator==( const QRegExp & )  const;
    bool	operator!=( const QRegExp &r ) const
					{ return !(this->operator==(r)); }

    bool	isEmpty()	const	{ return rxdata == 0; }
    bool	isValid()	const	{ return error == 0; }

    bool	caseSensitive() const	{ return cs; }
    void	setCaseSensitive( bool );

    bool	wildcard()	const	{ return wc; }
    void	setWildcard( bool );

    QString	pattern()	const	{ return rxstring; }
     
    void	setPattern( const QString& pattern )
					{ operator=( pattern ); }

    int		match( const QString &str, int index=0, int *len=0,
		       bool indexIsStart = TRUE ) const;
    int		find( const QString& str, int index )
					{ return match( str, index ); }

protected:
    void	compile();
    const QChar *matchstr( uint *, const QChar *, uint, const QChar * ) const;

private:
    QString	rxstring;			 
    uint	*rxdata;			 
    int		error;				 
    bool	cs;				 
    bool	wc;				 
};



# 44 "/opt/Qtopia/include/qstringlist.h" 2





class QStrList;

class   QStringList : public QValueList<QString>
{
public:
    QStringList() { }
    QStringList( const QStringList& l ) : QValueList<QString>(l) { }
    QStringList( const QValueList<QString>& l ) : QValueList<QString>(l) { }
    QStringList( const QString& i ) { append(i); }

    QStringList( const char* i ) { append(i); }


    static QStringList fromStrList(const QStrList&);

    void sort();

    static QStringList split( const QString &sep, const QString &str, bool allowEmptyEntries = FALSE );
    static QStringList split(  const QChar &sep, const QString &str, bool allowEmptyEntries = FALSE );
    static QStringList split(  const QRegExp &sep, const QString &str, bool allowEmptyEntries = FALSE );
    QString join( const QString &sep ) const;

    QStringList grep( const QString &str, bool cs = TRUE ) const;
    QStringList grep( const QRegExp &expr ) const;
};


class QDataStream;
extern   QDataStream &operator>>( QDataStream &, QStringList& );
extern   QDataStream &operator<<( QDataStream &, const QStringList& );



# 251 "/opt/Qtopia/include/qvariant.h" 2

# 1 "/opt/Qtopia/include/qmap.h" 1
 













































struct QMapNodeBase
{
    enum Color { Red, Black };

    QMapNodeBase* left;
    QMapNodeBase* right;
    QMapNodeBase* parent;

    Color color;

    QMapNodeBase* minimum() {
	QMapNodeBase* x = this;
	while ( x->left )
	    x = x->left;
	return x;
    }

    QMapNodeBase* maximum() {
	QMapNodeBase* x = this;
	while ( x->right )
	    x = x->right;
	return x;
    }
};


template <class K, class T>
struct QMapNode : public QMapNodeBase
{
    QMapNode( const K& _key, const T& _data ) { data = _data; key = _key; }
    QMapNode( const K& _key )	   { key = _key; }
    QMapNode( const QMapNode<K,T>& _n ) { key = _n.key; data = _n.data; }
    QMapNode() { }
    T data;
    K key;
};


template<class K, class T>
class   QMapIterator
{
 public:
     


    typedef QMapNode< K, T >* NodePtr;

     


    QMapNode<K,T>* node;

     


    QMapIterator() : node( 0 ) {}
    QMapIterator( QMapNode<K,T>* p ) : node( p ) {}
    QMapIterator( const QMapIterator<K,T>& it ) : node( it.node ) {}

    bool operator==( const QMapIterator<K,T>& it ) const { return node == it.node; }
    bool operator!=( const QMapIterator<K,T>& it ) const { return node != it.node; }
    T& operator*() { return node->data; }
    const T& operator*() const { return node->data; }

     
     

    const K& key() const { return node->key; }
    T& data() { return node->data; }
    const T& data() const { return node->data; }

private:
    int inc() {
	QMapNodeBase* tmp = node;
	if ( tmp->right ) {
	    tmp = tmp->right;
	    while ( tmp->left )
		tmp = tmp->left;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->right) {
		tmp = y;
		y = y->parent;
	    }
	    if (tmp->right != y)
		tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

    int dec() {
	QMapNodeBase* tmp = node;
	if (tmp->color == QMapNodeBase::Red &&
	    tmp->parent->parent == tmp ) {
	    tmp = tmp->right;
	} else if (tmp->left != 0) {
	    QMapNodeBase* y = tmp->left;
	    while ( y->right )
		y = y->right;
	    tmp = y;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->left) {
		tmp = y;
		y = y->parent;
	    }
	    tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

public:
    QMapIterator<K,T>& operator++() {
	inc();
	return *this;
    }

    QMapIterator<K,T> operator++(int) {
	QMapIterator<K,T> tmp = *this;
	inc();
	return tmp;
    }

    QMapIterator<K,T>& operator--() {
	dec();
	return *this;
    }

    QMapIterator<K,T> operator--(int) {
	QMapIterator<K,T> tmp = *this;
	dec();
	return tmp;
    }
};

template<class K, class T>
class   QMapConstIterator
{
 public:
     


    typedef QMapNode< K, T >* NodePtr;

     


    QMapNode<K,T>* node;

     


    QMapConstIterator() : node( 0 ) {}
    QMapConstIterator( QMapNode<K,T>* p ) : node( p ) {}
    QMapConstIterator( const QMapConstIterator<K,T>& it ) : node( it.node ) {}
    QMapConstIterator( const QMapIterator<K,T>& it ) : node( it.node ) {}

    bool operator==( const QMapConstIterator<K,T>& it ) const { return node == it.node; }
    bool operator!=( const QMapConstIterator<K,T>& it ) const { return node != it.node; }
    const T& operator*()  const { return node->data; }

     
     

    const K& key() const { return node->key; }
    const T& data() const { return node->data; }

private:
    int inc() {
        QMapNodeBase* tmp = node;
	if ( tmp->right ) {
	    tmp = tmp->right;
	    while ( tmp->left )
		tmp = tmp->left;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->right) {
		tmp = y;
		y = y->parent;
	    }
	    if (tmp->right != y)
		tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

    int dec() {
	QMapNodeBase* tmp = node;
	if (tmp->color == QMapNodeBase::Red &&
	    tmp->parent->parent == tmp ) {
	    tmp = tmp->right;
	} else if (tmp->left != 0) {
	    QMapNodeBase* y = tmp->left;
	    while ( y->right )
		y = y->right;
	    tmp = y;
	} else {
	    QMapNodeBase* y = tmp->parent;
	    while (tmp == y->left) {
		tmp = y;
		y = y->parent;
	    }
	    tmp = y;
	}
	node = (NodePtr)tmp;
	return 0;
    }

public:
    QMapConstIterator<K,T>& operator++() {
	inc();
	return *this;
    }

    QMapConstIterator<K,T> operator++(int) {
	QMapConstIterator<K,T> tmp = *this;
	inc();
	return tmp;
    }

    QMapConstIterator<K,T>& operator--() {
	dec();
	return *this;
    }

    QMapConstIterator<K,T> operator--(int) {
	QMapConstIterator<K,T> tmp = *this;
	dec();
	return tmp;
    }
};


class   QMapPrivateBase : public QShared
{
public:
    QMapPrivateBase() {
	node_count = 0;
    }
    QMapPrivateBase( const QMapPrivateBase* _map) {
	node_count = _map->node_count;
    }

     


    void rotateLeft( QMapNodeBase* x, QMapNodeBase*& root);
    void rotateRight( QMapNodeBase* x, QMapNodeBase*& root );
    void rebalance( QMapNodeBase* x, QMapNodeBase*& root );
    QMapNodeBase* removeAndRebalance( QMapNodeBase* z, QMapNodeBase*& root,
				      QMapNodeBase*& leftmost,
				      QMapNodeBase*& rightmost );

     


    int node_count;
};


template <class Key, class T>
class QMapPrivate : public QMapPrivateBase
{
public:
     


    typedef QMapIterator< Key, T > Iterator;
    typedef QMapConstIterator< Key, T > ConstIterator;
    typedef QMapNode< Key, T > Node;
    typedef QMapNode< Key, T >* NodePtr;

     


    QMapPrivate() {
	header = new Node;
	header->color = QMapNodeBase::Red;  
	header->parent = 0;
	header->left = header->right = header;
    }
    QMapPrivate( const QMapPrivate< Key, T >* _map ) : QMapPrivateBase( _map ) {
	header = new Node;
	header->color = QMapNodeBase::Red;  
	if ( _map->header->parent == 0 ) {
	    header->parent = 0;
	    header->left = header->right = header;
	} else {
	    header->parent = copy( (NodePtr)(_map->header->parent) );
	    header->parent->parent = header;
	    header->left = header->parent->minimum();
	    header->right = header->parent->maximum();
	}
    }
    ~QMapPrivate() { clear(); delete header; }

    NodePtr copy( NodePtr p ) {
	if ( !p )
	    return 0;
	NodePtr n = new Node( *p );
	n->color = p->color;
	if ( p->left ) {
	    n->left = copy( (NodePtr)(p->left) );
	    n->left->parent = n;
	} else {
	    n->left = 0;
	}
	if ( p->right ) {
	    n->right = copy( (NodePtr)(p->right) );
	    n->right->parent = n;
	} else {
	    n->right = 0;
	}
	return n;
    }

    void clear() {
	clear( (NodePtr)(header->parent) );
	header->color = QMapNodeBase::Red;
	header->parent = 0;
	header->left = header->right = header;
	node_count = 0;
    }

    void clear( NodePtr p ) {
	while ( p != 0 ) {
	    clear( (NodePtr)p->right );
	    NodePtr y = (NodePtr)p->left;
	    delete p;
	    p = y;
	}
    }

    Iterator begin()	{ return Iterator( (NodePtr)(header->left ) ); }
    Iterator end()	{ return Iterator( header ); }
    ConstIterator begin() const { return ConstIterator( (NodePtr)(header->left ) ); }
    ConstIterator end() const { return ConstIterator( header ); }

    ConstIterator find(const Key& k) const {
	QMapNodeBase* y = header;         
	QMapNodeBase* x = header->parent;  

	while ( x != 0 ) {
	     
	    if ( !( key(x) < k ) ) {
		y = x;
		x = x->left;
	    } else {
		x = x->right;
	    }
	}

	 
	 
	if ( y == header || k < key(y) )
	    return ConstIterator( header );
	return ConstIterator( (NodePtr)y );
    }

    void remove( Iterator it ) {
	NodePtr del = (NodePtr) removeAndRebalance( it.node, header->parent, header->left, header->right );
	delete del;
	--node_count;
    }

# 425 "/opt/Qtopia/include/qmap.h"


    Iterator insertMulti(const Key& v){
	QMapNodeBase* y = header;
	QMapNodeBase* x = header->parent;
	while (x != 0){
	    y = x;
	    x = ( v < key(x) ) ? x->left : x->right;
	}
	return insert(x, y, v);
    }

    Iterator insertSingle( const Key& k ) {
	 
	QMapNodeBase* y = header;
	QMapNodeBase* x = header->parent;
	bool result = TRUE;
	while ( x != 0 ) {
	    result = ( k < key(x) );
	    y = x;
	    x = result ? x->left : x->right;
	}
	 
	Iterator j( (NodePtr)y );
	if ( result ) {
	     
	    if ( j == begin() ) {
		return insert(x, y, k );
	    } else {
		 
		--j;
	    }
	}
	 
	if ( (j.node->key) < k )
	    return insert(x, y, k );
	 
	return j;
    }

    Iterator insert( QMapNodeBase* x, QMapNodeBase* y, const Key& k ) {
	NodePtr z = new Node( k );
	if (y == header || x != 0 || k < key(y) ) {
	    y->left = z;                 
	    if ( y == header ) {
		header->parent = z;
		header->right = z;
	    } else if ( y == header->left )
		header->left = z;            
	} else {
	    y->right = z;
	    if ( y == header->right )
		header->right = z;           
	}
	z->parent = y;
	z->left = 0;
	z->right = 0;
	rebalance( z, header->parent );
	++node_count;
	return Iterator(z);
    }

protected:
     


    const Key& key( QMapNodeBase* b ) const { return ((NodePtr)b)->key; }

     


    NodePtr header;
};


template<class Key, class T>
class   QMap
{
public:
     


    typedef QMapIterator< Key, T > Iterator;
    typedef QMapConstIterator< Key, T > ConstIterator;
    typedef T ValueType;
    typedef QMapPrivate< Key, T > Priv;

     


    QMap() { sh = new QMapPrivate< Key, T >; }
    QMap( const QMap<Key,T>& m ) { sh = m.sh; sh->ref(); }
    ~QMap() { if ( sh->deref() ) delete sh; }

    QMap<Key,T>& operator= ( const QMap<Key,T>& m )
      { m.sh->ref(); if ( sh->deref() ) delete sh; sh = m.sh; return *this; }

    Iterator begin() { detach(); return sh->begin(); }
    Iterator end() { detach(); return sh->end(); }
    ConstIterator begin() const { return ((const Priv*)sh)->begin(); }
    ConstIterator end() const { return ((const Priv*)sh)->end(); }

    Iterator find ( const Key& k )
	{ detach(); return Iterator( sh->find( k ).node ); }
    ConstIterator find ( const Key& k ) const
	{ return sh->find( k ); }
    T& operator[] ( const Key& k ) {
	detach(); QMapNode<Key,T>* p = sh->find( k ).node;
	if ( p != sh->end().node ) return p->data;
	return insert( k, T() ).data(); }
    const T& operator[] ( const Key& k ) const
	{ return sh->find( k ).data(); }
    bool contains ( const Key& k ) const
	{ return find( k ) != end(); }
	 

    uint count() const { return sh->node_count; }

    bool isEmpty() const { return sh->node_count == 0; }

    Iterator insert( const Key& key, const T& value ) {
        detach();
        Iterator it = sh->insertSingle( key );
        it.data() = value;
        return it;
    }

    void remove( Iterator it ) { detach(); sh->remove( it ); }
    void remove( const Key& k ) {
        detach();
        Iterator it( sh->find( k ).node );
        if ( it != end() )
            sh->remove( it );
    }

    Iterator replace( const Key& k, const T& v ) {
	remove( k );
	return insert( k, v );
    }

    void clear() { if ( sh->count == 1 ) sh->clear(); else { sh->deref(); sh = new QMapPrivate<Key,T>; } }





protected:
     


    void detach() { if ( sh->count > 1 ) { sh->deref(); sh = new QMapPrivate<Key,T>( sh ); } }

    Priv* sh;
};



template<class Key, class T>
inline QDataStream& operator>>( QDataStream& s, QMap<Key,T>& m ) {
    m.clear();
    Q_UINT32 c;
    s >> c;
    for( Q_UINT32 i = 0; i < c; ++i ) {
	Key k; T t;
	s >> k >> t;
	m.insert( k, t );
    }
    return s;
}


template<class Key, class T>
inline QDataStream& operator<<( QDataStream& s, const QMap<Key,T>& m ) {
    s << (Q_UINT32)m.count();
    QMapConstIterator<Key,T> it = m.begin();
    for( ; it != m.end(); ++it )
	s << it.key() << it.data();
    return s;
}



# 252 "/opt/Qtopia/include/qvariant.h" 2



inline QVariant::Type QVariant::type() const
{
    return d->typ;
}

inline bool QVariant::isValid() const
{
    return (d->typ != Invalid);
}

inline QValueListConstIterator<QString> QVariant::stringListBegin() const
{
    if ( d->typ != StringList )
	return QValueListConstIterator<QString>();
    return ((const QStringList*)d->value.ptr)->begin();
}

inline QValueListConstIterator<QString> QVariant::stringListEnd() const
{
    if ( d->typ != StringList )
	return QValueListConstIterator<QString>();
    return ((const QStringList*)d->value.ptr)->end();
}

inline QValueListConstIterator<QVariant> QVariant::listBegin() const
{
    if ( d->typ != List )
	return QValueListConstIterator<QVariant>();
    return ((const QValueList<QVariant>*)d->value.ptr)->begin();
}

inline QValueListConstIterator<QVariant> QVariant::listEnd() const
{
    if ( d->typ != List )
	return QValueListConstIterator<QVariant>();
    return ((const QValueList<QVariant>*)d->value.ptr)->end();
}

inline QMapConstIterator<QString,QVariant> QVariant::mapBegin() const
{
    if ( d->typ != Map )
	return QMapConstIterator<QString,QVariant>();
    return ((const QMap<QString,QVariant>*)d->value.ptr)->begin();
}

inline QMapConstIterator<QString,QVariant> QVariant::mapEnd() const
{
    if ( d->typ != Map )
	return QMapConstIterator<QString,QVariant>();
    return ((const QMap<QString,QVariant>*)d->value.ptr)->end();
}

inline QMapConstIterator<QString,QVariant> QVariant::mapFind( const QString& key ) const
{
    if ( d->typ != Map )
	return QMapConstIterator<QString,QVariant>();
    return ((const QMap<QString,QVariant>*)d->value.ptr)->find( key );
}

  QDataStream& operator>> ( QDataStream& s, QVariant& p );
  QDataStream& operator<< ( QDataStream& s, const QVariant& p );
  QDataStream& operator>> ( QDataStream& s, QVariant::Type& p );
  QDataStream& operator<< ( QDataStream& s, const QVariant::Type p );




# 12 "todaybase.h" 2

# 1 "/opt/Qtopia/include/qwidget.h" 1
 








































# 1 "/opt/Qtopia/include/qwindowdefs.h" 1
 









































# 1 "/opt/Qtopia/include/qobjectdefs.h" 1
 












































 
 
 








# 70 "/opt/Qtopia/include/qobjectdefs.h"

 
 
 
 
 
 
 
 

 
 
# 93 "/opt/Qtopia/include/qobjectdefs.h"

 




 















 

class QObject;
class QMetaObject;
class QSignal;
class QConnection;
class QEvent;
struct QMetaData;
class QConnectionList;
class QConnectionListIt;
class QSignalDict;
class QSignalDictIt;
class QObjectList;
class QObjectListIt;
class QMemberDict;



# 43 "/opt/Qtopia/include/qwindowdefs.h" 2


# 1 "/opt/Qtopia/include/qnamespace.h" 1
 












































class QColor;
class QCursor;


class   Qt {
public:
    static const  QColor & color0;
    static const  QColor & color1;
    static const  QColor & black;
    static const  QColor & white;
    static const  QColor & darkGray;
    static const  QColor & gray;
    static const  QColor & lightGray;
    static const  QColor & red;
    static const  QColor & green;
    static const  QColor & blue;
    static const  QColor & cyan;
    static const  QColor & magenta;
    static const  QColor & yellow;
    static const  QColor & darkRed;
    static const  QColor & darkGreen;
    static const  QColor & darkBlue;
    static const  QColor & darkCyan;
    static const  QColor & darkMagenta;
    static const  QColor & darkYellow;

     
    enum ButtonState {				 
	NoButton	= 0x0000,
	LeftButton	= 0x0001,
	RightButton	= 0x0002,
	MidButton	= 0x0004,
	MouseButtonMask = 0x0007,
	ShiftButton	= 0x0008,
	ControlButton   = 0x0010,
	AltButton	= 0x0020,
	KeyButtonMask	= 0x0038,
	Keypad		= 0x4000
    };

     
    enum Orientation {
        Horizontal,
	Vertical
    };

     

     
    enum AlignmentFlags {
	AlignLeft	= 0x0001,		 
	AlignRight	= 0x0002,
	AlignHCenter	= 0x0004,
	AlignTop	= 0x0008,
	AlignBottom	= 0x0010,
	AlignVCenter	= 0x0020,
	AlignCenter	= AlignVCenter | AlignHCenter,

	SingleLine	= 0x0040,		 
	DontClip	= 0x0080,
	ExpandTabs	= 0x0100,
	ShowPrefix	= 0x0200,
	WordBreak	= 0x0400,
	DontPrint	= 0x1000		 
    };

     
    enum WidgetState {
	WState_Created		= 0x00000001,
	WState_Disabled		= 0x00000002,
	WState_Visible		= 0x00000004,
	WState_ForceHide	= 0x00000008,
	WState_OwnCursor	= 0x00000010,
	WState_MouseTracking	= 0x00000020,
	WState_CompressKeys	= 0x00000040,
	WState_BlockUpdates	= 0x00000080,
	WState_InPaintEvent	= 0x00000100,
	WState_Reparented	= 0x00000200,
	WState_ConfigPending	= 0x00000400,
	WState_Resized		= 0x00000800,
	WState_AutoMask		= 0x00001000,
	WState_Polished		= 0x00002000,
	WState_DND		= 0x00004000,
	WState_Modal		= 0x00008000,
	WState_Reserved1	= 0x00010000,
	WState_Reserved2	= 0x00020000,
	WState_Reserved3	= 0x00040000,
	WState_Maximized	= 0x00080000,
	WState_TranslateBackground = 0x00100000,
	WState_ForceDisabled	= 0x00200000,
	WState_Exposed		= 0x00400000
    };

     
    typedef uint WFlags;

     
    enum WidgetFlags {
	WType_TopLevel		= 0x00000001,	 
	WType_Modal		= 0x00000002,
	WType_Popup		= 0x00000004,
	WType_Desktop		= 0x00000008,
	WType_Mask		= 0x0000000f,

	WStyle_Customize	= 0x00000010,	 
	WStyle_NormalBorder	= 0x00000020,
	WStyle_DialogBorder	= 0x00000040,
	WStyle_NoBorder		= 0x00000000,
	WStyle_Title		= 0x00000080,
	WStyle_SysMenu		= 0x00000100,
	WStyle_Minimize		= 0x00000200,
	WStyle_Maximize		= 0x00000400,
	WStyle_MinMax		= WStyle_Minimize | WStyle_Maximize,
	WStyle_Tool		= 0x00000800,
	WStyle_StaysOnTop	= 0x00001000,
	WStyle_Dialog 		= 0x00002000,
	WStyle_ContextHelp	= 0x00004000,
	WStyle_NoBorderEx	= 0x00008000,  
	WStyle_Mask		= 0x0000fff0,

	WDestructiveClose	= 0x00010000,	 
	WPaintDesktop		= 0x00020000,
	WPaintUnclipped		= 0x00040000,
	WPaintClever		= 0x00080000,
	WResizeNoErase		= 0x00100000,
	WMouseNoMask		= 0x00200000,
	WNorthWestGravity	= 0x00400000,
	WRepaintNoErase		= 0x00800000,
	WX11BypassWM		= 0x01000000,
	WGroupLeader 		= 0x02000000
	 
    };

     
     

    enum ImageConversionFlags {
	ColorMode_Mask		= 0x00000003,
	AutoColor		= 0x00000000,
	ColorOnly		= 0x00000003,
	MonoOnly		= 0x00000002,
	 

	AlphaDither_Mask	= 0x0000000c,
	ThresholdAlphaDither	= 0x00000000,
	OrderedAlphaDither	= 0x00000004,
	DiffuseAlphaDither	= 0x00000008,
	NoAlpha			= 0x0000000c,  

	Dither_Mask		= 0x00000030,
	DiffuseDither		= 0x00000000,
	OrderedDither		= 0x00000010,
	ThresholdDither		= 0x00000020,
	 

	DitherMode_Mask		= 0x000000c0,
	AutoDither		= 0x00000000,
	PreferDither		= 0x00000040,
	AvoidDither		= 0x00000080
    };

    enum BGMode	{				 
	TransparentMode,
	OpaqueMode
    };

    enum PaintUnit {				 
	PixelUnit,
	LoMetricUnit,  
	HiMetricUnit,  
	LoEnglishUnit,  
	HiEnglishUnit,  
	TwipsUnit  
    };

    enum GUIStyle {
	MacStyle,  
	WindowsStyle,
	Win3Style,  
	PMStyle,  
	MotifStyle
    };

    enum Modifier {		 
	SHIFT         = 0x00200000,
	CTRL          = 0x00400000,
	ALT           = 0x00800000,
	MODIFIER_MASK = 0x00e00000,
	UNICODE_ACCEL = 0x10000000,

	ASCII_ACCEL = UNICODE_ACCEL  
    };

    enum Key {
	Key_Escape = 0x1000,		 
	Key_Tab = 0x1001,
	Key_Backtab = 0x1002, Key_BackTab = Key_Backtab,
	Key_Backspace = 0x1003, Key_BackSpace = Key_Backspace,
	Key_Return = 0x1004,
	Key_Enter = 0x1005,
	Key_Insert = 0x1006,
	Key_Delete = 0x1007,
	Key_Pause = 0x1008,
	Key_Print = 0x1009,
	Key_SysReq = 0x100a,
	Key_Home = 0x1010,		 
	Key_End = 0x1011,
	Key_Left = 0x1012,
	Key_Up = 0x1013,
	Key_Right = 0x1014,
	Key_Down = 0x1015,
	Key_Prior = 0x1016, Key_PageUp = Key_Prior,
	Key_Next = 0x1017, Key_PageDown = Key_Next,
	Key_Shift = 0x1020,		 
	Key_Control = 0x1021,
	Key_Meta = 0x1022,
	Key_Alt = 0x1023,
	Key_CapsLock = 0x1024,
	Key_NumLock = 0x1025,
	Key_ScrollLock = 0x1026,
	Key_F1 = 0x1030,		 
	Key_F2 = 0x1031,
	Key_F3 = 0x1032,
	Key_F4 = 0x1033,
	Key_F5 = 0x1034,
	Key_F6 = 0x1035,
	Key_F7 = 0x1036,
	Key_F8 = 0x1037,
	Key_F9 = 0x1038,
	Key_F10 = 0x1039,
	Key_F11 = 0x103a,
	Key_F12 = 0x103b,
	Key_F13 = 0x103c,
	Key_F14 = 0x103d,
	Key_F15 = 0x103e,
	Key_F16 = 0x103f,
	Key_F17 = 0x1040,
	Key_F18 = 0x1041,
	Key_F19 = 0x1042,
	Key_F20 = 0x1043,
	Key_F21 = 0x1044,
	Key_F22 = 0x1045,
	Key_F23 = 0x1046,
	Key_F24 = 0x1047,
	Key_F25 = 0x1048,		 
	Key_F26 = 0x1049,
	Key_F27 = 0x104a,
	Key_F28 = 0x104b,
	Key_F29 = 0x104c,
	Key_F30 = 0x104d,
	Key_F31 = 0x104e,
	Key_F32 = 0x104f,
	Key_F33 = 0x1050,
	Key_F34 = 0x1051,
	Key_F35 = 0x1052,
	Key_Super_L = 0x1053, 		 
	Key_Super_R = 0x1054,
	Key_Menu = 0x1055,
	Key_Hyper_L = 0x1056,
	Key_Hyper_R = 0x1057,
	Key_Help = 0x1058,
	Key_Space = 0x20,		 
	Key_Any = Key_Space,
	Key_Exclam = 0x21,
	Key_QuoteDbl = 0x22,
	Key_NumberSign = 0x23,
	Key_Dollar = 0x24,
	Key_Percent = 0x25,
	Key_Ampersand = 0x26,
	Key_Apostrophe = 0x27,
	Key_ParenLeft = 0x28,
	Key_ParenRight = 0x29,
	Key_Asterisk = 0x2a,
	Key_Plus = 0x2b,
	Key_Comma = 0x2c,
	Key_Minus = 0x2d,
	Key_Period = 0x2e,
	Key_Slash = 0x2f,
	Key_0 = 0x30,
	Key_1 = 0x31,
	Key_2 = 0x32,
	Key_3 = 0x33,
	Key_4 = 0x34,
	Key_5 = 0x35,
	Key_6 = 0x36,
	Key_7 = 0x37,
	Key_8 = 0x38,
	Key_9 = 0x39,
	Key_Colon = 0x3a,
	Key_Semicolon = 0x3b,
	Key_Less = 0x3c,
	Key_Equal = 0x3d,
	Key_Greater = 0x3e,
	Key_Question = 0x3f,
	Key_At = 0x40,
	Key_A = 0x41,
	Key_B = 0x42,
	Key_C = 0x43,
	Key_D = 0x44,
	Key_E = 0x45,
	Key_F = 0x46,
	Key_G = 0x47,
	Key_H = 0x48,
	Key_I = 0x49,
	Key_J = 0x4a,
	Key_K = 0x4b,
	Key_L = 0x4c,
	Key_M = 0x4d,
	Key_N = 0x4e,
	Key_O = 0x4f,
	Key_P = 0x50,
	Key_Q = 0x51,
	Key_R = 0x52,
	Key_S = 0x53,
	Key_T = 0x54,
	Key_U = 0x55,
	Key_V = 0x56,
	Key_W = 0x57,
	Key_X = 0x58,
	Key_Y = 0x59,
	Key_Z = 0x5a,
	Key_BracketLeft = 0x5b,
	Key_Backslash = 0x5c,
	Key_BracketRight = 0x5d,
	Key_AsciiCircum = 0x5e,
	Key_Underscore = 0x5f,
	Key_QuoteLeft = 0x60,
	Key_BraceLeft = 0x7b,
	Key_Bar = 0x7c,
	Key_BraceRight = 0x7d,
	Key_AsciiTilde = 0x7e,

	 

	Key_nobreakspace = 0x0a0,
	Key_exclamdown = 0x0a1,
	Key_cent = 0x0a2,
	Key_sterling = 0x0a3,
	Key_currency = 0x0a4,
	Key_yen = 0x0a5,
	Key_brokenbar = 0x0a6,
	Key_section = 0x0a7,
	Key_diaeresis = 0x0a8,
	Key_copyright = 0x0a9,
	Key_ordfeminine = 0x0aa,
	Key_guillemotleft = 0x0ab,	 
	Key_notsign = 0x0ac,
	Key_hyphen = 0x0ad,
	Key_registered = 0x0ae,
	Key_macron = 0x0af,
	Key_degree = 0x0b0,
	Key_plusminus = 0x0b1,
	Key_twosuperior = 0x0b2,
	Key_threesuperior = 0x0b3,
	Key_acute = 0x0b4,
	Key_mu = 0x0b5,
	Key_paragraph = 0x0b6,
	Key_periodcentered = 0x0b7,
	Key_cedilla = 0x0b8,
	Key_onesuperior = 0x0b9,
	Key_masculine = 0x0ba,
	Key_guillemotright = 0x0bb,	 
	Key_onequarter = 0x0bc,
	Key_onehalf = 0x0bd,
	Key_threequarters = 0x0be,
	Key_questiondown = 0x0bf,
	Key_Agrave = 0x0c0,
	Key_Aacute = 0x0c1,
	Key_Acircumflex = 0x0c2,
	Key_Atilde = 0x0c3,
	Key_Adiaeresis = 0x0c4,
	Key_Aring = 0x0c5,
	Key_AE = 0x0c6,
	Key_Ccedilla = 0x0c7,
	Key_Egrave = 0x0c8,
	Key_Eacute = 0x0c9,
	Key_Ecircumflex = 0x0ca,
	Key_Ediaeresis = 0x0cb,
	Key_Igrave = 0x0cc,
	Key_Iacute = 0x0cd,
	Key_Icircumflex = 0x0ce,
	Key_Idiaeresis = 0x0cf,
	Key_ETH = 0x0d0,
	Key_Ntilde = 0x0d1,
	Key_Ograve = 0x0d2,
	Key_Oacute = 0x0d3,
	Key_Ocircumflex = 0x0d4,
	Key_Otilde = 0x0d5,
	Key_Odiaeresis = 0x0d6,
	Key_multiply = 0x0d7,
	Key_Ooblique = 0x0d8,
	Key_Ugrave = 0x0d9,
	Key_Uacute = 0x0da,
	Key_Ucircumflex = 0x0db,
	Key_Udiaeresis = 0x0dc,
	Key_Yacute = 0x0dd,
	Key_THORN = 0x0de,
	Key_ssharp = 0x0df,
	Key_agrave = 0x0e0,
	Key_aacute = 0x0e1,
	Key_acircumflex = 0x0e2,
	Key_atilde = 0x0e3,
	Key_adiaeresis = 0x0e4,
	Key_aring = 0x0e5,
	Key_ae = 0x0e6,
	Key_ccedilla = 0x0e7,
	Key_egrave = 0x0e8,
	Key_eacute = 0x0e9,
	Key_ecircumflex = 0x0ea,
	Key_ediaeresis = 0x0eb,
	Key_igrave = 0x0ec,
	Key_iacute = 0x0ed,
	Key_icircumflex = 0x0ee,
	Key_idiaeresis = 0x0ef,
	Key_eth = 0x0f0,
	Key_ntilde = 0x0f1,
	Key_ograve = 0x0f2,
	Key_oacute = 0x0f3,
	Key_ocircumflex = 0x0f4,
	Key_otilde = 0x0f5,
	Key_odiaeresis = 0x0f6,
	Key_division = 0x0f7,
	Key_oslash = 0x0f8,
	Key_ugrave = 0x0f9,
	Key_uacute = 0x0fa,
	Key_ucircumflex = 0x0fb,
	Key_udiaeresis = 0x0fc,
	Key_yacute = 0x0fd,
	Key_thorn = 0x0fe,
	Key_ydiaeresis = 0x0ff,

	Key_unknown = 0xffff
    };

    enum ArrowType {
	UpArrow,
	DownArrow,
	LeftArrow,
	RightArrow
    };

     
    enum RasterOp {  
	CopyROP,
	OrROP,
	XorROP,
	NotAndROP,
	EraseROP=NotAndROP,
	NotCopyROP,
	NotOrROP,
	NotXorROP,
	AndROP,	NotEraseROP=AndROP,
	NotROP,
	ClearROP,
	SetROP,
	NopROP,
	AndNotROP,
	OrNotROP,
	NandROP,
	NorROP,	LastROP=NorROP
    };

     
    enum PenStyle {  
	NoPen,
	SolidLine,
	DashLine,
	DotLine,
	DashDotLine,
	DashDotDotLine,
	MPenStyle = 0x0f
    };

    enum PenCapStyle {  
	FlatCap = 0x00,
	SquareCap = 0x10,
	RoundCap = 0x20,
	MPenCapStyle = 0x30
    };

    enum PenJoinStyle {  
	MiterJoin = 0x00,
	BevelJoin = 0x40,
	RoundJoin = 0x80,
	MPenJoinStyle = 0xc0
    };

    enum BrushStyle {  
	NoBrush,
	SolidPattern,
	Dense1Pattern,
	Dense2Pattern,
	Dense3Pattern,
	Dense4Pattern,
	Dense5Pattern,
	Dense6Pattern,
	Dense7Pattern,
	HorPattern,
	VerPattern,
	CrossPattern,
	BDiagPattern,
	FDiagPattern,
	DiagCrossPattern,
	CustomPattern=24
    };

    enum WindowsVersion {
	WV_32s 		= 0x0001,
	WV_95 		= 0x0002,
	WV_98		= 0x0003,
	WV_DOS_based	= 0x000f,

	WV_NT 		= 0x0010,
	WV_2000 	= 0x0020,
	WV_NT_based	= 0x00f0
    };

    enum UIEffect {
	UI_General,
	UI_AnimateMenu,
	UI_FadeMenu,
	UI_AnimateCombo,
	UI_AnimateTooltip,
	UI_FadeTooltip
    };


     

    static const  QCursor & arrowCursor;	 
    static const  QCursor & upArrowCursor;	 
    static const  QCursor & crossCursor;	 
    static const  QCursor & waitCursor;	 
    static const  QCursor & ibeamCursor;	 
    static const  QCursor & sizeVerCursor;	 
    static const  QCursor & sizeHorCursor;	 
    static const  QCursor & sizeBDiagCursor;	 
    static const  QCursor & sizeFDiagCursor;	 
    static const  QCursor & sizeAllCursor;	 
    static const  QCursor & blankCursor;	 
    static const  QCursor & splitVCursor;	 
						 
    static const  QCursor & splitHCursor;	 
						 
    static const  QCursor & pointingHandCursor;	 
    static const  QCursor & forbiddenCursor;	 


    enum TextFormat {
	PlainText,
	RichText,
	AutoText
    };
};


class   QInternal {
public:
    enum PaintDeviceFlags {
	UndefinedDevice = 0x00,
	Widget = 0x01,
	Pixmap = 0x02,
	Printer = 0x03,
	Picture = 0x04,
	System = 0x05,
	DeviceTypeMask = 0x0f,
	ExternalDevice = 0x10
    };
};


# 45 "/opt/Qtopia/include/qwindowdefs.h" 2



# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/limits.h" 1 3
 


 





 
# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/syslimits.h" 1 3
 





# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/limits.h" 1 3
 


 

# 114 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/limits.h" 3



# 1 "/usr/include/limits.h" 1 3
 

















 









 





 

# 113 "/usr/include/limits.h" 3




  




# 140 "/usr/include/limits.h" 3



 
# 1 "/usr/include/bits/posix1_lim.h" 1 3
 

















 









 

 


 


 


 


 


 


 


 



 


 


 


 


 



 


 


 


 


 


 


 


 


 


 


 


 



 


 


 


 


 



 
# 1 "/usr/include/bits/local_lim.h" 1 3
 


















 














 
# 1 "/usr/include/linux/limits.h" 1 3



















# 36 "/usr/include/bits/local_lim.h" 2 3


 




 




 





 

 


 

 


 

 


 



 


 

# 126 "/usr/include/bits/posix1_lim.h" 2 3








 







# 144 "/usr/include/limits.h" 2 3




# 1 "/usr/include/bits/posix2_lim.h" 1 3
 

















 







 


 


 


 


 



 



 


 



 




 




























 



# 148 "/usr/include/limits.h" 2 3






# 117 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/limits.h" 2 3




# 7 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/syslimits.h" 2 3


# 11 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/limits.h" 2 3





 



 



 




 





 



 












 

 




 



 








 



 













 



# 107 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/limits.h" 3




 









# 48 "/opt/Qtopia/include/qwindowdefs.h" 2


 

class QPaintDevice;
class QPaintDeviceMetrics;
class QWidget;
class QWidgetMapper;
class QDialog;
class QColor;
class QColorGroup;
class QPalette;
class QCursor;
class QPoint;
class QSize;
class QRect;
class QPointArray;
class QPainter;
class QRegion;
class QFont;
class QFontMetrics;
class QFontInfo;
class QPen;
class QBrush;
class QWMatrix;
class QPixmap;
class QBitmap;
class QMovie;
class QImage;
class QImageIO;
class QPicture;
class QPrinter;
class QAccel;
class QTimer;
class QTime;
class QClipboard;


 

class QWidgetList;
class QWidgetListIt;


 


























typedef unsigned int  WId;
typedef unsigned int  HANDLE;


typedef struct _XDisplay Display;
typedef union  _XEvent XEvent;
typedef struct _XGC *GC;
typedef struct _XRegion *Region;

  Display *qt_xdisplay();
  int	 qt_xscreen();
  WId	 qt_xrootwin();
  GC	 qt_xget_readonly_gc( bool monochrome=FALSE );
  GC	 qt_xget_temp_gc( bool monochrome=FALSE );












class QApplication;





 


typedef Q_INT32 QCOORD;				 
const QCOORD QCOORD_MAX =  2147483647;
const QCOORD QCOORD_MIN = -QCOORD_MAX - 1;

typedef unsigned int QRgb;			 

  char *qAppName();			 


 

typedef void (*Q_CleanUpFunction)();
  void qAddPostRoutine( Q_CleanUpFunction );
  void qRemovePostRoutine( Q_CleanUpFunction );

 
  void *qt_find_obj_child( QObject *, const char *, const char * );





# 42 "/opt/Qtopia/include/qwidget.h" 2

# 1 "/opt/Qtopia/include/qobject.h" 1
 











































# 1 "/opt/Qtopia/include/qevent.h" 1
 









































# 1 "/opt/Qtopia/include/qregion.h" 1
 









































# 1 "/opt/Qtopia/include/qrect.h" 1
 








































# 1 "/opt/Qtopia/include/qsize.h" 1
 








































# 1 "/opt/Qtopia/include/qpoint.h" 1
 












































class   QPoint
{
public:
    QPoint();
    QPoint( int xpos, int ypos );

    bool   isNull()	const;

    int	   x()		const;
    int	   y()		const;
    void   setX( int x );
    void   setY( int y );

    int manhattanLength() const;

    QCOORD &rx();
    QCOORD &ry();

    QPoint &operator+=( const QPoint &p );
    QPoint &operator-=( const QPoint &p );
    QPoint &operator*=( int c );
    QPoint &operator*=( double c );
    QPoint &operator/=( int c );
    QPoint &operator/=( double c );

    friend inline bool	 operator==( const QPoint &, const QPoint & );
    friend inline bool	 operator!=( const QPoint &, const QPoint & );
    friend inline QPoint operator+( const QPoint &, const QPoint & );
    friend inline QPoint operator-( const QPoint &, const QPoint & );
    friend inline QPoint operator*( const QPoint &, int );
    friend inline QPoint operator*( int, const QPoint & );
    friend inline QPoint operator*( const QPoint &, double );
    friend inline QPoint operator*( double, const QPoint & );
    friend inline QPoint operator-( const QPoint & );
    friend inline QPoint operator/( const QPoint &, int );
    friend inline QPoint operator/( const QPoint &, double );

private:
    static void warningDivByZero();





    QCOORD xp;
    QCOORD yp;

};


 



  QDataStream &operator<<( QDataStream &, const QPoint & );
  QDataStream &operator>>( QDataStream &, QPoint & );


 



inline QPoint::QPoint()
{ xp=0; yp=0; }

inline QPoint::QPoint( int xpos, int ypos )
{ xp=(QCOORD)xpos; yp=(QCOORD)ypos; }

inline bool QPoint::isNull() const
{ return xp == 0 && yp == 0; }

inline int QPoint::x() const
{ return xp; }

inline int QPoint::y() const
{ return yp; }

inline void QPoint::setX( int x )
{ xp = (QCOORD)x; }

inline void QPoint::setY( int y )
{ yp = (QCOORD)y; }

inline QCOORD &QPoint::rx()
{ return xp; }

inline QCOORD &QPoint::ry()
{ return yp; }

inline QPoint &QPoint::operator+=( const QPoint &p )
{ xp+=p.xp; yp+=p.yp; return *this; }

inline QPoint &QPoint::operator-=( const QPoint &p )
{ xp-=p.xp; yp-=p.yp; return *this; }

inline QPoint &QPoint::operator*=( int c )
{ xp*=(QCOORD)c; yp*=(QCOORD)c; return *this; }

inline QPoint &QPoint::operator*=( double c )
{ xp=(QCOORD)(xp*c); yp=(QCOORD)(yp*c); return *this; }

inline bool operator==( const QPoint &p1, const QPoint &p2 )
{ return p1.xp == p2.xp && p1.yp == p2.yp; }

inline bool operator!=( const QPoint &p1, const QPoint &p2 )
{ return p1.xp != p2.xp || p1.yp != p2.yp; }

inline QPoint operator+( const QPoint &p1, const QPoint &p2 )
{ return QPoint(p1.xp+p2.xp, p1.yp+p2.yp); }

inline QPoint operator-( const QPoint &p1, const QPoint &p2 )
{ return QPoint(p1.xp-p2.xp, p1.yp-p2.yp); }

inline QPoint operator*( const QPoint &p, int c )
{ return QPoint(p.xp*c, p.yp*c); }

inline QPoint operator*( int c, const QPoint &p )
{ return QPoint(p.xp*c, p.yp*c); }

inline QPoint operator*( const QPoint &p, double c )
{ return QPoint((QCOORD)(p.xp*c), (QCOORD)(p.yp*c)); }

inline QPoint operator*( double c, const QPoint &p )
{ return QPoint((QCOORD)(p.xp*c), (QCOORD)(p.yp*c)); }

inline QPoint operator-( const QPoint &p )
{ return QPoint(-p.xp, -p.yp); }

inline QPoint &QPoint::operator/=( int c )
{

    if ( c == 0 )
	warningDivByZero();

    xp/=(QCOORD)c;
    yp/=(QCOORD)c;
    return *this;
}

inline QPoint &QPoint::operator/=( double c )
{

    if ( c == 0.0 )
	warningDivByZero();

    xp=(QCOORD)(xp/c);
    yp=(QCOORD)(yp/c);
    return *this;
}

inline QPoint operator/( const QPoint &p, int c )
{

    if ( c == 0 )
	QPoint::warningDivByZero();

    return QPoint(p.xp/c, p.yp/c);
}

inline QPoint operator/( const QPoint &p, double c )
{

    if ( c == 0.0 )
	QPoint::warningDivByZero();

    return QPoint((QCOORD)(p.xp/c), (QCOORD)(p.yp/c));
}



# 42 "/opt/Qtopia/include/qsize.h" 2




class   QSize
{
public:
    QSize();
    QSize( int w, int h );

    bool   isNull()	const;
    bool   isEmpty()	const;
    bool   isValid()	const;

    int	   width()	const;
    int	   height()	const;
    void   setWidth( int w );
    void   setHeight( int h );
    void   transpose();

    QSize expandedTo( const QSize & ) const;
    QSize boundedTo( const QSize & ) const;

    QCOORD &rwidth();
    QCOORD &rheight();

    QSize &operator+=( const QSize & );
    QSize &operator-=( const QSize & );
    QSize &operator*=( int c );
    QSize &operator*=( double c );
    QSize &operator/=( int c );
    QSize &operator/=( double c );

    friend inline bool	operator==( const QSize &, const QSize & );
    friend inline bool	operator!=( const QSize &, const QSize & );
    friend inline QSize operator+( const QSize &, const QSize & );
    friend inline QSize operator-( const QSize &, const QSize & );
    friend inline QSize operator*( const QSize &, int );
    friend inline QSize operator*( int, const QSize & );
    friend inline QSize operator*( const QSize &, double );
    friend inline QSize operator*( double, const QSize & );
    friend inline QSize operator/( const QSize &, int );
    friend inline QSize operator/( const QSize &, double );

private:
    static void warningDivByZero();

    QCOORD wd;
    QCOORD ht;
};


 



  QDataStream &operator<<( QDataStream &, const QSize & );
  QDataStream &operator>>( QDataStream &, QSize & );


 



inline QSize::QSize()
{ wd = ht = -1; }

inline QSize::QSize( int w, int h )
{ wd=(QCOORD)w; ht=(QCOORD)h; }

inline bool QSize::isNull() const
{ return wd==0 && ht==0; }

inline bool QSize::isEmpty() const
{ return wd<1 || ht<1; }

inline bool QSize::isValid() const
{ return wd>=0 && ht>=0; }

inline int QSize::width() const
{ return wd; }

inline int QSize::height() const
{ return ht; }

inline void QSize::setWidth( int w )
{ wd=(QCOORD)w; }

inline void QSize::setHeight( int h )
{ ht=(QCOORD)h; }

inline QCOORD &QSize::rwidth()
{ return wd; }

inline QCOORD &QSize::rheight()
{ return ht; }

inline QSize &QSize::operator+=( const QSize &s )
{ wd+=s.wd; ht+=s.ht; return *this; }

inline QSize &QSize::operator-=( const QSize &s )
{ wd-=s.wd; ht-=s.ht; return *this; }

inline QSize &QSize::operator*=( int c )
{ wd*=(QCOORD)c; ht*=(QCOORD)c; return *this; }

inline QSize &QSize::operator*=( double c )
{ wd=(QCOORD)(wd*c); ht=(QCOORD)(ht*c); return *this; }

inline bool operator==( const QSize &s1, const QSize &s2 )
{ return s1.wd == s2.wd && s1.ht == s2.ht; }

inline bool operator!=( const QSize &s1, const QSize &s2 )
{ return s1.wd != s2.wd || s1.ht != s2.ht; }

inline QSize operator+( const QSize & s1, const QSize & s2 )
{ return QSize(s1.wd+s2.wd, s1.ht+s2.ht); }

inline QSize operator-( const QSize &s1, const QSize &s2 )
{ return QSize(s1.wd-s2.wd, s1.ht-s2.ht); }

inline QSize operator*( const QSize &s, int c )
{ return QSize(s.wd*c, s.ht*c); }

inline QSize operator*( int c, const QSize &s )
{  return QSize(s.wd*c, s.ht*c); }

inline QSize operator*( const QSize &s, double c )
{ return QSize((QCOORD)(s.wd*c), (QCOORD)(s.ht*c)); }

inline QSize operator*( double c, const QSize &s )
{ return QSize((QCOORD)(s.wd*c), (QCOORD)(s.ht*c)); }

inline QSize &QSize::operator/=( int c )
{

    if ( c == 0 )
	warningDivByZero();

    wd/=(QCOORD)c; ht/=(QCOORD)c;
    return *this;
}

inline QSize &QSize::operator/=( double c )
{

    if ( c == 0.0 )
	warningDivByZero();

    wd=(QCOORD)(wd/c); ht=(QCOORD)(ht/c);
    return *this;
}

inline QSize operator/( const QSize &s, int c )
{

    if ( c == 0 )
	QSize::warningDivByZero();

    return QSize(s.wd/c, s.ht/c);
}

inline QSize operator/( const QSize &s, double c )
{

    if ( c == 0.0 )
	QSize::warningDivByZero();

    return QSize((QCOORD)(s.wd/c), (QCOORD)(s.ht/c));
}

inline QSize QSize::expandedTo( const QSize & otherSize ) const
{
    return QSize( (( wd ) > ( otherSize.wd ) ? ( wd ) : ( otherSize.wd )) , (( ht ) > ( otherSize.ht ) ? ( ht ) : ( otherSize.ht ))  );
}

inline QSize QSize::boundedTo( const QSize & otherSize ) const
{
    return QSize( (( wd ) < ( otherSize.wd ) ? ( wd ) : ( otherSize.wd )) , (( ht ) < ( otherSize.ht ) ? ( ht ) : ( otherSize.ht ))  );
}



# 42 "/opt/Qtopia/include/qrect.h" 2








class   QRect					 
{
public:
    QRect()	{ x1 = y1 = 0; x2 = y2 = -1; }
    QRect( const QPoint &topleft, const QPoint &bottomright );
    QRect( const QPoint &topleft, const QSize &size );
    QRect( int left, int top, int width, int height );

    bool   isNull()	const;
    bool   isEmpty()	const;
    bool   isValid()	const;
    QRect  normalize()	const;

    int	   left()	const;
    int	   top()	const;
    int	   right()	const;
    int	   bottom()	const;

    QCOORD &rLeft();
    QCOORD &rTop();
    QCOORD &rRight();
    QCOORD &rBottom();
	
    int	   x()		const;
    int	   y()		const;
    void   setLeft( int pos );
    void   setTop( int pos );
    void   setRight( int pos );
    void   setBottom( int pos );
    void   setX( int x );
    void   setY( int y );

    QPoint topLeft()	 const;
    QPoint bottomRight() const;
    QPoint topRight()	 const;
    QPoint bottomLeft()	 const;
    QPoint center()	 const;

    void   rect( int *x, int *y, int *w, int *h ) const;
    void   coords( int *x1, int *y1, int *x2, int *y2 ) const;

    void   moveTopLeft( const QPoint &p );
    void   moveBottomRight( const QPoint &p );
    void   moveTopRight( const QPoint &p );
    void   moveBottomLeft( const QPoint &p );
    void   moveCenter( const QPoint &p );
    void   moveBy( int dx, int dy );

    void   setRect( int x, int y, int w, int h );
    void   setCoords( int x1, int y1, int x2, int y2 );

    QSize  size()	const;
    int	   width()	const;
    int	   height()	const;
    void   setWidth( int w );
    void   setHeight( int h );
    void   setSize( const QSize &s );

    QRect  operator|(const QRect &r) const;
    QRect  operator&(const QRect &r) const;
    QRect&  operator|=(const QRect &r);
    QRect&  operator&=(const QRect &r);

    bool   contains( const QPoint &p, bool proper=FALSE ) const;
    bool   contains( int x, int y, bool proper=FALSE ) const;
    bool   contains( const QRect &r, bool proper=FALSE ) const;
    QRect  unite( const QRect &r ) const;
    QRect  intersect( const QRect &r ) const;
    bool   intersects( const QRect &r ) const;

    friend   bool operator==( const QRect &, const QRect & );
    friend   bool operator!=( const QRect &, const QRect & );

private:






    QCOORD x1;
    QCOORD y1;
    QCOORD x2;
    QCOORD y2;

};

  bool operator==( const QRect &, const QRect & );
  bool operator!=( const QRect &, const QRect & );


 



  QDataStream &operator<<( QDataStream &, const QRect & );
  QDataStream &operator>>( QDataStream &, QRect & );


 



inline QRect::QRect( int left, int top, int width, int height )
{
    x1 = (QCOORD)left;
    y1 = (QCOORD)top;
    x2 = (QCOORD)(left+width-1);
    y2 = (QCOORD)(top+height-1);
}

inline bool QRect::isNull() const
{ return x2 == x1-1 && y2 == y1-1; }

inline bool QRect::isEmpty() const
{ return x1 > x2 || y1 > y2; }

inline bool QRect::isValid() const
{ return x1 <= x2 && y1 <= y2; }

inline int QRect::left() const
{ return x1; }

inline int QRect::top() const
{ return y1; }

inline int QRect::right() const
{ return x2; }

inline int QRect::bottom() const
{ return y2; }

inline QCOORD &QRect::rLeft()
{ return x1; }

inline QCOORD & QRect::rTop()
{ return y1; }

inline QCOORD & QRect::rRight()
{ return x2; }

inline QCOORD & QRect::rBottom()
{ return y2; }

inline int QRect::x() const
{ return x1; }

inline int QRect::y() const
{ return y1; }

inline void QRect::setLeft( int pos )
{ x1 = (QCOORD)pos; }

inline void QRect::setTop( int pos )
{ y1 = (QCOORD)pos; }

inline void QRect::setRight( int pos )
{ x2 = (QCOORD)pos; }

inline void QRect::setBottom( int pos )
{ y2 = (QCOORD)pos; }

inline void QRect::setX( int x )
{ x1 = (QCOORD)x; }

inline void QRect::setY( int y )
{ y1 = (QCOORD)y; }

inline QPoint QRect::topLeft() const
{ return QPoint(x1, y1); }

inline QPoint QRect::bottomRight() const
{ return QPoint(x2, y2); }

inline QPoint QRect::topRight() const
{ return QPoint(x2, y1); }

inline QPoint QRect::bottomLeft() const
{ return QPoint(x1, y2); }

inline QPoint QRect::center() const
{ return QPoint((x1+x2)/2, (y1+y2)/2); }

inline int QRect::width() const
{ return  x2 - x1 + 1; }

inline int QRect::height() const
{ return  y2 - y1 + 1; }

inline QSize QRect::size() const
{ return QSize(x2-x1+1, y2-y1+1); }

inline bool QRect::contains( int x, int y, bool proper ) const
{
    if ( proper )
        return x > x1 && x < x2 &&
               y > y1 && y < y2;
    else
        return x >= x1 && x <= x2 &&
               y >= y1 && y <= y2;
}


# 43 "/opt/Qtopia/include/qregion.h" 2





class   QRegion
{
public:
    enum RegionType { Rectangle, Ellipse };

    QRegion();
    QRegion( int x, int y, int w, int h, RegionType = Rectangle );
    QRegion( const QRect &, RegionType = Rectangle );
    QRegion( const QPointArray &, bool winding=FALSE );
    QRegion( const QRegion & );
    QRegion( const QBitmap & );
   ~QRegion();
    QRegion &operator=( const QRegion & );

    bool    isNull()   const;
    bool    isEmpty()  const;

    bool    contains( const QPoint &p ) const;
    bool    contains( const QRect &r )	const;

    void    translate( int dx, int dy );

    QRegion unite( const QRegion & )	const;
    QRegion intersect( const QRegion &) const;
    QRegion subtract( const QRegion & ) const;
    QRegion eor( const QRegion & )	const;

    QRect   boundingRect() const;
    QArray<QRect> rects() const;
    void setRects( const QRect *, int );

    QRegion operator|( const QRegion & ) const;
    QRegion operator+( const QRegion & ) const;
    QRegion operator&( const QRegion & ) const;
    QRegion operator-( const QRegion & ) const;
    QRegion operator^( const QRegion & ) const;
    QRegion& operator|=( const QRegion & );
    QRegion& operator+=( const QRegion & );
    QRegion& operator&=( const QRegion & );
    QRegion& operator-=( const QRegion & );
    QRegion& operator^=( const QRegion & );

    bool    operator==( const QRegion & )  const;
    bool    operator!=( const QRegion &r ) const
			{ return !(operator==(r)); }




    Region  handle() const { return data->rgn; }








    friend   QDataStream &operator<<( QDataStream &, const QRegion & );
    friend   QDataStream &operator>>( QDataStream &, QRegion & );

private:
    QRegion( bool );
    QRegion copy() const;
    void    detach();



    void    exec( const QByteArray &, int ver = 0 );
    struct QRegionData : public QShared {



	Region rgn;
	QRect br;





	bool   is_null;
    } *data;
};














 




  QDataStream &operator<<( QDataStream &, const QRegion & );
  QDataStream &operator>>( QDataStream &, QRegion & );




# 43 "/opt/Qtopia/include/qevent.h" 2


# 1 "/opt/Qtopia/include/qmime.h" 1
 













































class   QMimeSource {
public:
    virtual ~QMimeSource();
    virtual const char* format( int n = 0 ) const = 0;
    virtual bool provides( const char* ) const;
    virtual QByteArray encodedData( const char* ) const = 0;
};

class QMimeSourceFactoryData;
class QStringList;

class   QMimeSourceFactory {
public:
    QMimeSourceFactory();
    virtual ~QMimeSourceFactory();

    static QMimeSourceFactory* defaultFactory();
    static void setDefaultFactory( QMimeSourceFactory* );

    virtual const QMimeSource* data(const QString& abs_name) const;
    virtual QString makeAbsolute(const QString& abs_or_rel_name, const QString& context) const;
    const QMimeSource* data(const QString& abs_or_rel_name, const QString& context) const;

    virtual void setText( const QString& abs_name, const QString& text );
    virtual void setImage( const QString& abs_name, const QImage& im );
    virtual void setPixmap( const QString& abs_name, const QPixmap& pm );
    virtual void setData( const QString& abs_name, QMimeSource* data );
    virtual void setFilePath( const QStringList& );
    virtual QStringList filePath() const;
    void addFilePath( const QString& );
    virtual void setExtensionType( const QString& ext, const char* mimetype );

private:
    QMimeSourceFactoryData* d;
};

# 119 "/opt/Qtopia/include/qmime.h"





# 45 "/opt/Qtopia/include/qevent.h" 2




class   QEvent: public Qt		 
{
public:
    enum Type {

	 
	 
	 
	 

	None = 0,				 


	Timer = 1,				 
	MouseButtonPress = 2,			 
	MouseButtonRelease = 3,			 
	MouseButtonDblClick= 4,			 
	MouseMove = 5,				 
	KeyPress = 6,				 
	KeyRelease = 7,				 
	FocusIn = 8,				 
	FocusOut = 9,				 
	Enter = 10,				 
	Leave = 11,				 
	Paint = 12,				 
	Move = 13,				 
	Resize = 14,				 
	Create = 15,				 
	Destroy = 16,				 
	Show = 17,				 
	Hide = 18,				 
	Close = 19,				 
	Quit = 20,				 
	Reparent = 21,				 
	ShowMinimized = 22,		       	 
	ShowNormal = 23,	       		 
	WindowActivate = 24,	       		 
	WindowDeactivate = 25,	       		 
	ShowToParent = 26,	       		 
	HideToParent = 27,	       		 
	ShowMaximized = 28,		       	 
	Accel = 30,				 
	Wheel = 31,				 
	AccelAvailable = 32,			 
	CaptionChange = 33,			 
	IconChange = 34,			 
	ParentFontChange = 35,			 
	ApplicationFontChange = 36,		 
	ParentPaletteChange = 37,		 
	ApplicationPaletteChange = 38,		 
	Clipboard = 40,				 
	Speech = 42,				 
	SockAct = 50,				 
	AccelOverride = 51,			 
	DragEnter = 60,				 
	DragMove = 61,				 
	DragLeave = 62,				 
	Drop = 63,				 
	DragResponse = 64,			 
	ChildInserted = 70,			 
	ChildRemoved = 71,			 
	LayoutHint = 72,			 
	ShowWindowRequest = 73,			 
	ActivateControl = 80,			 
	DeactivateControl = 81,			 
	User = 1000				 
    };

    QEvent( Type type ) : t(type), posted(FALSE) {}
    virtual ~QEvent();
    Type  type() const	{ return t; }
protected:
    Type  t;
private:
    bool  posted;




    friend class QApplication;
    friend class QBaseApplication;
};


class   QTimerEvent : public QEvent
{
public:
    QTimerEvent( int timerId )
	: QEvent(Timer), id(timerId) {}
    int	  timerId()	const	{ return id; }
protected:
    int	  id;
};


class   QMouseEvent : public QEvent
{
public:
    QMouseEvent( Type type, const QPoint &pos, int button, int state );

    QMouseEvent( Type type, const QPoint &pos, const QPoint&globalPos,
		 int button, int state )
	: QEvent(type), p(pos), g(globalPos), b(button),s((ushort)state) {};

    const QPoint &pos() const	{ return p; }
    const QPoint &globalPos() const { return g; }
    int	   x()		const	{ return p.x(); }
    int	   y()		const	{ return p.y(); }
    int	   globalX()	const	{ return g.x(); }
    int	   globalY()	const	{ return g.y(); }
    ButtonState button() const	{ return (ButtonState) b; }
    ButtonState state()	const	{ return (ButtonState) s; }
    ButtonState stateAfter() const;
protected:
    QPoint p;
    QPoint g;
    int	   b;  
    ushort s;  
};



class   QWheelEvent : public QEvent
{
public:
    QWheelEvent( const QPoint &pos, int delta, int state );
    QWheelEvent( const QPoint &pos, const QPoint& globalPos, int delta, int state )
	: QEvent(Wheel), p(pos), g(globalPos), d(delta), s((ushort)state),
	  accpt(TRUE) {}
    int	   delta()	const	{ return d; }
    const QPoint &pos() const	{ return p; }
    const QPoint &globalPos() const	{ return g; }
    int	   x()		const	{ return p.x(); }
    int	   y()		const	{ return p.y(); }
    int	   globalX()	const	{ return g.x(); }
    int	   globalY()	const	{ return g.y(); }
    ButtonState state()	const	{ return ButtonState(s); }
    bool   isAccepted() const	{ return accpt; }
    void   accept()		{ accpt = TRUE; }
    void   ignore()		{ accpt = FALSE; }
protected:
    QPoint p;
    QPoint g;
    int d;
    ushort s;
    bool   accpt;
};


class   QKeyEvent : public QEvent
{
public:
    QKeyEvent( Type type, int key, int ascii, int state,
		const QString& text=QString::null, bool autorep=FALSE, ushort count=1 )
	: QEvent(type), txt(text), k((ushort)key), s((ushort)state),
	    a((uchar)ascii), accpt(TRUE), autor(autorep), c(count) {}
    int	   key()	const	{ return k; }
    int	   ascii()	const	{ return a; }
    ButtonState state()	const	{ return ButtonState(s); }
    ButtonState stateAfter() const;
    bool   isAccepted() const	{ return accpt; }
    QString text()      const   { return txt; }
    bool   isAutoRepeat() const	{ return autor; }
    int   count() const	{ return int(c); }
    void   accept()		{ accpt = TRUE; }
    void   ignore()		{ accpt = FALSE; }

protected:
    QString txt;
    ushort k, s;
    uchar  a;
    uint   accpt:1;
    uint   autor:1;
    ushort c;
};


class   QFocusEvent : public QEvent
{
public:

    QFocusEvent( Type type )
	: QEvent(type) {}

    bool   gotFocus()	const { return type() == FocusIn; }
    bool   lostFocus()	const { return type() == FocusOut; }

    enum Reason { Mouse, Tab, ActiveWindow, Popup, Shortcut, Other };
    static Reason reason();
    static void setReason( Reason reason );
    static void resetReason();

private:
    static Reason m_reason;
    static Reason prev_reason;
};


class   QPaintEvent : public QEvent
{
public:
    QPaintEvent( const QRegion& paintRegion, bool erased = TRUE)
	: QEvent(Paint),
	  rec(paintRegion.boundingRect()),
	  reg(paintRegion),
	  erase(erased){}
    QPaintEvent( const QRect &paintRect, bool erased = TRUE )
	: QEvent(Paint),
	  rec(paintRect),
	  reg(paintRect),
	  erase(erased){}
    const QRect &rect() const	  { return rec; }
    const QRegion &region() const { return reg; }
    bool erased() const { return erase; }
protected:
    friend class QApplication;
    friend class QBaseApplication;
    QRect rec;
    QRegion reg;
    bool erase;
};


class   QMoveEvent : public QEvent
{
public:
    QMoveEvent( const QPoint &pos, const QPoint &oldPos )
	: QEvent(Move), p(pos), oldp(oldPos) {}
    const QPoint &pos()	  const { return p; }
    const QPoint &oldPos()const { return oldp;}
protected:
    QPoint p, oldp;
    friend class QApplication;
    friend class QBaseApplication;
};


class   QResizeEvent : public QEvent
{
public:
    QResizeEvent( const QSize &size, const QSize &oldSize )
	: QEvent(Resize), s(size), olds(oldSize) {}
    const QSize &size()	  const { return s; }
    const QSize &oldSize()const { return olds;}
protected:
    QSize s, olds;
    friend class QApplication;
    friend class QBaseApplication;
};


class   QCloseEvent : public QEvent
{
public:
    QCloseEvent()
	: QEvent(Close), accpt(FALSE) {}
    bool   isAccepted() const	{ return accpt; }
    void   accept()		{ accpt = TRUE; }
    void   ignore()		{ accpt = FALSE; }
protected:
    bool   accpt;
};


class   QShowEvent : public QEvent
{
public:
    QShowEvent(bool spontaneous)
	: QEvent(Show), spont(spontaneous) {}
    bool spontaneous() const { return spont; }
protected:
    bool spont;
};


class   QHideEvent : public QEvent
{
public:
    QHideEvent(bool spontaneous)
	: QEvent(Hide), spont(spontaneous) {}
    bool spontaneous() const { return spont; }
protected:
    bool spont;
};

# 423 "/opt/Qtopia/include/qevent.h"


class   QChildEvent : public QEvent
{
public:
    QChildEvent( Type type, QObject *child )
	: QEvent(type), c(child) {}
    QObject *child() const	{ return c; }
    bool inserted() const { return t == ChildInserted; }
    bool removed() const { return t == ChildRemoved; }
protected:
    QObject *c;
};


class   QCustomEvent : public QEvent
{
public:
    QCustomEvent( int type );
    QCustomEvent( Type type, void *data )
	: QEvent(type), d(data) {};
    void       *data()	const	{ return d; }
    void	setData( void* data )	{ d = data; }
private:
    void       *d;
};


# 45 "/opt/Qtopia/include/qobject.h" 2








class QMetaObject;
class QVariant;



class   QObject: public Qt
{
     

public:
    QObject( QObject *parent=0, const char *name=0 );
    virtual ~QObject();

    static QString tr( const char * );
    static QString tr( const char *, const char * );

    virtual bool event( QEvent * );
    virtual bool eventFilter( QObject *, QEvent * );

    virtual QMetaObject *metaObject() const { return staticMetaObject(); }
    virtual const char	*className()  const;

    bool	 isA( const char * )	 const;
    bool	 inherits( const char * ) const;

    const char  *name() const;
    const char  *name( const char * defaultName ) const;

    virtual void setName( const char *name );
    bool	 isWidgetType()	  const { return isWidget; }
    bool	 highPriority()	  const { return FALSE; }

    bool	 signalsBlocked()  const { return blockSig; }
    void	 blockSignals( bool b );

    int		 startTimer( int interval );
    void	 killTimer( int id );
    void	 killTimers();

    QObject           *child( const char *name, const char *type = 0 );
    const QObjectList *children() const { return childObjects; }

    static const QObjectList *objectTrees();

     
    QObjectList	      *queryList( const char *inheritsClass = 0,
				  const char *objName = 0,
				  bool regexpMatch = TRUE,
				  bool recursiveSearch = TRUE );

    virtual void insertChild( QObject * );
    virtual void removeChild( QObject * );

    void	 installEventFilter( const QObject * );
    void	 removeEventFilter( const QObject * );

    static bool  connect( const QObject *sender, const char *signal,
			  const QObject *receiver, const char *member );
    bool	 connect( const QObject *sender, const char *signal,
			  const char *member ) const;
    static bool  disconnect( const QObject *sender, const char *signal,
			     const QObject *receiver, const char *member );
    bool	 disconnect( const char *signal=0,
			     const QObject *receiver=0, const char *member=0 );
    bool	 disconnect( const QObject *receiver, const char *member=0 );

    void	 dumpObjectTree();
    void	 dumpObjectInfo();






protected :
    void	 destroyed();

public:
    QObject	*parent() const { return parentObj; }

private  :
    void	 cleanupEventFilter();

protected:
    bool	 activate_filters( QEvent * );
    QConnectionList *receivers( const char *signal ) const;
    void	 activate_signal( const char *signal );
    void	 activate_signal( const char *signal, short );
    void	 activate_signal( const char *signal, int );
    void	 activate_signal( const char *signal, long );
    void	 activate_signal( const char *signal, const char * );
    void	 activate_signal_bool( const char *signal, bool );
    void	 activate_signal_string( const char *signal, QString );
    void	 activate_signal_strref( const char *signal, const QString & );

    const QObject *sender();


    virtual void initMetaObject();
    static QMetaObject* staticMetaObject();

    virtual void timerEvent( QTimerEvent * );
    virtual void childEvent( QChildEvent * );

    virtual void connectNotify( const char *signal );
    virtual void disconnectNotify( const char *signal );
    virtual bool checkConnectArgs( const char *signal, const QObject *receiver,
				   const char *member );
    static QCString normalizeSignalSlot( const char *signalSlot );

    static  void badSuperclassWarning( const char *className,
				       const char *superclassName );

private:
    uint	isSignal   : 1;
    uint	isWidget   : 1;
    uint	pendTimer  : 1;
    uint	pendEvent  : 1;
    uint	blockSig   : 1;
    uint	wasDeleted : 1;
    uint	isTree : 1;

    QMetaObject *queryMetaObject() const;
    static QMetaObject *metaObj;
    const char	*objname;
    QObject	*parentObj;
    QObjectList *childObjects;
    QSignalDict *connections;
    QObjectList *senderObjects;
    QObjectList *eventFilters;
     

    QObject	*sigSender;

    friend class QApplication;
    friend class QBaseApplication;
    friend class QWidget;
    friend class QSignal;
    friend class QSenderObject;

private:	 

    QObject( const QObject & );
    QObject &operator=( const QObject & );


public:
     

    QStringList  superClasses( bool includeThis = FALSE ) const;  

};



inline bool QObject::connect( const QObject *sender, const char *signal,
			      const char *member ) const
{
    return connect( sender, signal, this, member );
}

inline bool QObject::disconnect( const char *signal,
				 const QObject *receiver, const char *member )
{
    return disconnect( this, signal, receiver, member );
}

inline bool QObject::disconnect( const QObject *receiver, const char *member )
{
    return disconnect( this, 0, receiver, member );
}

inline const QObject *QObject::sender()
{
    return sigSender;
}


class   QSenderObject : public QObject		 
{
public:
    void setSender( QObject *s ) { sigSender=s; }
};












# 43 "/opt/Qtopia/include/qwidget.h" 2

# 1 "/opt/Qtopia/include/qpaintdevice.h" 1
 

















































class QIODevice;
class QString;



struct QPaintDeviceX11Data;


union QPDevCmdParam {
    int			 ival;
    int			*ivec;
    QString	        *str;
    const QPoint	*point;
    const QRect		*rect;
    const QPointArray	*ptarr;
    const QPixmap	*pixmap;
    const QImage	*image;
    const QColor	*color;
    const QFont		*font;
    const QPen		*pen;
    const QBrush	*brush;
    const QRegion	*rgn;
    const QWMatrix	*matrix;
    QIODevice		*device;
};



class   QPaintDevice				 
{
public:
    virtual ~QPaintDevice();

    int		devType() const;
    bool	isExtDev() const;
    bool	paintingActive() const;

     
     



    HANDLE	handle() const;







    Display 	   *x11Display() const;
    int		    x11Screen() const;
    int		    x11Depth() const;
    int		    x11Cells() const;
    HANDLE	    x11Colormap() const;
    bool	    x11DefaultColormap() const;
    void	   *x11Visual() const;
    bool	    x11DefaultVisual() const;

    static Display *x11AppDisplay();
    static int	    x11AppScreen();
    static int	    x11AppDepth();
    static int	    x11AppCells();
    static int	    x11AppDpiX();
    static int	    x11AppDpiY();
    static HANDLE   x11AppColormap();
    static bool     x11AppDefaultColormap();
    static void    *x11AppVisual();
    static bool	    x11AppDefaultVisual();
    static void	    x11SetAppDpiX(int);
    static void	    x11SetAppDpiY(int);









    enum PDevCmd {
	PdcNOP = 0,  
	PdcDrawPoint = 1,  
	PdcDrawFirst = PdcDrawPoint,
	PdcMoveTo = 2,  
	PdcLineTo = 3,  
	PdcDrawLine = 4,  
	PdcDrawRect = 5,  
	PdcDrawRoundRect = 6,  
	PdcDrawEllipse = 7,  
	PdcDrawArc = 8,  
	PdcDrawPie = 9,  
	PdcDrawChord = 10,  
	PdcDrawLineSegments = 11,  
	PdcDrawPolyline = 12,  
	PdcDrawPolygon = 13,  
	PdcDrawQuadBezier = 14,  
	PdcDrawText = 15,  
	PdcDrawTextFormatted = 16,  
	PdcDrawPixmap = 17,  
	PdcDrawImage = 18,  
	PdcDrawText2 = 19,  
	PdcDrawText2Formatted = 20,  
	PdcDrawLast = PdcDrawText2Formatted,

	 

	PdcBegin = 30,  
	PdcEnd = 31,  
	PdcSave = 32,  
	PdcRestore = 33,  
	PdcSetdev = 34,  
	PdcSetBkColor = 40,  
	PdcSetBkMode = 41,  
	PdcSetROP = 42,  
	PdcSetBrushOrigin = 43,  
	PdcSetFont = 45,  
	PdcSetPen = 46,  
	PdcSetBrush = 47,  
	PdcSetTabStops = 48,  
	PdcSetTabArray = 49,  
	PdcSetUnit = 50,  
	PdcSetVXform = 51,  
	PdcSetWindow = 52,  
	PdcSetViewport = 53,  
	PdcSetWXform = 54,  
	PdcSetWMatrix = 55,  
	PdcSaveWMatrix = 56,
	PdcRestoreWMatrix = 57,
	PdcSetClip = 60,  
	PdcSetClipRegion = 61,  

	PdcReservedStart = 0,  
	PdcReservedStop = 199  
    };

protected:
    QPaintDevice( uint devflags );




    HANDLE	hd;				 
    void		 copyX11Data( const QPaintDevice * );
    virtual void	 setX11Data( const QPaintDeviceX11Data* );
    QPaintDeviceX11Data* getX11Data( bool def=FALSE ) const;







    virtual bool cmd( int, QPainter *, QPDevCmdParam * );
    virtual int	 metric( int ) const;
    virtual int	 fontMet( QFont *, int, const char * = 0, int = 0 ) const;
    virtual int	 fontInf( QFont *, int ) const;

    ushort	devFlags;			 
    ushort	painters;			 

    friend class QPainter;
    friend class QPaintDeviceMetrics;
    friend   void bitBlt( QPaintDevice *, int, int,
				 const QPaintDevice *,
				 int, int, int, int, Qt::RasterOp, bool );

    friend void qt_init_internal( int *, char **, Display * );


private:

    static Display *x_appdisplay;
    static int	    x_appscreen;
    static int	    x_appdepth;
    static int	    x_appcells;
    static HANDLE   x_appcolormap;
    static bool	    x_appdefcolormap;
    static void	   *x_appvisual;
    static bool     x_appdefvisual;

    QPaintDeviceX11Data* x11Data;


private:	 

    QPaintDevice( const QPaintDevice & );
    QPaintDevice &operator=( const QPaintDevice & );

};


 
void bitBlt( QPaintDevice *dst, int dx, int dy,
	     const QPaintDevice *src, int sx=0, int sy=0, int sw=-1, int sh=-1,
	     Qt::RasterOp = Qt::CopyROP, bool ignoreMask=FALSE );

 
void bitBlt( QPaintDevice *dst, int dx, int dy,
	     const QImage *src, int sx=0, int sy=0, int sw=-1, int sh=-1,
	     int conversion_flags=0 );




struct   QPaintDeviceX11Data {
    Display*	x_display;
    int		x_screen;
    int		x_depth;
    int		x_cells;
    HANDLE	x_colormap;
    bool	x_defcolormap;
    void*	x_visual;
    bool	x_defvisual;
};



 



inline int QPaintDevice::devType() const
{ return devFlags & QInternal::DeviceTypeMask; }

inline bool QPaintDevice::isExtDev() const
{ return (devFlags & QInternal::ExternalDevice) != 0; }

inline bool QPaintDevice::paintingActive() const
{ return painters != 0; }




inline HANDLE QPaintDevice::handle() const { return hd; }



inline Display *QPaintDevice::x11Display() const
{ return x11Data ? x11Data->x_display : x_appdisplay; }

inline int QPaintDevice::x11Screen() const
{ return x11Data ? x11Data->x_screen : x_appscreen; }

inline int QPaintDevice::x11Depth() const
{ return x11Data ? x11Data->x_depth : x_appdepth; }

inline int QPaintDevice::x11Cells() const
{ return x11Data ? x11Data->x_cells : x_appcells; }

inline HANDLE QPaintDevice::x11Colormap() const
{ return x11Data ? x11Data->x_colormap : x_appcolormap; }

inline bool QPaintDevice::x11DefaultColormap() const
{ return x11Data ? x11Data->x_defcolormap : x_appdefcolormap; }

inline void *QPaintDevice::x11Visual() const
{ return x11Data ? x11Data->x_visual : x_appvisual; }

inline bool QPaintDevice::x11DefaultVisual() const
{ return x11Data ? x11Data->x_defvisual : x_appdefvisual; }

inline Display *QPaintDevice::x11AppDisplay()
{ return x_appdisplay; }

inline int QPaintDevice::x11AppScreen()
{ return x_appscreen; }

inline int QPaintDevice::x11AppDepth()
{ return x_appdepth; }

inline int QPaintDevice::x11AppCells()
{ return x_appcells; }

inline HANDLE QPaintDevice::x11AppColormap()
{ return x_appcolormap; }

inline bool QPaintDevice::x11AppDefaultColormap()
{ return x_appdefcolormap; }

inline void *QPaintDevice::x11AppVisual()
{ return x_appvisual; }

inline bool QPaintDevice::x11AppDefaultVisual()
{ return x_appdefvisual; }



 
inline void bitBlt( QPaintDevice *dst, const QPoint &dp,
		    const QPaintDevice *src, const QRect &sr =QRect(0,0,-1,-1),
		    Qt::RasterOp rop=Qt::CopyROP, bool ignoreMask=FALSE )
{
    bitBlt( dst, dp.x(), dp.y(), src, sr.x(), sr.y(), sr.width(), sr.height(),
	    rop, ignoreMask );
}





# 44 "/opt/Qtopia/include/qwidget.h" 2

# 1 "/opt/Qtopia/include/qpalette.h" 1
 









































# 1 "/opt/Qtopia/include/qcolor.h" 1
 











































const QRgb  RGB_DIRTY	= 0x80000000;		 
const QRgb  RGB_INVALID = 0x40000000;		 
const QRgb  RGB_DIRECT	= 0x20000000;		 
const QRgb  RGB_MASK	= 0x00ffffff;		 


  inline int qRed( QRgb rgb )		 
{ return (int)((rgb >> 16) & 0xff); }

  inline int qGreen( QRgb rgb )		 
{ return (int)((rgb >> 8) & 0xff); }

  inline int qBlue( QRgb rgb )		 
{ return (int)(rgb & 0xff); }

  inline int qAlpha( QRgb rgb )		 
{ return (int)((rgb >> 24) & 0xff); }

  inline QRgb qRgb( int r, int g, int b ) 
{ return (0xff << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

  inline QRgb qRgba( int r, int g, int b, int a ) 
{ return ((a & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

  inline int qGray( int r, int g, int b ) 
{ return (r*11+g*16+b*5)/32; }

  inline int qGray( QRgb rgb )		 
{ return qGray( qRed(rgb), qGreen(rgb), qBlue(rgb) ); }


class   QColor
{
public:
    enum Spec { Rgb, Hsv };

    QColor();
    QColor( int r, int g, int b );
    QColor( int x, int y, int z, Spec );
    QColor( QRgb rgb, uint pixel=0xffffffff);
    QColor( const QString& name );
    QColor( const char *name );
    QColor( const QColor & );
    QColor &operator=( const QColor & );

    bool   isValid() const;
    bool   isDirty() const;

    QString name() const;
    void   setNamedColor( const QString& name );

    void   rgb( int *r, int *g, int *b ) const;
    QRgb   rgb()    const;
    void   setRgb( int r, int g, int b );
    void   setRgb( QRgb rgb );

    int	   red()    const;
    int	   green()  const;
    int	   blue()   const;

    void   hsv( int *h, int *s, int *v ) const;
    void   getHsv( int &h, int &s, int &v ) const;
    void   setHsv( int h, int s, int v );

    QColor light( int f = 150 ) const;
    QColor dark( int f = 200 )	const;

    bool   operator==( const QColor &c ) const;
    bool   operator!=( const QColor &c ) const;

    static bool lazyAlloc();
    static void setLazyAlloc( bool );
    uint   alloc();
    uint   pixel()  const;

    static int  maxColors();
    static int  numBitPlanes();

    static int  enterAllocContext();
    static void leaveAllocContext();
    static int  currentAllocContext();
    static void destroyAllocContext( int );






    static void initialize();
    static void cleanup();

private:
    void   setSystemNamedColor( const QString& name );
    static void initGlobalColors();
    static QColor* globalColors();
    static bool color_init;
    static bool globals_init;
    static bool lazy_alloc;



    uint   pix;
    QRgb   rgbVal;
};


inline QColor::QColor()
{ rgbVal = RGB_INVALID; pix = 0; }

inline QColor::QColor( int r, int g, int b )
{ setRgb( r, g, b ); }

inline bool QColor::isValid() const
{ return (rgbVal & RGB_INVALID) == 0; }

inline bool QColor::isDirty() const
{ return (rgbVal & RGB_DIRTY) != 0; }

inline QRgb QColor::rgb() const
{ return rgbVal | ~RGB_MASK; }

inline int QColor::red() const
{ return qRed(rgbVal); }

inline int QColor::green() const
{ return qGreen(rgbVal); }

inline int QColor::blue() const
{ return qBlue(rgbVal); }

inline uint QColor::pixel() const
{ return (rgbVal & RGB_DIRTY) == 0 ? pix : ((QColor*)this)->alloc(); }

inline bool QColor::lazyAlloc()
{ return lazy_alloc; }


inline bool QColor::operator==( const QColor &c ) const
{
    return isValid()==c.isValid() &&
	((((rgbVal | c.rgbVal) & RGB_DIRECT) == 0 &&
	    (rgbVal & RGB_MASK) == (c.rgbVal & RGB_MASK)) ||
	   ((rgbVal & c.rgbVal & RGB_DIRECT) != 0 &&
	    (rgbVal & RGB_MASK) == (c.rgbVal & RGB_MASK) && pix == c.pix));
}

inline bool QColor::operator!=( const QColor &c ) const
{
    return !operator==(c);
}


 




  QDataStream &operator<<( QDataStream &, const QColor & );
  QDataStream &operator>>( QDataStream &, QColor & );



# 43 "/opt/Qtopia/include/qpalette.h" 2


# 1 "/opt/Qtopia/include/qbrush.h" 1
 













































class   QBrush: public Qt
{
friend class QPainter;
public:
    QBrush();
    QBrush( BrushStyle );
    QBrush( const QColor &, BrushStyle=SolidPattern );
    QBrush( const QColor &, const QPixmap & );
    QBrush( const QBrush & );
   ~QBrush();
    QBrush &operator=( const QBrush & );

    BrushStyle	style()	 const		{ return data->style; }
    void	setStyle( BrushStyle );
    const QColor &color()const		{ return data->color; }
    void	setColor( const QColor & );
    QPixmap    *pixmap() const		{ return data->pixmap; }
    void	setPixmap( const QPixmap & );

    bool	operator==( const QBrush &p ) const;
    bool	operator!=( const QBrush &b ) const
					{ return !(operator==(b)); }

private:
    QBrush	copy()	const;
    void	detach();
    void	init( const QColor &, BrushStyle );
    struct QBrushData : public QShared {	 
	BrushStyle style;
	QColor	  color;
	QPixmap	 *pixmap;
    } *data;
};


 




  QDataStream &operator<<( QDataStream &, const QBrush & );
  QDataStream &operator>>( QDataStream &, QBrush & );



# 45 "/opt/Qtopia/include/qpalette.h" 2




class QColorGroupPrivate;


class   QColorGroup
{
public:
    QColorGroup();
    QColorGroup( const QColor &foreground, const QColor &button,
		 const QColor &light, const QColor &dark, const QColor &mid,
		 const QColor &text, const QColor &base );
    QColorGroup( const QBrush &foreground, const QBrush &button,
		 const QBrush &light, const QBrush &dark, const QBrush &mid,
		 const QBrush &text, const QBrush &bright_text,
		 const QBrush &base, const QBrush &background);
    QColorGroup( const QColorGroup & );

   ~QColorGroup();

    QColorGroup& operator =(const QColorGroup&);

     
    enum ColorRole { Foreground, Button, Light, Midlight, Dark, Mid,
                     Text, BrightText, ButtonText, Base, Background, Shadow,
                     Highlight, HighlightedText,
		     NColorRoles };

    const QColor &color( ColorRole ) const;
    const QBrush &brush( ColorRole ) const;
    void setColor( ColorRole, const QColor & );
    void setBrush( ColorRole, const QBrush & );

    const QColor &foreground()	const	{ return br[Foreground].color(); }
    const QColor &button()	const	{ return br[Button].color(); }
    const QColor &light()	const	{ return br[Light].color(); }
    const QColor &dark()	const	{ return br[Dark].color(); }
    const QColor &mid()		const	{ return br[Mid].color(); }
    const QColor &text()	const	{ return br[Text].color(); }
    const QColor &base()	const	{ return br[Base].color(); }
    const QColor &background()	const	{ return br[Background].color(); }

    const QColor &midlight()	const	{ return br[Midlight].color(); }
    const QColor &brightText()	const	{ return br[BrightText].color(); }
    const QColor &buttonText()	const	{ return br[ButtonText].color(); }
    const QColor &shadow()	const	{ return br[Shadow].color(); }
    const QColor &highlight()	const	{ return br[Highlight].color(); }
    const QColor &highlightedText() const{return br[HighlightedText].color(); }

    bool	operator==( const QColorGroup &g ) const;
    bool	operator!=( const QColorGroup &g ) const
	{ return !(operator==(g)); }

private:
    QBrush *br;
    QColorGroupPrivate * d;

    friend class QPalette;
};


class   QPalette
{
public:
    QPalette();
    QPalette( const QColor &button );
    QPalette( const QColor &button, const QColor &background );
    QPalette( const QColorGroup &active, const QColorGroup &disabled,
	      const QColorGroup &inactive );
    QPalette( const QPalette & );
   ~QPalette();
    QPalette &operator=( const QPalette & );

    enum ColorGroup { Normal, Disabled, Active, Inactive, NColorGroups };

    const QColor &color( ColorGroup, QColorGroup::ColorRole ) const;
    const QBrush &brush( ColorGroup, QColorGroup::ColorRole ) const;
    void setColor( ColorGroup, QColorGroup::ColorRole, const QColor & );
    void setBrush( ColorGroup, QColorGroup::ColorRole, const QBrush & );

    void setColor( QColorGroup::ColorRole, const QColor & );
    void setBrush( QColorGroup::ColorRole, const QBrush & );

    QPalette	copy() const;

    const QColorGroup &active() const { return data->active; }
    const QColorGroup &disabled() const { return data->disabled; }
    const QColorGroup &inactive() const { return data->inactive; }
    const QColorGroup &normal() const { return data->normal; }  

    void	setActive( const QColorGroup & );
    void	setDisabled( const QColorGroup & );
    void	setInactive( const QColorGroup & );
    void	setNormal( const QColorGroup & );  

    bool	operator==( const QPalette &p ) const;
    bool	operator!=( const QPalette &p ) const
					{ return !(operator==(p)); }
    bool	isCopyOf( const QPalette & );

    int		serialNumber() const	{ return data->ser_no; }

private:
    void	detach();
    QBrush 	&directBrush( ColorGroup, QColorGroup::ColorRole ) const;

    struct QPalData : public QShared {
	QColorGroup normal;  
	QColorGroup disabled;
	QColorGroup active;
	int	    ser_no;
	QColorGroup inactive;
    } *data;
    static QPalData *defPalData;
    static void cleanupDefPal();
};


 




  QDataStream &operator<<( QDataStream &, const QColorGroup & );
  QDataStream &operator>>( QDataStream &, QColorGroup & );

  QDataStream &operator<<( QDataStream &, const QPalette & );
  QDataStream &operator>>( QDataStream &, QPalette & );




# 45 "/opt/Qtopia/include/qwidget.h" 2

# 1 "/opt/Qtopia/include/qcursor.h" 1
 













































 


# 62 "/opt/Qtopia/include/qcursor.h"




struct QCursorData;


class   QCursor
{
public:
    QCursor();					 
    QCursor( int shape );
    QCursor( const QBitmap &bitmap, const QBitmap &mask,
	     int hotX=-1, int hotY=-1 );
    QCursor( const QPixmap &pixmap,
	     int hotX=-1, int hotY=-1 );
    QCursor( const QCursor & );
   ~QCursor();
    QCursor &operator=( const QCursor & );

    int		  shape()   const;
    void	  setShape( int );

    const QBitmap *bitmap() const;
    const QBitmap *mask()   const;
    QPoint	  hotSpot() const;




    HANDLE	  handle()  const;






    static QPoint pos();
    static void	  setPos( int x, int y );
    static void	  setPos( const QPoint & );

    static void	  initialize();
    static void	  cleanup();

private:
    void	  setBitmap( const QBitmap &bitmap, const QBitmap &mask,
				 int hotX, int hotY );
    void	  update() const;
    QCursorData	 *data;
    QCursor	 *find_cur(int);
};



 



 
enum QCursorShape {
    ArrowCursor, UpArrowCursor, CrossCursor, WaitCursor, IbeamCursor,
    SizeVerCursor, SizeHorCursor, SizeBDiagCursor, SizeFDiagCursor,
    SizeAllCursor, BlankCursor, SplitVCursor, SplitHCursor, PointingHandCursor,
    ForbiddenCursor, LastCursor = ForbiddenCursor, BitmapCursor=24 };


 



  QDataStream &operator<<( QDataStream &, const QCursor & );
  QDataStream &operator>>( QDataStream &, QCursor & );




inline void QCursor::setPos( const QPoint &p )
{
    setPos( p.x(), p.y() );
}


# 46 "/opt/Qtopia/include/qwidget.h" 2

# 1 "/opt/Qtopia/include/qfont.h" 1
 













































class QStringList;
struct QFontDef;
struct QFontData;
class QFontInternal;
class QRenderedFont;

class   QFont					 
{
public:
    enum CharSet   { ISO_8859_1,  Latin1 = ISO_8859_1, AnyCharSet,
		     ISO_8859_2,  Latin2 = ISO_8859_2,
		     ISO_8859_3,  Latin3 = ISO_8859_3,
		     ISO_8859_4,  Latin4 = ISO_8859_4,
		     ISO_8859_5,
		     ISO_8859_6,
		     ISO_8859_7,
		     ISO_8859_8,
		     ISO_8859_9,  Latin5 = ISO_8859_9,
		     ISO_8859_10, Latin6 = ISO_8859_10,
		     ISO_8859_11, TIS620 = ISO_8859_11,
		     ISO_8859_12,
		     ISO_8859_13, Latin7 = ISO_8859_13,
		     ISO_8859_14, Latin8 = ISO_8859_14,
		     ISO_8859_15, Latin9 = ISO_8859_15,
		     KOI8R,
		     Set_Ja, Set_1 = Set_Ja,
		     Set_Ko,
		     Set_Th_TH,
		     Set_Zh,
		     Set_Zh_TW,
		     Set_N = Set_Zh_TW,
		     Unicode,
		      





		     Set_GBK,
		     Set_Big5,

		     TSCII,
		     KOI8U,
		     CP1251,
		     PT154,
		      


		      
		     JIS_X_0201 = 0xa0,
		      
		     JIS_X_0208 = 0xc0, Enc16 = JIS_X_0208,
		     KSC_5601,
		     GB_2312,
		     Big5
    };
    enum StyleHint { Helvetica, Times, Courier, OldEnglish,  System, AnyStyle,
		     SansSerif	= Helvetica,
		     Serif	= Times,
		     TypeWriter = Courier,
		     Decorative = OldEnglish};
    enum StyleStrategy { PreferDefault = 0x0001,
			  PreferBitmap = 0x0002,
			  PreferDevice = 0x0004,
			  PreferOutline = 0x0008,
			  ForceOutline = 0x0010,
			  PreferMatch = 0x0020,
			  PreferQuality = 0x0040 };
    enum Weight	   { Light = 25, Normal = 50, DemiBold = 63,
		     Bold  = 75, Black	= 87 };
    QFont();					 
    QFont( const QString &family, int pointSize = 12,
	   int weight = Normal, bool italic = FALSE );
    QFont( const QString &family, int pointSize,
	   int weight, bool italic, CharSet charSet );
    QFont( const QFont & );
    ~QFont();
    QFont      &operator=( const QFont & );

    QString	family()	const;
    void	setFamily( const QString &);
    int		pointSize()	const;
    float	pointSizeFloat()	const;
    void	setPointSize( int );
    void	setPointSizeFloat( float );
    int		pixelSize() const;
    void	setPixelSize( int );
    void	setPixelSizeFloat( float );
    int		weight()	const;
    void	setWeight( int );
    bool	bold()		const;
    void	setBold( bool );
    bool	italic()	const;
    void	setItalic( bool );
    bool	underline()	const;
    void	setUnderline( bool );
    bool	strikeOut()	const;
    void	setStrikeOut( bool );
    bool	fixedPitch()	const;
    void	setFixedPitch( bool );
    StyleHint	styleHint()	const;
    void	setStyleHint( StyleHint );
    StyleStrategy styleStrategy() const;
    void	setStyleHint( StyleHint, StyleStrategy );
    CharSet	charSet()	const;
    void	setCharSet( CharSet );

    static CharSet charSetForLocale();

    bool	rawMode()      const;
    void	setRawMode( bool );

    bool	exactMatch()	const;

    bool	operator==( const QFont & ) const;
    bool	operator!=( const QFont & ) const;
    bool	isCopyOf( const QFont & ) const;






    HANDLE	handle() const;




    void	setRawName( const QString & );
    QString	rawName() const;

    QString	key() const;

    static QString encodingName( CharSet );

    static QFont defaultFont();
    static void setDefaultFont( const QFont & );

    static QString substitute( const QString &familyName );
    static void insertSubstitution( const QString&, const QString &);
    static void removeSubstitution( const QString &);
    static QStringList substitutions();

    static void initialize();
    static void locale_init();
    static void cleanup();
    static void cacheStatistics();





protected:
    bool	dirty()			const;

    QString	defaultFamily()		const;
    QString	lastResortFamily()	const;
    QString	lastResortFont()	const;
    int		deciPointSize()		const;

private:
    QFont( QFontData * );
    void	init();
    void	detach();
    void	initFontInfo() const;
    void	load() const;








    friend class QFont_Private;
    friend class QFontInternal;
    friend class QFontMetrics;
    friend class QFontInfo;
    friend class QPainter;





    friend   QDataStream &operator<<( QDataStream &, const QFont & );
    friend   QDataStream &operator>>( QDataStream &, QFont & );

    QFontData	 *d;				 
    static CharSet defaultCharSet;
};

inline bool QFont::bold() const
{ return weight() > Normal; }

inline void QFont::setBold( bool enable )
{ setWeight( enable ? Bold : Normal ); }


 




  QDataStream &operator<<( QDataStream &, const QFont & );
  QDataStream &operator>>( QDataStream &, QFont & );



# 47 "/opt/Qtopia/include/qwidget.h" 2

# 1 "/opt/Qtopia/include/qfontmetrics.h" 1
 












































class QTextCodec;


class   QFontMetrics
{
public:
    QFontMetrics( const QFont & );
    QFontMetrics( const QFontMetrics & );
   ~QFontMetrics();

    QFontMetrics &operator=( const QFontMetrics & );

    int		ascent()	const;
    int		descent()	const;
    int		height()	const;
    int		leading()	const;
    int		lineSpacing()	const;
    int		minLeftBearing() const;
    int		minRightBearing() const;
    int		maxWidth()	const;

    bool	inFont(QChar)	const;

    int		leftBearing(QChar) const;
    int		rightBearing(QChar) const;
    int		width( const QString &, int len = -1 ) const;
    int		width( QChar ) const;
    int		width( char c ) const { return width( (QChar) c ); }
    QRect	boundingRect( const QString &, int len = -1 ) const;
    QRect	boundingRect( QChar ) const;
    QRect	boundingRect( int x, int y, int w, int h, int flags,
			      const QString& str, int len=-1, int tabstops=0,
			      int *tabarray=0, char **intern=0 ) const;
    QSize	size( int flags,
		      const QString& str, int len=-1, int tabstops=0,
		      int *tabarray=0, char **intern=0 ) const;

    int		underlinePos()	const;
    int		strikeOutPos()	const;
    int		lineWidth()	const;

private:
    QFontMetrics( const QPainter * );
    static void reset( const QPainter * );
    const QFontDef *spec() const;





    void   *fontStruct() const;
    void   *fontSet() const;
    const QTextCodec *mapper() const;
    int	    printerAdjusted(int) const;




    friend class QWidget;
    friend class QPainter;

    QFontInternal *fin;
    QPainter      *painter;
    int		   flags;

    bool    underlineFlag()  const { return (flags & 0x1) != 0; }
    bool    strikeOutFlag()  const { return (flags & 0x2) != 0; }
    void    setUnderlineFlag()	   { flags |= 0x1; }
    void    setStrikeOutFlag()	   { flags |= 0x2; }
};



# 48 "/opt/Qtopia/include/qwidget.h" 2

# 1 "/opt/Qtopia/include/qfontinfo.h" 1
 












































class   QFontInfo
{
public:
    QFontInfo( const QFont & );
    QFontInfo( const QFontInfo & );
   ~QFontInfo();

    QFontInfo	       &operator=( const QFontInfo & );

    QString   	        family()	const;
    int			pointSize()	const;
    bool		italic()	const;
    int			weight()	const;
    bool		bold()		const;
    bool		underline()	const;
    bool		strikeOut()	const;
    bool		fixedPitch()	const;
    QFont::StyleHint	styleHint()	const;
    QFont::CharSet	charSet()	const;
    bool		rawMode()	const;

    bool		exactMatch()	const;


    const QFont &font() const;


private:
    QFontInfo( const QPainter * );
    static void reset( const QPainter * );
    const QFontDef *spec() const;

    QFontInternal *fin;
    QPainter      *painter;
    int		   flags;

    bool    underlineFlag()  const { return (flags & 0x1) != 0; }
    bool    strikeOutFlag()  const { return (flags & 0x2) != 0; }
    bool    exactMatchFlag() const { return (flags & 0x4) != 0; }
    void    setUnderlineFlag()	   { flags |= 0x1; }
    void    setStrikeOutFlag()	   { flags |= 0x2; }
    void    setExactMatchFlag()	   { flags |= 0x4; }

    friend class QWidget;
    friend class QPainter;
};


inline bool QFontInfo::bold() const
{ return weight() > QFont::Normal; }



# 49 "/opt/Qtopia/include/qwidget.h" 2

# 1 "/opt/Qtopia/include/qstyle.h" 1
 












































class QButton;
class QPushButton;
class QScrollBar;
class QTabBar;
class QTab;
class QPopupMenu;
class QMenuItem;
class QToolButton;

class   QStyle: public QObject
{
    public:	QMetaObject *metaObject() const { return staticMetaObject();	}	const char *className() const;	static QMetaObject* staticMetaObject();	static QString tr(const char*); static QString tr(const char*, const char*); 	protected:	void initMetaObject();	private:	static QMetaObject *metaObj; 
    GUIStyle gs;

private:
    QStyle(GUIStyle);
    QStyle();
    friend class QCommonStyle;

public:
    virtual ~QStyle();


    operator GUIStyle() const { return gs; }
    int operator==(GUIStyle s) const { return gs==s; }
    int operator!=(GUIStyle s) const { return gs!=s; }


    GUIStyle guiStyle() const { return gs; }

     

    virtual void polish( QWidget* );
    virtual void unPolish( QWidget* );

    virtual void polish( QApplication*);
    virtual void unPolish( QApplication*);

    virtual void polish( QPalette&);

    virtual QRect itemRect( QPainter *p, int x, int y, int w, int h,
		    int flags, bool enabled,
		    const QPixmap *pixmap,
		    const QString& text, int len=-1 );  

    virtual void drawItem( QPainter *p, int x, int y, int w, int h,
		    int flags, const QColorGroup &g, bool enabled,
		    const QPixmap *pixmap, const QString& text,
			   int len=-1, const QColor* penColor = 0 );


    virtual void drawSeparator( QPainter *p, int x1, int y1, int x2, int y2,
		     const QColorGroup &g, bool sunken = TRUE,
		     int lineWidth = 1, int midLineWidth = 0 );

    virtual void drawRect( QPainter *p, int x, int y, int w, int h,
		    const QColor &, int lineWidth = 1,
		    const QBrush *fill = 0 );

    virtual void drawRectStrong( QPainter *p, int x, int y, int w, int h,
		     const QColorGroup &, bool sunken=FALSE,
		     int lineWidth = 1, int midLineWidth = 0,
		     const QBrush *fill = 0 );

    virtual void drawButton( QPainter *p, int x, int y, int w, int h,
		     const QColorGroup &g, bool sunken = FALSE,
		     const QBrush *fill = 0 ) = 0;

    virtual QRect buttonRect( int x, int y, int w, int h);  

    virtual void drawButtonMask( QPainter *p, int x, int y, int w, int h);

    virtual void drawBevelButton( QPainter *p, int x, int y, int w, int h,
		     const QColorGroup &g, bool sunken = FALSE,
		     const QBrush *fill = 0 ) = 0;

    QRect bevelButtonRect( int x, int y, int w, int h);  

    virtual void drawToolButton( QPainter *p, int x, int y, int w, int h,
		     const QColorGroup &g, bool sunken = FALSE,
		     const QBrush *fill = 0 );
    void drawToolButton( QToolButton* btn, QPainter *p);  

    QRect toolButtonRect(  int x, int y, int w, int h);  

    virtual void drawPanel( QPainter *p, int x, int y, int w, int h,
		    const QColorGroup &, bool sunken=FALSE,
		    int lineWidth = 1, const QBrush *fill = 0 );

    virtual void drawPopupPanel( QPainter *p, int x, int y, int w, int h,
				 const QColorGroup &,  int lineWidth = 2,
				 const QBrush *fill = 0 );

    virtual void drawArrow( QPainter *p, Qt::ArrowType type, bool down,
		     int x, int y, int w, int h,
		     const QColorGroup &g, bool enabled, const QBrush *fill = 0 ) = 0;

     
    virtual QSize exclusiveIndicatorSize() const = 0;
    virtual void drawExclusiveIndicator( QPainter* p, int x, int y, int w, int h,
		    const QColorGroup &g, bool on, bool down = FALSE, bool enabled = TRUE ) = 0;
    virtual void drawExclusiveIndicatorMask( QPainter *p, int x, int y, int w, int h, bool on);

     
    virtual QSize indicatorSize() const = 0;
    virtual void drawIndicator( QPainter* p, int x, int y, int w, int h, const QColorGroup &g,
				int state, bool down = FALSE, bool enabled = TRUE ) = 0;
    virtual void drawIndicatorMask( QPainter *p, int x, int y, int w, int h, int state);


     
    virtual void drawFocusRect( QPainter*, const QRect &,
				const QColorGroup &, const QColor* bg = 0,
				bool = FALSE ) = 0;


     

     
    virtual void drawComboButton( QPainter *p, int x, int y, int w, int h,
				  const QColorGroup &g, bool sunken = FALSE,
				  bool editable = FALSE,
				  bool enabled = TRUE,
				  const QBrush *fill = 0 ) = 0;
    virtual QRect comboButtonRect( int x, int y,
		    int w, int h) = 0;  
    virtual QRect comboButtonFocusRect( int x, int y,
		    int w, int h) = 0;  

    virtual void drawComboButtonMask( QPainter *p, int x, int y, int w, int h) = 0;

     
    virtual void drawPushButton( QPushButton* btn, QPainter *p) = 0;
     
    virtual void drawPushButtonLabel( QPushButton* btn, QPainter *p) = 0;
    QRect pushButtonContentsRect( QPushButton* btn );  
    int menuButtonIndicatorWidth( int h );  
    virtual void getButtonShift( int &x, int &y) = 0;  

     
    virtual int defaultFrameWidth() const = 0;

     
    virtual void tabbarMetrics( const QTabBar*,
		    int&, int&, int& ) = 0;  
    virtual void drawTab( QPainter*, const QTabBar*, QTab*, bool selected ) = 0;
    virtual void drawTabMask( QPainter*, const QTabBar*, QTab*, bool selected ) = 0;

     
    enum ScrollControl { AddLine = 0x1 , SubLine  = 0x2 , AddPage = 0x4,
			 SubPage = 0x8 , First = 0x10, Last = 0x20,
			 Slider  = 0x40, NoScroll = 0x80 };

    virtual void scrollBarMetrics( const QScrollBar*,
		    int&, int&, int&, int&) = 0;  
    virtual void drawScrollBarControls( QPainter*,  const QScrollBar*,
					int sliderStart, uint controls,
					uint activeControl ) = 0;
    virtual ScrollControl scrollBarPointOver( const QScrollBar*,
					int sliderStart, const QPoint& ) = 0;

     
    virtual int sliderLength() const = 0;
    virtual void drawSlider( QPainter *p,
			     int x, int y, int w, int h,
			     const QColorGroup &g,
			     Orientation, bool tickAbove, bool tickBelow) = 0;

    virtual void drawSliderMask( QPainter *p,
				 int x, int y, int w, int h,
				 Orientation, bool tickAbove, bool tickBelow) = 0;
    virtual void drawSliderGroove( QPainter *p,
				   int x, int y, int w, int h,
				   const QColorGroup& g, QCOORD c,
				   Orientation ) = 0;
    virtual void drawSliderGrooveMask( QPainter *p,
				       int x, int y, int w, int h,
				       QCOORD c,
				       Orientation ) = 0;
    virtual int maximumSliderDragDistance() const = 0;

    virtual int splitterWidth() const = 0;
    virtual void drawSplitter( QPainter *p,
			     int x, int y, int w, int h,
			     const QColorGroup &g,
			     Orientation) = 0;

    virtual void drawCheckMark( QPainter *p, int x, int y, int w, int h,
				const QColorGroup &g,
				bool act, bool dis ) = 0;
    virtual void polishPopupMenu( QPopupMenu* ) = 0;

    virtual int extraPopupMenuItemWidth( bool checkable, int maxpmw,
				QMenuItem* mi,
				const QFontMetrics& fm  ) = 0;  
    virtual int popupSubmenuIndicatorWidth(
				const QFontMetrics& fm  ) = 0;  
    virtual int popupMenuItemHeight( bool checkable,
				QMenuItem* mi,
				const QFontMetrics& fm  ) = 0;  
    virtual void drawPopupMenuItem( QPainter* p, bool checkable,
				    int maxpmw, int tab, QMenuItem* mi,
				    const QPalette& pal,
				    bool act, bool enabled,
				    int x, int y, int w, int h) = 0;
    void drawMenuBarItem( QPainter* p, int x, int y, int w, int h,  
				    QMenuItem* mi, QColorGroup& g,
				    bool enabled, bool active );

     
    QSize scrollBarExtent();  
    int buttonDefaultIndicatorWidth() const;
    int buttonMargin() const;  
    int toolBarHandleExtent() const;  
    int toolBarHandleExtend() const;  
    int sliderThickness() const ;  
    void drawToolBarHandle( QPainter *p, const QRect &r,
			    Qt::Orientation orientation,
			    bool highlight, const QColorGroup &cg,
			    bool drawBorder = FALSE );  

protected:
    void setScrollBarExtent( int w, int h=-1 );  
    void setButtonDefaultIndicatorWidth( int w );  
    void setButtonMargin( int w );  
    void setSliderThickness(int t);  


private:	 

    QStyle( const QStyle & );
    QStyle& operator=( const QStyle & );

};



# 50 "/opt/Qtopia/include/qwidget.h" 2

# 1 "/opt/Qtopia/include/qsizepolicy.h" 1
 











































class   QSizePolicy
{
private:
    enum { HSize = 6, HMask = 0x3f, VMask = HMask << HSize,
	   MayGrow = 1, ExpMask = 2, MayShrink = 4 };
public:
    enum SizeType { Fixed = 0,
		    Minimum = MayGrow,
		    Maximum = MayShrink,
		    Preferred = MayGrow|MayShrink ,
		    MinimumExpanding = Minimum|ExpMask,
		    Expanding = MinimumExpanding|MayShrink };

    enum ExpandData { NoDirection = 0,
		      Horizontal = 1,
		      Vertical = 2,
		      BothDirections = Horizontal | Vertical };

    QSizePolicy() { data = 0; }

    QSizePolicy( SizeType hor, SizeType ver, bool hfw = FALSE );

    SizeType horData() const { return (SizeType)( data & HMask ); }
    SizeType verData() const { return (SizeType)(( data & VMask ) >> HSize); }

    bool mayShrinkHorizontally() const { return horData() & MayShrink; }
    bool mayShrinkVertically() const { return verData() & MayShrink; }
    bool mayGrowHorizontally() const { return horData() & MayGrow; }
    bool mayGrowVertically() const { return verData() & MayGrow; }

    ExpandData expanding() const
    {
	return (ExpandData)( (int)(verData()&ExpMask ? Vertical : 0)+
			     (int)(horData()&ExpMask ? Horizontal : 0) );
    }

    void setHorData( SizeType d ) { data = (data & ~HMask) | d; }
    void setVerData( SizeType d ) { data = (data & ~(HMask<<HSize)) |
					   (d<<HSize); }
		
    void setHeightForWidth( bool b ) { data = b ? ( data | ( 1 << 2*HSize ) )
					      : ( data & ~( 1 << 2*HSize ) );  }
    bool hasHeightForWidth() const { return data & ( 1 << 2*HSize ); }

    bool operator==( const QSizePolicy& s ) const { return data == s.data; }
    bool operator!=( const QSizePolicy& s ) const { return data != s.data; }

private:
    QSizePolicy( int i ): data( i ) {}

    Q_UINT16 data;
};

inline QSizePolicy::QSizePolicy( SizeType hor, SizeType ver, bool hfw )
	: data( hor | (ver<<HSize) | (hfw ? (1<<2*HSize) : 0) ) {}


# 51 "/opt/Qtopia/include/qwidget.h" 2



class QLayout;
struct QWExtra;
struct QTLWExtra;
class QFocusData;
class QStyle;
class QWSRegionManager;

class   QWidget : public QObject, public QPaintDevice
{
    public:	QMetaObject *metaObject() const { return staticMetaObject();	}	const char *className() const;	static QMetaObject* staticMetaObject();	static QString tr(const char*); static QString tr(const char*, const char*); 	protected:	void initMetaObject();	private:	static QMetaObject *metaObj; 
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

     
     

     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     

public:
    QWidget( QWidget *parent=0, const char *name=0, WFlags f=0 );
    ~QWidget();

    WId		 winId() const;
    void	 setName( const char *name );

     

    QStyle     &style() const;
    void        setStyle( QStyle * );

     

    bool	 isTopLevel()	const;
    bool	 isModal()	const;
    bool	 isPopup()	const;
    bool	 isDesktop()	const;

    bool	 isEnabled()	const;
    bool	 isEnabledTo(QWidget*) const;
    bool	 isEnabledToTLW() const;

public  :
    virtual void setEnabled( bool );
    void setDisabled( bool );

     

public:
    QRect	 frameGeometry() const;
    const QRect &geometry()	const;
    int		 x()		const;
    int		 y()		const;
    QPoint	 pos()		const;
    QSize	 frameSize()    const;
    QSize	 size()		const;
    int		 width()	const;
    int		 height()	const;
    QRect	 rect()		const;
    QRect	 childrenRect() const;
    QRegion	 childrenRegion() const;

    QSize	 minimumSize()	 const;
    QSize	 maximumSize()	 const;
    int		 minimumWidth()	 const;
    int		 minimumHeight() const;
    int		 maximumWidth()	 const;
    int		 maximumHeight() const;
    void	 setMinimumSize( const QSize & );
    virtual void setMinimumSize( int minw, int minh );
    void	 setMaximumSize( const QSize & );
    virtual void setMaximumSize( int maxw, int maxh );
    void	 setMinimumWidth( int minw );
    void	 setMinimumHeight( int minh );
    void	 setMaximumWidth( int maxw );
    void	 setMaximumHeight( int maxh );

    QSize	 sizeIncrement() const;
    void	 setSizeIncrement( const QSize & );
    virtual void setSizeIncrement( int w, int h );
    QSize	 baseSize() const;
    void	 setBaseSize( const QSize & );
    void	 setBaseSize( int basew, int baseh );

    void	setFixedSize( const QSize & );
    void	setFixedSize( int w, int h );
    void	setFixedWidth( int w );
    void	setFixedHeight( int h );

     

    QPoint	 mapToGlobal( const QPoint & )	 const;
    QPoint	 mapFromGlobal( const QPoint & ) const;
    QPoint	 mapToParent( const QPoint & )	 const;
    QPoint	 mapFromParent( const QPoint & ) const;
    QPoint	 mapTo( QWidget *, const QPoint & ) const;
    QPoint	 mapFrom( QWidget *, const QPoint & ) const;

    QWidget	*topLevelWidget()   const;

     

    enum BackgroundMode { FixedColor, FixedPixmap, NoBackground,
			  PaletteForeground, PaletteButton, PaletteLight,
			  PaletteMidlight, PaletteDark, PaletteMid,
			  PaletteText, PaletteBrightText, PaletteBase,
			  PaletteBackground, PaletteShadow, PaletteHighlight,
			  PaletteHighlightedText, PaletteButtonText,
			  X11ParentRelative };

    BackgroundMode	backgroundMode() const;
    virtual void	setBackgroundMode( BackgroundMode );

    const QColor &	backgroundColor() const;
    const QColor &	foregroundColor() const;
    virtual void	setBackgroundColor( const QColor & );

    const QPixmap *	backgroundPixmap() const;
    virtual void	setBackgroundPixmap( const QPixmap & );


    const QColorGroup & colorGroup() const;
    const QPalette &	palette()    const;
    bool		ownPalette() const;
    virtual void	setPalette( const QPalette & );
    void		unsetPalette();

    QFont		font() const;
    bool		ownFont() const;
    virtual void	setFont( const QFont & );
    void		unsetFont();
    QFontMetrics	fontMetrics() const;
    QFontInfo	 	fontInfo() const;

    enum PropagationMode { NoChildren, AllChildren,
			   SameFont, SamePalette = SameFont };

    PropagationMode	fontPropagation() const;  
    virtual void	setFontPropagation( PropagationMode );  

    PropagationMode	palettePropagation() const;  
    virtual void	setPalettePropagation( PropagationMode );  

    const QCursor      &cursor() const;
    bool		ownCursor() const;
    virtual void	setCursor( const QCursor & );
    virtual void	unsetCursor();

    QString		caption() const;
    const QPixmap      *icon() const;
    QString		iconText() const;
    bool		hasMouseTracking() const;

    virtual void	setMask( const QBitmap & );
    virtual void	setMask( const QRegion & );
    void		clearMask();

public  :
    virtual void	setCaption( const QString &);
    virtual void	setIcon( const QPixmap & );
    virtual void	setIconText( const QString &);
    virtual void	setMouseTracking( bool enable );

     

    virtual void	setFocus();
    void		clearFocus();

public:
    enum FocusPolicy {
	NoFocus = 0,
	TabFocus = 0x1,
	ClickFocus = 0x2,
	StrongFocus = 0x3,
	WheelFocus = 0x7
    };

    bool		isActiveWindow() const;
    virtual void	setActiveWindow();
    bool		isFocusEnabled() const;

    FocusPolicy		focusPolicy() const;
    virtual void	setFocusPolicy( FocusPolicy );
    bool		hasFocus() const;
    static void		setTabOrder( QWidget *, QWidget * );
    virtual void	setFocusProxy( QWidget * );
    QWidget *		focusProxy() const;

     

    void		grabMouse();

    void		grabMouse( const QCursor & );

    void		releaseMouse();
    void		grabKeyboard();
    void		releaseKeyboard();
    static QWidget *	mouseGrabber();
    static QWidget *	keyboardGrabber();

     

    bool	 	isUpdatesEnabled() const;




public  :
    virtual void	setUpdatesEnabled( bool enable );
    void		update();
    void		update( int x, int y, int w, int h );
    void		update( const QRect& );
    void		repaint();
    void		repaint( bool erase );
    void		repaint( int x, int y, int w, int h, bool erase=TRUE );
    void		repaint( const QRect &, bool erase=TRUE );
    void		repaint( const QRegion &, bool erase=TRUE );

     

    virtual void	show();
    virtual void	hide();

    void		iconify()	{ showMinimized(); }

    virtual void	showMinimized();
    virtual void	showMaximized();
    void		showFullScreen();  
    virtual void	showNormal();
    virtual void	polish();
    void 		constPolish() const;
    bool		close();

    void		raise();
    void		lower();
    void		stackUnder( QWidget* );
    virtual void	move( int x, int y );
    void		move( const QPoint & );
    virtual void	resize( int w, int h );
    void		resize( const QSize & );
    virtual void	setGeometry( int x, int y, int w, int h );
    virtual void	setGeometry( const QRect & );

public:
    virtual bool	close( bool alsoDelete );
    bool		isVisible()	const;
    bool		isVisibleTo(QWidget*) const;
    bool		isVisibleToTLW() const;  
    QRect		visibleRect() const;
    bool 		isHidden() const;
    bool		isMinimized() const;
    bool		isMaximized() const;

    virtual QSize	sizeHint() const;
    virtual QSize	minimumSizeHint() const;
    virtual QSizePolicy	sizePolicy() const;
    void 		setSizePolicy( QSizePolicy );
    virtual int heightForWidth(int) const;

    virtual void  	adjustSize();

    QLayout *		layout() const { return lay_out; }

    void		updateGeometry();
    virtual void 	reparent( QWidget *parent, WFlags, const QPoint &,
				  bool showIt=FALSE );
    void		reparent( QWidget *parent, const QPoint &,
				  bool showIt=FALSE );

    void		recreate( QWidget *parent, WFlags f, const QPoint & p,
				  bool showIt=FALSE )
    { reparent(parent,f,p,showIt); }


    void		erase();
    void		erase( int x, int y, int w, int h );
    void		erase( const QRect & );
    void		erase( const QRegion & );
    void		scroll( int dx, int dy );
    void		scroll( int dx, int dy, const QRect& );

    void		drawText( int x, int y, const QString &);
    void		drawText( const QPoint &, const QString &);

     

    QWidget *		focusWidget() const;
    QRect               microFocusHint() const;

     

    bool		acceptDrops() const;
    virtual void	setAcceptDrops( bool on );

     

    virtual void	setAutoMask(bool);
    bool		autoMask() const;

    enum BackgroundOrigin { WidgetOrigin, ParentOrigin };

    void setBackgroundOrigin( BackgroundOrigin );
    BackgroundOrigin backgroundOrigin() const;


     
    virtual bool customWhatsThis() const;

    QWidget *		parentWidget() const;
    bool		testWState( uint n ) const;
    bool		testWFlags( WFlags f ) const;
    static QWidget *	find( WId );
    static QWidgetMapper *wmapper();





protected:
     
    bool	 event( QEvent * );
    virtual void mousePressEvent( QMouseEvent * );
    virtual void mouseReleaseEvent( QMouseEvent * );
    virtual void mouseDoubleClickEvent( QMouseEvent * );
    virtual void mouseMoveEvent( QMouseEvent * );
    virtual void wheelEvent( QWheelEvent * );
    virtual void keyPressEvent( QKeyEvent * );
    virtual void keyReleaseEvent( QKeyEvent * );
    virtual void focusInEvent( QFocusEvent * );
    virtual void focusOutEvent( QFocusEvent * );
    virtual void enterEvent( QEvent * );
    virtual void leaveEvent( QEvent * );
    virtual void paintEvent( QPaintEvent * );
    virtual void moveEvent( QMoveEvent * );
    virtual void resizeEvent( QResizeEvent * );
    virtual void closeEvent( QCloseEvent * );








    virtual void showEvent( QShowEvent * );
    virtual void hideEvent( QHideEvent * );
    virtual void customEvent( QCustomEvent * );

# 463 "/opt/Qtopia/include/qwidget.h"

    virtual bool x11Event( XEvent * );		 






    virtual void updateMask();

     

protected:

    virtual void styleChange( QStyle& );

    virtual void enabledChange( bool );
    virtual void backgroundColorChange( const QColor & );
    virtual void backgroundPixmapChange( const QPixmap & );

    virtual void paletteChange( const QPalette & );

    virtual void fontChange( const QFont & );

    int		 metric( int )	const;

    virtual void create( WId = 0, bool initializeWindow = TRUE,
			 bool destroyOldWindow = TRUE );
    virtual void destroy( bool destroyWindow = TRUE,
			  bool destroySubWindows = TRUE );
    uint	 getWState() const;
    virtual void setWState( uint );
    void	 clearWState( uint n );
    WFlags	 getWFlags() const;
    virtual void setWFlags( WFlags );
    void	 clearWFlags( WFlags n );

    virtual void setFRect( const QRect & );
    virtual void setCRect( const QRect & );

    virtual bool focusNextPrevChild( bool next );

    QWExtra	*extraData();
    QTLWExtra	*topData();
    QFocusData	*focusData();

    virtual void setKeyCompression(bool);
    virtual void setMicroFocusHint(int x, int y, int w, int h, bool text=TRUE);

private  :
    void	 focusProxyDestroyed();

private:
    void	 setFontSys();

    void 	 setLayout( QLayout *l );

    void	 setWinId( WId );
    void	 showWindow();
    void	 hideWindow();
    void	 sendShowEventsToChildren( bool spontaneous );
    void	 sendHideEventsToChildren( bool spontaneous );
    void	 createTLExtra();
    void	 createExtra();
    void	 deleteExtra();
    void	 createSysExtra();
    void	 deleteSysExtra();
    void	 createTLSysExtra();
    void	 deleteTLSysExtra();
    void	 deactivateWidgetCleanup();
    void	 internalSetGeometry( int, int, int, int, bool );
    void	 reparentFocusWidgets( QWidget * );
    QFocusData	*focusData( bool create );
    void         setBackgroundFromMode();
    void         setBackgroundColorDirect( const QColor & );
    void   	 setBackgroundPixmapDirect( const QPixmap & );
    void         setBackgroundModeDirect( BackgroundMode );
    void         setBackgroundEmpty();

    void         setBackgroundX11Relative();
    void	 checkChildrenDnd();


    WId		 winid;
    uint	 widget_state;
    uint	 widget_flags;
    uint	 propagate_font : 2;  
    uint	 propagate_palette : 2;  
    uint	 focus_policy : 4;
    uint 	 own_font :1;
    uint 	 own_palette :1;
    uint 	 sizehint_forced :1;
    uint 	 is_closing :1;
    uint 	 in_show : 1;
    uint 	 in_show_maximized : 1;
    QPoint	 fpos;
    QRect	 crect;
    QColor	 bg_col;

    QPalette	 pal;

    QFont	 fnt;

    QLayout 	*lay_out;

    QWExtra	*extra;
# 593 "/opt/Qtopia/include/qwidget.h"


    static void	 createMapper();
    static void	 destroyMapper();
    static QWidgetList	 *wList();
    static QWidgetList	 *tlwList();
    static QWidgetMapper *mapper;
    friend class QApplication;
    friend class QBaseApplication;
    friend class QPainter;
    friend class QFontMetrics;
    friend class QFontInfo;
    friend class QETWidget;

    friend class QLayout;



private:	 

    QWidget( const QWidget & );
    QWidget &operator=( const QWidget & );


public:  

    void setPalette( const QPalette &, bool iReallyMeanIt );

    void setFont( const QFont &, bool iReallyMeanIt );
};


inline bool QWidget::testWState( uint f ) const
{ return (widget_state & f) != 0; }

inline bool QWidget::testWFlags( WFlags f ) const
{ return (widget_flags & f) != 0; }


inline WId QWidget::winId() const
{ return winid; }

inline bool QWidget::isTopLevel() const
{ return testWFlags(WType_TopLevel); }

inline bool QWidget::isModal() const
{ return testWFlags(WType_Modal); }

inline bool QWidget::isPopup() const
{ return testWFlags(WType_Popup); }

inline bool QWidget::isDesktop() const
{ return testWFlags(WType_Desktop); }

inline bool QWidget::isEnabled() const
{ return !testWState(WState_Disabled); }

inline const QRect &QWidget::geometry() const
{ return crect; }

inline int QWidget::x() const
{ return fpos.x(); }

inline int QWidget::y() const
{ return fpos.y(); }

inline QPoint QWidget::pos() const
{ return fpos; }

inline QSize QWidget::size() const
{ return crect.size(); }

inline int QWidget::width() const
{ return crect.width(); }

inline int QWidget::height() const
{ return crect.height(); }

inline QRect QWidget::rect() const
{ return QRect(0,0,crect.width(),crect.height()); }

inline int QWidget::minimumWidth() const
{ return minimumSize().width(); }

inline int QWidget::minimumHeight() const
{ return minimumSize().height(); }

inline int QWidget::maximumWidth() const
{ return maximumSize().width(); }

inline int QWidget::maximumHeight() const
{ return maximumSize().height(); }

inline void QWidget::setMinimumSize( const QSize &s )
{ setMinimumSize(s.width(),s.height()); }

inline void QWidget::setMaximumSize( const QSize &s )
{ setMaximumSize(s.width(),s.height()); }

inline void QWidget::setSizeIncrement( const QSize &s )
{ setSizeIncrement(s.width(),s.height()); }

inline void QWidget::setBaseSize( const QSize &s )
{ setBaseSize(s.width(),s.height()); }

inline const QColor &QWidget::backgroundColor() const
{ return bg_col; }


inline const QPalette &QWidget::palette() const
{ return pal; }


inline QFont QWidget::font() const
{ return fnt; }

inline QFontMetrics QWidget::fontMetrics() const
{ return QFontMetrics(font()); }

inline QFontInfo QWidget::fontInfo() const
{ return QFontInfo(font()); }

inline bool QWidget::hasMouseTracking() const
{ return testWState(WState_MouseTracking); }

inline bool  QWidget::isFocusEnabled() const
{ return (FocusPolicy)focus_policy != NoFocus; }

inline QWidget::FocusPolicy QWidget::focusPolicy() const
{ return (FocusPolicy)focus_policy; }

inline bool QWidget::isUpdatesEnabled() const
{ return !testWState(WState_BlockUpdates); }

inline void QWidget::update( const QRect &r )
{ update( r.x(), r.y(), r.width(), r.height() ); }

inline void QWidget::repaint()
{ repaint( 0, 0, crect.width(), crect.height(), TRUE ); }

inline void QWidget::repaint( bool erase )
{ repaint( 0, 0, crect.width(), crect.height(), erase ); }

inline void QWidget::repaint( const QRect &r, bool erase )
{ repaint( r.x(), r.y(), r.width(), r.height(), erase ); }

inline void QWidget::erase()
{ erase( 0, 0, crect.width(), crect.height() ); }

inline void QWidget::erase( const QRect &r )
{ erase( r.x(), r.y(), r.width(), r.height() ); }

inline bool QWidget::close()
{ return close( FALSE ); }

inline bool QWidget::isVisible() const
{ return testWState(WState_Visible); }

inline bool QWidget::isHidden() const
{ return testWState(WState_ForceHide); }

inline void QWidget::move( const QPoint &p )
{ move( p.x(), p.y() ); }

inline void QWidget::resize( const QSize &s )
{ resize( s.width(), s.height()); }

inline void QWidget::setGeometry( const QRect &r )
{ setGeometry( r.left(), r.top(), r.width(), r.height() ); }

inline void QWidget::drawText( const QPoint &p, const QString &s )
{ drawText( p.x(), p.y(), s ); }

inline QWidget *QWidget::parentWidget() const
{ return (QWidget *)QObject::parent(); }

inline QWidgetMapper *QWidget::wmapper()
{ return mapper; }

inline uint QWidget::getWState() const
{ return widget_state; }

inline void QWidget::setWState( uint f )
{ widget_state |= f; }

inline void QWidget::clearWState( uint f )
{ widget_state &= ~f; }

inline Qt::WFlags QWidget::getWFlags() const
{ return widget_flags; }

inline void QWidget::setWFlags( WFlags f )
{ widget_flags |= f; }

inline void QWidget::clearWFlags( WFlags f )
{ widget_flags &= ~f; }

inline void QWidget::constPolish() const
{
    if ( !testWState(WState_Polished) ) {
	QWidget* that = (QWidget*) this;
	that->polish();
        that->setWState(WState_Polished);  
    }
}

inline bool QWidget::ownCursor() const
{
    return testWState( WState_OwnCursor );
}

inline bool QWidget::ownFont() const
{
    return own_font;
}

inline bool QWidget::ownPalette() const
{
    return own_palette;
}


 
 
 

class QFocusData;
class QWSManager;




struct QTLWExtra {
    QString  caption;				 
    QString  iconText;				 
    QPixmap *icon;				 
    QFocusData *focusData;			 
    QSize    fsize;				 
    short    incw, inch;			 
    uint     iconic: 1;				 
    uint     fullscreen : 1;			 
    uint     showMode: 2;			 
    short    basew, baseh;			 

    WId	     parentWinId;			 
    uint     embedded : 1;			 
    uint     reserved: 2;			 
    uint     dnd : 1; 				 
    uint     uspos : 1;                          
    uint     ussize : 1;                         
    void    *xic;				 








    QRect    normalGeometry;			 
};




 

struct QWExtra {
    Q_INT16  minw, minh;			 
    Q_INT16  maxw, maxh;			 
    QPixmap *bg_pix;				 
    QWidget *focus_proxy;

    QCursor *curs;

    QTLWExtra *topextra;			 




    WId	     xDndProxy;				 




    char     bg_mode;				 

    QStyle* style;

    QRect micro_focus_hint;                      
    QSizePolicy size_policy;
    void * posted_events;			 

    uint children_use_dnd : 1;			 

};



# 13 "todaybase.h" 2

class QVBoxLayout; 
class QHBoxLayout; 
class QGridLayout; 
class QFrame;
class QLabel;

class TodayBase : public QWidget
{ 
    public:	QMetaObject *metaObject() const { return staticMetaObject();	}	const char *className() const;	static QMetaObject* staticMetaObject();	static QString tr(const char*); static QString tr(const char*, const char*); 	protected:	void initMetaObject();	private:	static QMetaObject *metaObj; 

public:
    TodayBase( QWidget* parent = 0, const char* name = 0, WFlags fl = 0 );
    ~TodayBase();

    QFrame* Frame;
    QLabel* TextLabel1;
    QFrame* Line2;
    QLabel* PixmapLabel1;
    QLabel* PixmapLabel7;
    QLabel* DatesField;
    QLabel* TodoField;

protected:
    bool event( QEvent* );
};


# 4 "today.h" 2


# 1 "/opt/Qtopia/include/qpe/datebookdb.h" 1
 























# 1 "/opt/Qtopia/include/qdatetime.h" 1
 












































 



class   QDate
{
public:
    QDate()  { jd=0; }				 
    QDate( int y, int m, int d );		 

    bool   isNull()	 const { return jd == 0; }
    bool   isValid()	 const;			 

    int	   year()	 const;			 
    int	   month()	 const;			 
    int	   day()	 const;			 
    int	   dayOfWeek()	 const;			 
    int	   dayOfYear()	 const;			 
    int	   daysInMonth() const;			 
    int	   daysInYear()	 const;			 

    virtual QString monthName( int month ) const;
    virtual QString dayName( int weekday ) const;

    QString toString()	 const;

    bool   setYMD( int y, int m, int d );

    QDate  addDays( int days )		const;
    int	   daysTo( const QDate & )	const;

    bool   operator==( const QDate &d ) const { return jd == d.jd; }
    bool   operator!=( const QDate &d ) const { return jd != d.jd; }
    bool   operator<( const QDate &d )	const { return jd < d.jd; }
    bool   operator<=( const QDate &d ) const { return jd <= d.jd; }
    bool   operator>( const QDate &d )	const { return jd > d.jd; }
    bool   operator>=( const QDate &d ) const { return jd >= d.jd; }

    static QDate currentDate();
    static bool	 isValid( int y, int m, int d );
    static bool	 leapYear( int year );

protected:
    static uint	 greg2jul( int y, int m, int d );
    static void	 jul2greg( uint jd, int &y, int &m, int &d );
private:
    static const char * const monthNames[];
    static const char * const weekdayNames[];
    uint	 jd;
    friend class QDateTime;

    friend   QDataStream &operator<<( QDataStream &, const QDate & );
    friend   QDataStream &operator>>( QDataStream &, QDate & );

};


 



class   QTime
{
public:
    QTime() { ds=0; }				 
    QTime( int h, int m, int s=0, int ms=0 );	 

    bool   isNull()	 const { return ds == 0; }
    bool   isValid()	 const;			 

    int	   hour()	 const;			 
    int	   minute()	 const;			 
    int	   second()	 const;			 
    int	   msec()	 const;			 

    QString toString()	 const;

    bool   setHMS( int h, int m, int s, int ms=0 );

    QTime  addSecs( int secs )		const;
    int	   secsTo( const QTime & )	const;
    QTime  addMSecs( int ms )		const;
    int	   msecsTo( const QTime & )	const;

    bool   operator==( const QTime &d ) const { return ds == d.ds; }
    bool   operator!=( const QTime &d ) const { return ds != d.ds; }
    bool   operator<( const QTime &d )	const { return ds < d.ds; }
    bool   operator<=( const QTime &d ) const { return ds <= d.ds; }
    bool   operator>( const QTime &d )	const { return ds > d.ds; }
    bool   operator>=( const QTime &d ) const { return ds >= d.ds; }

    static QTime currentTime();
    static bool	 isValid( int h, int m, int s, int ms=0 );

    void   start();
    int	   restart();
    int	   elapsed();

private:
    static bool currentTime( QTime * );

    uint   ds;
    friend class QDateTime;

    friend   QDataStream &operator<<( QDataStream &, const QTime & );
    friend   QDataStream &operator>>( QDataStream &, QTime & );

};


 



class   QDateTime
{
public:
    QDateTime() {}				 
    QDateTime( const QDate & );
    QDateTime( const QDate &, const QTime & );

    bool   isNull()	const		{ return d.isNull() && t.isNull(); }
    bool   isValid()	const		{ return d.isValid() && t.isValid(); }

    QDate  date()	const		{ return d; }
    QTime  time()	const		{ return t; }
    void   setDate( const QDate &date ) { d=date; }
    void   setTime( const QTime &time ) { t=time; }
    void   setTime_t( uint secsSince1Jan1970UTC );

    QString toString()	const;

    QDateTime addDays( int days )	const;
    QDateTime addSecs( int secs )	const;
    int	   daysTo( const QDateTime & )	const;
    int	   secsTo( const QDateTime & )	const;

    bool   operator==( const QDateTime &dt ) const;
    bool   operator!=( const QDateTime &dt ) const;
    bool   operator<( const QDateTime &dt )  const;
    bool   operator<=( const QDateTime &dt ) const;
    bool   operator>( const QDateTime &dt )  const;
    bool   operator>=( const QDateTime &dt ) const;

    static QDateTime currentDateTime();

private:
    QDate  d;
    QTime  t;

    friend   QDataStream &operator<<( QDataStream &, const QDateTime &);
    friend   QDataStream &operator>>( QDataStream &, QDateTime & );

};


 




  QDataStream &operator<<( QDataStream &, const QDate & );
  QDataStream &operator>>( QDataStream &, QDate & );
  QDataStream &operator<<( QDataStream &, const QTime & );
  QDataStream &operator>>( QDataStream &, QTime & );
  QDataStream &operator<<( QDataStream &, const QDateTime & );
  QDataStream &operator>>( QDataStream &, QDateTime & );



# 25 "/opt/Qtopia/include/qpe/datebookdb.h" 2

# 1 "/opt/Qtopia/include/qfile.h" 1
 










































# 1 "/usr/include/stdio.h" 1 3
 


















 









extern "C" { 



# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 1 3






 


# 19 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3



 


 





 


# 61 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 





 


















 





 

 

# 131 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 


# 188 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3





 




 

# 271 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


# 283 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 

# 317 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3




 





















# 34 "/usr/include/stdio.h" 2 3


# 1 "/usr/include/bits/types.h" 1 3
 

















 









# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 1 3






 


# 19 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3



 


 





 


# 61 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 





 


















 





 

 

# 131 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 


# 188 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3





 




 

# 271 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


# 283 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 

# 317 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3




 





















# 29 "/usr/include/bits/types.h" 2 3


 
typedef unsigned char __u_char;
typedef unsigned short __u_short;
typedef unsigned int __u_int;
typedef unsigned long __u_long;

__extension__ typedef unsigned long long int __u_quad_t;
__extension__ typedef long long int __quad_t;
# 48 "/usr/include/bits/types.h" 3

typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;

typedef __quad_t *__qaddr_t;

typedef __u_quad_t __dev_t;		 
typedef __u_int __uid_t;		 
typedef __u_int __gid_t;		 
typedef __u_long __ino_t;		 
typedef __u_int __mode_t;		 
typedef __u_int __nlink_t; 		 
typedef long int __off_t;		 
typedef __quad_t __loff_t;		 
typedef int __pid_t;			 
typedef int __ssize_t;			 
typedef __u_long __rlim_t;		 
typedef __u_quad_t __rlim64_t;		 
typedef __u_int __id_t;			 

typedef struct
  {
    int __val[2];
  } __fsid_t;				 

 
typedef int __daddr_t;			 
typedef char *__caddr_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __swblk_t;		 

typedef long int __clock_t;

 
typedef int __clockid_t;

 
typedef int __timer_t;


 



typedef int __key_t;

 
typedef unsigned short int __ipc_pid_t;


 
typedef long int __blksize_t;

 

 
typedef long int __blkcnt_t;
typedef __quad_t __blkcnt64_t;

 
typedef __u_long __fsblkcnt_t;
typedef __u_quad_t __fsblkcnt64_t;

 
typedef __u_long __fsfilcnt_t;
typedef __u_quad_t __fsfilcnt64_t;

 
typedef __u_quad_t __ino64_t;

 
typedef __loff_t __off64_t;

 
typedef long int __t_scalar_t;
typedef unsigned long int __t_uscalar_t;

 
typedef int __intptr_t;

 
typedef unsigned int __socklen_t;


 

# 1 "/usr/include/bits/pthreadtypes.h" 1 3
 
 
 
 
 
 
 
 
 
 
 
 
 









# 1 "/usr/include/bits/sched.h" 1 3
 



















# 62 "/usr/include/bits/sched.h" 3





 
struct __sched_param
  {
    int __sched_priority;
  };


# 23 "/usr/include/bits/pthreadtypes.h" 2 3


typedef int __atomic_lock_t;

 
struct _pthread_fastlock
{
  long int __status;    
  __atomic_lock_t __spinlock;   

};


 
typedef struct _pthread_descr_struct *_pthread_descr;




 
typedef struct __pthread_attr_s
{
  int __detachstate;
  int __schedpolicy;
  struct __sched_param __schedparam;
  int __inheritsched;
  int __scope;
  size_t __guardsize;
  int __stackaddr_set;
  void *__stackaddr;
  size_t __stacksize;
} pthread_attr_t;


 
typedef struct
{
  struct _pthread_fastlock __c_lock;  
  _pthread_descr __c_waiting;         
} pthread_cond_t;


 
typedef struct
{
  int __dummy;
} pthread_condattr_t;

 
typedef unsigned int pthread_key_t;


 
 

typedef struct
{
  int __m_reserved;                
  int __m_count;                   
  _pthread_descr __m_owner;        
  int __m_kind;                    
  struct _pthread_fastlock __m_lock;  
} pthread_mutex_t;


 
typedef struct
{
  int __mutexkind;
} pthread_mutexattr_t;


 
typedef int pthread_once_t;


# 119 "/usr/include/bits/pthreadtypes.h" 3


# 138 "/usr/include/bits/pthreadtypes.h" 3



 
typedef unsigned long int pthread_t;


# 143 "/usr/include/bits/types.h" 2 3




# 36 "/usr/include/stdio.h" 2 3








 
typedef struct _IO_FILE FILE;








 
typedef struct _IO_FILE __FILE;









# 1 "/usr/include/libio.h" 1 3
 






























# 1 "/usr/include/_G_config.h" 1 3
 





 






# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 1 3






 


# 19 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3



 


 





 


# 61 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 





 


















 





 

 

# 131 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 


# 188 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3





 




 





























 



















































typedef unsigned int  wint_t;




 

 

# 317 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3




 





















# 14 "/usr/include/_G_config.h" 2 3










# 1 "/usr/include/wchar.h" 1 3
 

















 











# 46 "/usr/include/wchar.h" 3


# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 1 3






 


# 19 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3



 


 





 


# 61 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 





 


















 





 

 

# 131 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 

# 190 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3



 




 

# 271 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3














 

 

# 317 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3




 





















# 48 "/usr/include/wchar.h" 2 3


# 1 "/usr/include/bits/wchar.h" 1 3
 

























# 50 "/usr/include/wchar.h" 2 3


 













 
typedef struct
{
  int __count;
  union
  {
    wint_t __wch;
    char __wchb[4];
  } __value;		 
} __mbstate_t;




 

# 682 "/usr/include/wchar.h" 3



# 24 "/usr/include/_G_config.h" 2 3


typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;








# 1 "/usr/include/gconv.h" 1 3
 

















 








# 1 "/usr/include/wchar.h" 1 3
 

















 











# 46 "/usr/include/wchar.h" 3


# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 1 3






 


# 19 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3



 


 





 


# 61 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 





 


















 





 

 

# 131 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 

# 190 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3



 




 

# 271 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3














 

 

# 317 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3




 





















# 48 "/usr/include/wchar.h" 2 3




 











# 76 "/usr/include/wchar.h" 3




 

# 682 "/usr/include/wchar.h" 3



# 28 "/usr/include/gconv.h" 2 3



# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 1 3






 


# 19 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3



 


 





 


# 61 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 





 


















 





 

 

# 131 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 


# 188 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3





 




 


# 269 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3




# 283 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 

# 317 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3




 





















# 31 "/usr/include/gconv.h" 2 3


 


 
enum
{
  __GCONV_OK = 0,
  __GCONV_NOCONV,
  __GCONV_NODB,
  __GCONV_NOMEM,

  __GCONV_EMPTY_INPUT,
  __GCONV_FULL_OUTPUT,
  __GCONV_ILLEGAL_INPUT,
  __GCONV_INCOMPLETE_INPUT,

  __GCONV_ILLEGAL_DESCRIPTOR,
  __GCONV_INTERNAL_ERROR
};


 
enum
{
  __GCONV_IS_LAST = 0x0001,
  __GCONV_IGNORE_ERRORS = 0x0002
};


 
struct __gconv_step;
struct __gconv_step_data;
struct __gconv_loaded_object;
struct __gconv_trans_data;


 
typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,
			    __const unsigned char **, __const unsigned char *,
			    unsigned char **, size_t *, int, int);

 
typedef int (*__gconv_init_fct) (struct __gconv_step *);
typedef void (*__gconv_end_fct) (struct __gconv_step *);


 
typedef int (*__gconv_trans_fct) (struct __gconv_step *,
				  struct __gconv_step_data *, void *,
				  __const unsigned char *,
				  __const unsigned char **,
				  __const unsigned char *, unsigned char **,
				  size_t *);

 
typedef int (*__gconv_trans_context_fct) (void *, __const unsigned char *,
					  __const unsigned char *,
					  unsigned char *, unsigned char *);

 
typedef int (*__gconv_trans_query_fct) (__const char *, __const char ***,
					size_t *);

 
typedef int (*__gconv_trans_init_fct) (void **, const char *);
typedef void (*__gconv_trans_end_fct) (void *);

struct __gconv_trans_data
{
   
  __gconv_trans_fct __trans_fct;
  __gconv_trans_context_fct __trans_context_fct;
  __gconv_trans_end_fct __trans_end_fct;
  void *__data;
  struct __gconv_trans_data *__next;
};


 
struct __gconv_step
{
  struct __gconv_loaded_object *__shlib_handle;
  __const char *__modname;

  int __counter;

  char *__from_name;
  char *__to_name;

  __gconv_fct __fct;
  __gconv_init_fct __init_fct;
  __gconv_end_fct __end_fct;

   

  int __min_needed_from;
  int __max_needed_from;
  int __min_needed_to;
  int __max_needed_to;

   
  int __stateful;

  void *__data;		 
};

 

struct __gconv_step_data
{
  unsigned char *__outbuf;     
  unsigned char *__outbufend;  


   
  int __flags;

   

  int __invocation_counter;

   

  int __internal_use;

  __mbstate_t *__statep;
  __mbstate_t __state;	 


   
  struct __gconv_trans_data *__trans;
};


 
typedef struct __gconv_info
{
  size_t __nsteps;
  struct __gconv_step *__steps;
  __extension__ struct __gconv_step_data __data [0] ;
} *__gconv_t;


# 44 "/usr/include/_G_config.h" 2 3

typedef union
{
  struct __gconv_info __cd;
  struct
  {
    struct __gconv_info __cd;
    struct __gconv_step_data __data;
  } __combined;
} _G_iconv_t;

typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));
typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));




 


















 




 














# 32 "/usr/include/libio.h" 2 3

 

















 

# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stdarg.h" 1 3
 
































































 






typedef void *__gnuc_va_list;



 

# 122 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stdarg.h" 3




















# 209 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stdarg.h" 3




# 53 "/usr/include/libio.h" 2 3







# 72 "/usr/include/libio.h" 3


 

















# 103 "/usr/include/libio.h" 3











 

























 



















struct _IO_jump_t;  struct _IO_FILE;

 







typedef void _IO_lock_t;



 

struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;
   

   
  int _pos;
# 192 "/usr/include/libio.h" 3

};

 
enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};

# 259 "/usr/include/libio.h" 3


struct _IO_FILE {
  int _flags;		 


   
   
  char* _IO_read_ptr;	 
  char* _IO_read_end;	 
  char* _IO_read_base;	 
  char* _IO_write_base;	 
  char* _IO_write_ptr;	 
  char* _IO_write_end;	 
  char* _IO_buf_base;	 
  char* _IO_buf_end;	 
   
  char *_IO_save_base;  
  char *_IO_backup_base;   
  char *_IO_save_end;  

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _blksize;
  __off_t   _old_offset;  


   
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

   

  _IO_lock_t *_lock;








  __off64_t   _offset;





  void *__pad1;
  void *__pad2;

  int _mode;
   
  char _unused2[15 * sizeof (int) - 2 * sizeof (void *)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;











 

 

typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);

 





typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,
				 size_t __n);

 





typedef int __io_seek_fn (void *__cookie, __off64_t   *__pos, int __w);

 
typedef int __io_close_fn (void *__cookie);


# 389 "/usr/include/libio.h" 3




extern "C" {


extern int __underflow (_IO_FILE *) throw () ;
extern int __uflow (_IO_FILE *) throw () ;
extern int __overflow (_IO_FILE *, int) throw () ;
extern wint_t   __wunderflow (_IO_FILE *) throw () ;
extern wint_t   __wuflow (_IO_FILE *) throw () ;
extern wint_t   __woverflow (_IO_FILE *, wint_t  ) throw () ;
























extern int _IO_getc (_IO_FILE *__fp) throw () ;
extern int _IO_putc (int __c, _IO_FILE *__fp) throw () ;
extern int _IO_feof (_IO_FILE *__fp) throw () ;
extern int _IO_ferror (_IO_FILE *__fp) throw () ;

extern int _IO_peekc_locked (_IO_FILE *__fp) throw () ;

 



extern void _IO_flockfile (_IO_FILE *) throw () ;
extern void _IO_funlockfile (_IO_FILE *) throw () ;
extern int _IO_ftrylockfile (_IO_FILE *) throw () ;
















extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
			__gnuc_va_list , int *__restrict) throw () ;
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
			 __gnuc_va_list ) throw () ;
extern __ssize_t   _IO_padn (_IO_FILE *, int, __ssize_t  ) throw () ;
extern size_t   _IO_sgetn (_IO_FILE *, void *, size_t  ) throw () ;

extern __off64_t   _IO_seekoff (_IO_FILE *, __off64_t  , int, int) throw () ;
extern __off64_t   _IO_seekpos (_IO_FILE *, __off64_t  , int) throw () ;

extern void _IO_free_backup_area (_IO_FILE *) throw () ;

# 511 "/usr/include/libio.h" 3



}



# 65 "/usr/include/stdio.h" 2 3


# 76 "/usr/include/stdio.h" 3


 

typedef _G_fpos_t fpos_t;







 





 





 






 







 




 








# 1 "/usr/include/bits/stdio_lim.h" 1 3
 








































# 129 "/usr/include/stdio.h" 2 3



 
extern FILE *stdin;		 
extern FILE *stdout;		 
extern FILE *stderr;		 
 




 
extern int remove (__const char *__filename) throw () ;
 
extern int rename (__const char *__old, __const char *__new) throw () ;


 

extern FILE *tmpfile (void) throw () ;










 
extern char *tmpnam (char *__s) throw () ;


 

extern char *tmpnam_r (char *__s) throw () ;




 






extern char *tempnam (__const char *__dir, __const char *__pfx)
     throw ()   ;



 
extern int fclose (FILE *__stream) throw () ;
 
extern int fflush (FILE *__stream) throw () ;


 
extern int fflush_unlocked (FILE *__stream) throw () ;









 
extern FILE *fopen (__const char *__restrict __filename,
		    __const char *__restrict __modes) throw () ;
 
extern FILE *freopen (__const char *__restrict __filename,
		      __const char *__restrict __modes,
		      FILE *__restrict __stream) throw () ;
# 220 "/usr/include/stdio.h" 3










 
extern FILE *fdopen (int __fd, __const char *__modes) throw () ;


# 249 "/usr/include/stdio.h" 3



 

extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw () ;
 


extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
		    int __modes, size_t __n) throw () ;


 

extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
		       size_t __size) throw () ;

 
extern void setlinebuf (FILE *__stream) throw () ;



 
extern int fprintf (FILE *__restrict __stream,
		    __const char *__restrict __format, ...) throw () ;
 
extern int printf (__const char *__restrict __format, ...) throw () ;
 
extern int sprintf (char *__restrict __s,
		    __const char *__restrict __format, ...) throw () ;

 
extern int vfprintf (FILE *__restrict __s, __const char *__restrict __format,
		     __gnuc_va_list  __arg) throw () ;
 
extern int vprintf (__const char *__restrict __format, __gnuc_va_list  __arg)
     throw () ;
 
extern int vsprintf (char *__restrict __s, __const char *__restrict __format,
		     __gnuc_va_list  __arg) throw () ;


 
extern int snprintf (char *__restrict __s, size_t __maxlen,
		     __const char *__restrict __format, ...)
     throw ()  __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
		      __const char *__restrict __format, __gnuc_va_list  __arg)
     throw ()  __attribute__ ((__format__ (__printf__, 3, 0)));


# 321 "/usr/include/stdio.h" 3



 
extern int fscanf (FILE *__restrict __stream,
		   __const char *__restrict __format, ...) throw () ;
 
extern int scanf (__const char *__restrict __format, ...) throw () ;
 
extern int sscanf (__const char *__restrict __s,
		   __const char *__restrict __format, ...) throw () ;

# 347 "/usr/include/stdio.h" 3



 
extern int fgetc (FILE *__stream) throw () ;
extern int getc (FILE *__stream) throw () ;

 
extern int getchar (void) throw () ;

 




 
extern int getc_unlocked (FILE *__stream) throw () ;
extern int getchar_unlocked (void) throw () ;



 
extern int fgetc_unlocked (FILE *__stream) throw () ;



 
extern int fputc (int __c, FILE *__stream) throw () ;
extern int putc (int __c, FILE *__stream) throw () ;

 
extern int putchar (int __c) throw () ;

 




 
extern int fputc_unlocked (int __c, FILE *__stream) throw () ;



 
extern int putc_unlocked (int __c, FILE *__stream) throw () ;
extern int putchar_unlocked (int __c) throw () ;




 
extern int getw (FILE *__stream) throw () ;

 
extern int putw (int __w, FILE *__stream) throw () ;



 
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     throw () ;







 

extern char *gets (char *__s) throw () ;


# 437 "/usr/include/stdio.h" 3



 
extern int fputs (__const char *__restrict __s, FILE *__restrict __stream)
     throw () ;







 
extern int puts (__const char *__s) throw () ;


 
extern int ungetc (int __c, FILE *__stream) throw () ;


 
extern size_t fread (void *__restrict __ptr, size_t __size,
		     size_t __n, FILE *__restrict __stream) throw () ;
 
extern size_t fwrite (__const void *__restrict __ptr, size_t __size,
		      size_t __n, FILE *__restrict __s) throw () ;


 
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
			      size_t __n, FILE *__restrict __stream) throw () ;
extern size_t fwrite_unlocked (__const void *__restrict __ptr, size_t __size,
			       size_t __n, FILE *__restrict __stream) throw () ;



 
extern int fseek (FILE *__stream, long int __off, int __whence) throw () ;
 
extern long int ftell (FILE *__stream) throw () ;
 
extern void rewind (FILE *__stream) throw () ;

 












 
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos)
     throw () ;
 
extern int fsetpos (FILE *__stream, __const fpos_t *__pos) throw () ;
# 520 "/usr/include/stdio.h" 3










 
extern void clearerr (FILE *__stream) throw () ;
 
extern int feof (FILE *__stream) throw () ;
 
extern int ferror (FILE *__stream) throw () ;


 
extern void clearerr_unlocked (FILE *__stream) throw () ;
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;



 
extern void perror (__const char *__s) throw () ;

 


extern int sys_nerr;
extern __const char *__const sys_errlist[];








 
extern int fileno (FILE *__stream) throw () ;



 
extern int fileno_unlocked (FILE *__stream) throw () ;





 
extern FILE *popen (__const char *__command, __const char *__modes) throw () ;

 
extern int pclose (FILE *__stream) throw () ;




 
extern char *ctermid (char *__s) throw () ;









# 602 "/usr/include/stdio.h" 3




 

 
extern void flockfile (FILE *__stream) throw () ;

 

extern int ftrylockfile (FILE *__stream) throw () ;

 
extern void funlockfile (FILE *__stream) throw () ;










 





} 




# 44 "/opt/Qtopia/include/qfile.h" 2



class QDir;


class   QFile : public QIODevice			 
{
public:
    QFile();
    QFile( const QString &name );
   ~QFile();

    QString	name()	const;
    void	setName( const QString &name );

    typedef QCString (*EncoderFn)( const QString &fileName );
    typedef QString (*DecoderFn)( const QCString &localfileName );
    static QCString encodeName( const QString &fileName );
    static QString decodeName( const QCString &localFileName );
    static void setEncodingFunction( EncoderFn );
    static void setDecodingFunction( DecoderFn );

    bool	exists()   const;
    static bool exists( const QString &fileName );

    bool	remove();
    static bool remove( const QString &fileName );

    bool	open( int );
    bool	open( int, FILE * );
    bool	open( int, int );
    void	close();
    void	flush();

    uint	size()	const;
    int		at()	const;
    bool	at( int );
    bool	atEnd() const;

    int		readBlock( char *data, uint len );
    int		writeBlock( const char *data, uint len );
    int		writeBlock( const QByteArray& data )
		    { return QIODevice::writeBlock(data); }
    int		readLine( char *data, uint maxlen );
    int		readLine( QString &, uint maxlen );

    int		getch();
    int		putch( int );
    int		ungetch( int );

    int		handle() const;

protected:
    QString	fn;
    FILE       *fh;
    int		fd;
    int		length;
    bool	ext_f;
    void * 	d;

private:
    void	init();
    QCString ungetchBuffer;

private:	 

    QFile( const QFile & );
    QFile &operator=( const QFile & );

};


inline QString QFile::name() const
{ return fn; }

inline int QFile::at() const
{ return ioIndex; }



# 26 "/opt/Qtopia/include/qpe/datebookdb.h" 2


# 1 "/opt/Qtopia/include/qpe/event.h" 1
 





























# 1 "/opt/Qtopia/include/qpe/palmtoprecord.h" 1
 
























# 1 "/opt/Qtopia/include/qpe/qpcglobal.h" 1
 























# 42 "/opt/Qtopia/include/qpe/qpcglobal.h"









# 26 "/opt/Qtopia/include/qpe/palmtoprecord.h" 2

# 1 "/opt/Qtopia/include/qpe/palmtopuidgen.h" 1
 




















 




















# 1 "/usr/include/time.h" 1 3
 

















 










extern "C" { 




 


# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 1 3






 


# 19 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3



 


 





 


# 61 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 





 


















 





 

 

# 131 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 


# 188 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3





 




 

# 271 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


# 283 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 

# 317 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3




 





















# 38 "/usr/include/time.h" 2 3


 

# 1 "/usr/include/bits/time.h" 1 3
 


















 







 


 





 


extern long int __sysconf (int);




 

 

 


 






# 73 "/usr/include/bits/time.h" 3

# 42 "/usr/include/time.h" 2 3


 













 
typedef __clock_t clock_t;









 
typedef __time_t time_t;










 
typedef __clockid_t clockid_t;










 
typedef __timer_t timer_t;









 

struct timespec
  {
    __time_t tv_sec;		 
    long int tv_nsec;		 
  };






 
struct tm
{
  int tm_sec;			 
  int tm_min;			 
  int tm_hour;			 
  int tm_mday;			 
  int tm_mon;			 
  int tm_year;			 
  int tm_wday;			 
  int tm_yday;			 
  int tm_isdst;			 


  long int tm_gmtoff;		 
  __const char *tm_zone;	 




};



 
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };

 
struct sigevent;











 

extern clock_t clock (void) throw () ;

 
extern time_t time (time_t *__timer) throw () ;

 
extern double difftime (time_t __time1, time_t __time0)
     throw ()  __attribute__ ((__const__));

 
extern time_t mktime (struct tm *__tp) throw () ;


 


extern size_t strftime (char *__restrict __s, size_t __maxsize,
			__const char *__restrict __format,
			__const struct tm *__restrict __tp) throw () ;










 

extern struct tm *gmtime (__const time_t *__timer) throw () ;

 

extern struct tm *localtime (__const time_t *__timer) throw () ;


 

extern struct tm *gmtime_r (__const time_t *__restrict __timer,
			    struct tm *__restrict __tp) throw () ;

 

extern struct tm *localtime_r (__const time_t *__restrict __timer,
			       struct tm *__restrict __tp) throw () ;


 

extern char *asctime (__const struct tm *__tp) throw () ;

 
extern char *ctime (__const time_t *__timer) throw () ;


 

 

extern char *asctime_r (__const struct tm *__restrict __tp,
			char *__restrict __buf) throw () ;

 
extern char *ctime_r (__const time_t *__restrict __timer,
		      char *__restrict __buf) throw () ;



 
extern char *__tzname[2];	 
extern int __daylight;		 
extern long int __timezone;	 



 
extern char *tzname[2];

 

extern void tzset (void) throw () ;



extern int daylight;
extern long int timezone;



 

extern int stime (__const time_t *__when) throw () ;



 






 


 
extern time_t timegm (struct tm *__tp) throw () ;

 
extern time_t timelocal (struct tm *__tp) throw () ;

 
extern int dysize (int __year) throw ()   __attribute__ ((__const__));




 
extern int nanosleep (__const struct timespec *__requested_time,
		      struct timespec *__remaining) throw () ;


 
extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw () ;

 
extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw () ;

 
extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp)
     throw () ;

# 305 "/usr/include/time.h" 3



 
extern int timer_create (clockid_t __clock_id,
			 struct sigevent *__restrict __evp,
			 timer_t *__restrict __timerid) throw () ;

 
extern int timer_delete (timer_t __timerid) throw () ;

 
extern int timer_settime (timer_t __timerid, int __flags,
			  __const struct itimerspec *__restrict __value,
			  struct itimerspec *__restrict __ovalue) throw () ;

 
extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw () ;

 
extern int timer_getoverrun (timer_t __timerid) throw () ;



# 349 "/usr/include/time.h" 3


# 359 "/usr/include/time.h" 3



} 




# 43 "/opt/Qtopia/include/qpe/palmtopuidgen.h" 2


# 1 "/opt/Qtopia/include/qpe/qpcglobal.h" 1
 




















# 46 "/opt/Qtopia/include/qpe/qpcglobal.h"





# 45 "/opt/Qtopia/include/qpe/palmtopuidgen.h" 2








namespace Qtopia {


class   UidGen
{
public:
    enum Type { Qtopia, PalmtopCenter };

    UidGen() : type( Qtopia ), sign( -1 ), ids()
{




}
    UidGen( Type t ) : type(t), sign(1), ids()
{
    if ( t == Qtopia )
	sign = -1;
}

    virtual ~UidGen() { }

    int generate() const
{
    int id = sign * (int) ::time(__null );
    while ( ids.contains( id ) ) {
	id += sign;
	
	 
	 
	if ( sign == -1 && id > 0 || sign == 1 && id < 0 )
	    id = sign;
    }
    return id;
}

    void store(int id) { ids.insert(id, TRUE); }
    bool isUnique(int id) const { return (!ids.contains(id)); }

private:
    Type type;
    int sign;
    QMap<int, bool> ids;

};

}


# 27 "/opt/Qtopia/include/qpe/palmtoprecord.h" 2










class QRegExp;
namespace Qtopia {

class RecordPrivate;
class   Record
{
public:
    Record() : mUid(0), mCats() { }
    Record( const Record &c ) :	mUid( c.mUid ), mCats ( c.mCats ), customMap(c.customMap) { }
    virtual ~Record() { }

    Record &operator=( const Record &c );

    virtual bool match( const QRegExp & ) const { return FALSE; }

    void setCategories( const QArray<int> &v ) { mCats = v; }
    void setCategories( int single );
    const QArray<int> &categories() const { return mCats; }

    int uid() const { return mUid; };
    virtual void setUid( int i ) { mUid = i; uidGen().store( mUid ); }
    bool isValidUid() const { return mUid != 0; }
    void assignUid() { setUid( uidGen().generate() ); }

    virtual QString customField(const QString &) const;
    virtual void setCustomField(const QString &, const QString &);
    virtual void removeCustomField(const QString &);

    virtual bool operator == ( const Record &r ) const
{ return mUid == r.mUid; }
    virtual bool operator != ( const Record &r ) const
{ return mUid != r.mUid; }

     
    static QString idsToString( const QArray<int> &ids );
     
    static QArray<int> idsFromString( const QString &str );

     
    static void dump( const QMap<int, QString> &map );

protected:
    virtual UidGen &uidGen() = 0;

    virtual QString customToXml() const;

private:
    int mUid;
    QArray<int> mCats;

    QMap<QString, QString> customMap;

    RecordPrivate *d;
};

}


# 31 "/opt/Qtopia/include/qpe/event.h" 2


# 1 "/opt/Qtopia/include/qpe/timeconversion.h" 1
 
























# 1 "/usr/include/sys/types.h" 1 3
 

















 








extern "C" { 





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;











typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;











typedef __pid_t pid_t;




typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;











# 143 "/usr/include/sys/types.h" 3



# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 1 3






 


# 19 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3



 


 





 


# 61 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 





 


















 





 

 

# 131 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 


# 188 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3





 




 

# 271 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


# 283 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3


 

 

# 317 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stddef.h" 3




 





















# 146 "/usr/include/sys/types.h" 2 3



 
typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;


 

# 180 "/usr/include/sys/types.h" 3


 







typedef int int8_t __attribute__ ((__mode__ (  __QI__ ))) ;
typedef int int16_t __attribute__ ((__mode__ (  __HI__ ))) ;
typedef int int32_t __attribute__ ((__mode__ (  __SI__ ))) ;
typedef int int64_t __attribute__ ((__mode__ (  __DI__ ))) ;


typedef unsigned int u_int8_t __attribute__ ((__mode__ (  __QI__ ))) ;
typedef unsigned int u_int16_t __attribute__ ((__mode__ (  __HI__ ))) ;
typedef unsigned int u_int32_t __attribute__ ((__mode__ (  __SI__ ))) ;
typedef unsigned int u_int64_t __attribute__ ((__mode__ (  __DI__ ))) ;

typedef int register_t __attribute__ ((__mode__ (__word__)));


 






 
# 1 "/usr/include/endian.h" 1 3
 






















 











 
# 1 "/usr/include/bits/endian.h" 1 3
 






# 37 "/usr/include/endian.h" 2 3


 



















# 212 "/usr/include/sys/types.h" 2 3


 
# 1 "/usr/include/sys/select.h" 1 3
 


















 






 


 
# 1 "/usr/include/bits/select.h" 1 3
 

























# 36 "/usr/include/bits/select.h" 3












# 56 "/usr/include/bits/select.h" 3

# 72 "/usr/include/bits/select.h" 3

# 31 "/usr/include/sys/select.h" 2 3


 
# 1 "/usr/include/bits/sigset.h" 1 3
 





















typedef int __sig_atomic_t;

 


typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int))) ];
  } __sigset_t;




 





# 125 "/usr/include/bits/sigset.h" 3

# 34 "/usr/include/sys/select.h" 2 3




typedef __sigset_t sigset_t;


 




# 1 "/usr/include/bits/time.h" 1 3
 


















 



# 57 "/usr/include/bits/time.h" 3








 

struct timeval
  {
    __time_t tv_sec;		 
    __suseconds_t tv_usec;	 
  };


# 46 "/usr/include/sys/select.h" 2 3



typedef __suseconds_t suseconds_t;




 
typedef long int __fd_mask;

 




 
typedef struct
  {
     





    __fd_mask __fds_bits[1024  / (8 * sizeof (__fd_mask)) ];


  } fd_set;

 



 
typedef __fd_mask fd_mask;

 




 






extern "C" { 

 




extern int select (int __nfds, fd_set *__restrict __readfds,
		   fd_set *__restrict __writefds,
		   fd_set *__restrict __exceptfds,
		   struct timeval *__restrict __timeout) throw () ;

# 116 "/usr/include/sys/select.h" 3


} 


# 215 "/usr/include/sys/types.h" 2 3


 
# 1 "/usr/include/sys/sysmacros.h" 1 3
 





















 








# 47 "/usr/include/sys/sysmacros.h" 3



# 218 "/usr/include/sys/types.h" 2 3









 


typedef __blkcnt_t blkcnt_t;	  



typedef __fsblkcnt_t fsblkcnt_t;  



typedef __fsfilcnt_t fsfilcnt_t;  


# 254 "/usr/include/sys/types.h" 3








} 


# 26 "/opt/Qtopia/include/qpe/timeconversion.h" 2



# 1 "/opt/Qtopia/include/qpe/qpcglobal.h" 1
 




















# 46 "/opt/Qtopia/include/qpe/qpcglobal.h"





# 29 "/opt/Qtopia/include/qpe/timeconversion.h" 2


class   TimeConversion
{
public:
    static QString toString( const QDate &d );
    static QDate fromString( const QString &datestr );

    static time_t toUTC( const QDateTime& dt );
    static QDateTime fromUTC( time_t time );
    static int secsTo( const QDateTime &from, const QDateTime &to );

    static QCString toISO8601( const QDate & );
    static QCString toISO8601( const QDateTime & );
    static QDateTime fromISO8601( const QCString & );
};


# 33 "/opt/Qtopia/include/qpe/event.h" 2


class EventPrivate;
class   Event : public Qtopia::Record
{
public:
    enum RepeatType { NoRepeat = -1, Daily, Weekly, MonthlyDay,
                      MonthlyDate, Yearly };
    enum Days { MON = 0x01, TUE = 0x02, WED = 0x04, THU = 0x08,
                FRI = 0x10, SAT = 0x20, SUN = 0x40 };
    struct   RepeatPattern
    {
	RepeatPattern() {
	    type = NoRepeat; frequency = -1; days = 0;  position = 0; createTime = -1;
	    hasEndDate = FALSE; endDateUTC = 0; }
	bool operator ==( const RepeatPattern &right ) const;

	RepeatType type;
	int frequency;
	int position;	 
	char days;   
	bool hasEndDate;
	QDate endDate() const { return TimeConversion::fromUTC( endDateUTC ).date(); }
	void setEndDate( const QDate &dt ) { endDateUTC = TimeConversion::toUTC( dt ); }
	time_t endDateUTC;
	time_t createTime;
    };

    Event();
    Event( const QMap<int, QString > & map );
    virtual ~Event();

    QMap<int, QString> toMap() const;

    static void writeVCalendar( const QString &filename, const QValueList<Event> &events);
    static void writeVCalendar( const QString &filename, const Event &event);
    static QValueList<Event> readVCalendar( const QString &filename );

    enum Type { Normal, AllDay };
    enum SoundTypeChoice { Silent, Loud };

    bool operator<( const Event &e1) const { return start() < e1.start(); };
    bool operator<=( const Event &e1 ) const { return start() <= e1.start(); };
    bool operator!=( const Event &e1 ) const { return !( *this == e1 ); };
    bool operator>( const Event &e1 ) const { return start() > e1.start(); };
    bool operator>=(const Event &e1 ) const { return start() >= e1.start(); };
    bool operator==( const Event &e ) const;

    void setDescription( const QString &s );
    const QString &description() const;

    void setLocation( const QString &s );
    const QString &location() const;

    void setType( Type t );
    Type type() const;
    void setStart( const QDateTime &d );
    void setStart( time_t time );
    QDateTime start( bool actual = FALSE ) const;
    time_t startTime() const { return startUTC; }
    void setEnd( const QDateTime &e );
    void setEnd( time_t time );
    QDateTime end( bool actual = FALSE ) const;
    time_t endTime() const { return endUTC; }
    void setTimeZone( const QString & );
    const QString &timeZone() const;
    void setAlarm( bool b, int minutes, SoundTypeChoice );
    bool hasAlarm() const;
    int alarmTime() const;
    SoundTypeChoice alarmSound() const;
    void setRepeat( bool b, const RepeatPattern &p );
    void setRepeat( const RepeatPattern &p );
    bool hasRepeat() const;
    const RepeatPattern &repeatPattern() const;
    RepeatPattern &repeatPattern();
    void setNotes( const QString &n );
    const QString &notes() const;
    bool doRepeat() const { return pattern.type != NoRepeat; }

    void save( QString& buf );
     

     
    static int week( const QDate& date );
     
     
    static int occurrence( const QDate& date );
     
    static char day( int dayOfWeek ) { return 1 << ( dayOfWeek - 1 ); }
     
     
    static int dayOfWeek( char day );
     
    static int monthDiff( const QDate& first, const QDate& second );
    bool match( const QRegExp &r ) const;

private:
    Qtopia::UidGen &uidGen() { return sUidGen; }
    static Qtopia::UidGen sUidGen;

    QString descript, locat, categ;
    Type typ : 4;
    bool startTimeDirty : 1;
    bool endTimeDirty : 1;
    time_t startUTC, endUTC;
    QString tz;
    bool hAlarm, hRepeat;
    int aMinutes;
    SoundTypeChoice aSound;
    RepeatPattern pattern;
    QString note;
    EventPrivate *d;
};

 
 
 

class EffectiveEventPrivate;
class   EffectiveEvent
{
public:
     
     
     
     
     
     
     
     
     
     
    enum Position { MidWay = 0, Start = 1, End = 2, StartEnd = 3 };

    EffectiveEvent();
    EffectiveEvent( const Event &event, const QDate &startDate, Position pos = StartEnd );
    EffectiveEvent( const EffectiveEvent & );
    EffectiveEvent& operator=( const EffectiveEvent & );
    ~EffectiveEvent();


    bool operator<( const EffectiveEvent &e ) const;
    bool operator<=( const EffectiveEvent &e ) const;
    bool operator==( const EffectiveEvent &e ) const;
    bool operator!=( const EffectiveEvent &e ) const;
    bool operator>( const EffectiveEvent &e ) const;
    bool operator>= ( const EffectiveEvent &e ) const;

    void setStart( const QTime &start );
    void setEnd( const QTime &end );
    void setEvent( Event e );
    void setDate( const QDate &date );
    void setEffectiveDates( const QDate &from, const QDate &to );

     
    const QString &description() const;
    const QString &location() const;
    const QString &notes() const;
    const Event &event() const;
    const QTime &start() const;
    const QTime &end() const;
    const QDate &date() const;
    int length() const;
    int size() const;

    QDate startDate() const;
    QDate endDate() const;

private:
    class EffectiveEventPrivate *d;
    Event mEvent;
    QDate mDate;
    QTime mStart,
	  mEnd;

};

# 228 "/opt/Qtopia/include/qpe/event.h"



# 28 "/opt/Qtopia/include/qpe/datebookdb.h" 2


 
enum journal_action { ACTION_ADD, ACTION_REMOVE, ACTION_REPLACE };

class DateBookDBPrivate;
class DateBookDB
{
public:
    DateBookDB();
    ~DateBookDB();

     
    QValueList<Event> getEvents( const QDate &from, const QDate &to );
    QValueList<Event> getEvents( const QDateTime &start );

     
    QValueList<EffectiveEvent> getEffectiveEvents( const QDate &from,
						   const QDate &to );
    QValueList<EffectiveEvent> getEffectiveEvents( const QDateTime &start );

    QValueList<Event> getRawRepeats() const;
    QValueList<Event> getNonRepeatingEvents( const QDate &from,
					     const QDate &to ) const;

     
    void addEvent( const Event &ev, bool doalarm=TRUE );
    void removeEvent( const Event &ev );
    void editEvent( const Event &old, Event &ev );
     
     
     
    void addJFEvent( const Event &ev, bool doalarm=TRUE );
    void removeJFEvent( const Event &ev );

    bool save();
    void reload();
private:
     
    bool origRepeat( const Event &ev, Event &orig ) const;
    bool removeRepeat( const Event &ev );
    void init();
    void loadFile( const QString &strFile );
     
    void saveJournalEntry( const Event &ev, journal_action action );
     
     
    bool saveJournalEntry( const Event &ev, journal_action action,
			   int key , bool origHadRepeat = false );

    QValueList<Event> eventList;  
    QValueList<Event> repeatEvents;  
    DateBookDBPrivate *d;
    QFile journalFile;
};

 
bool nextOccurance( const Event &e, const QDate &from, QDateTime &next);

# 6 "today.h" 2




class Today : public TodayBase
{
  public:	QMetaObject *metaObject() const { return staticMetaObject();	}	const char *className() const;	static QMetaObject* staticMetaObject();	static QString tr(const char*); static QString tr(const char*, const char*); 	protected:	void initMetaObject();	private:	static QMetaObject *metaObj; 
    
    public:
  Today( QWidget* parent = 0, const char* name = 0, WFlags fl = 0 );
  ~Today();
  
  private  :
    void goodBye();
  
 private:
  void getDates();
  int getTodo();
 private:
  DateBookDB *db;
  
};

# 2 "today.cpp" 2

# 1 "/opt/Qtopia/include/qpushbutton.h" 1
 








































# 1 "/opt/Qtopia/include/qbutton.h" 1
 














































class QButtonGroup;
struct QButtonData;
class QToolBar;

class   QButton : public QWidget
{
    public:	QMetaObject *metaObject() const { return staticMetaObject();	}	const char *className() const;	static QMetaObject* staticMetaObject();	static QString tr(const char*); static QString tr(const char*, const char*); 	protected:	void initMetaObject();	private:	static QMetaObject *metaObj; 
     
     
     
     
     
     
     
     
     
     
     
     

public:
    QButton( QWidget *parent=0, const char *name=0, WFlags f=0 );
   ~QButton();

    QString text() const;
    virtual void setText( const QString &);
    const QPixmap *pixmap() const;
    virtual void setPixmap( const QPixmap & );

    int		accel()	const;
    virtual void	setAccel( int );

    bool	isToggleButton() const;

    enum ToggleType { SingleShot, Toggle, Tristate };
    ToggleType	toggleType() const;

    virtual void setDown( bool );
    bool	isDown() const;

    bool	isOn() const;

    enum ToggleState { Off, NoChange, On };
    ToggleState	state() const;

    bool	autoResize() const;  
    virtual void setAutoResize( bool );  

    bool	autoRepeat() const;
    virtual void setAutoRepeat( bool );

    bool	isExclusiveToggle() const;

    bool	focusNextPrevChild( bool next );

    QButtonGroup *group() const;

public  :
    void	animateClick();
    void	toggle();

protected :
    void	pressed();
    void	released();
    void	clicked();
    void	toggled( bool );
    void	stateChanged( int );

protected:
    void	setToggleButton( bool );
    virtual void	setToggleType( ToggleType );
    void	setOn( bool );
    virtual void	setState( ToggleState );

    virtual bool hitButton( const QPoint &pos ) const;
    virtual void drawButton( QPainter * );
    virtual void drawButtonLabel( QPainter * );

    void	keyPressEvent( QKeyEvent *);
    void	keyReleaseEvent( QKeyEvent *);
    void	mousePressEvent( QMouseEvent * );
    void	mouseReleaseEvent( QMouseEvent * );
    void	mouseMoveEvent( QMouseEvent * );
    void	paintEvent( QPaintEvent * );
    void	focusInEvent( QFocusEvent * );
    void	focusOutEvent( QFocusEvent * );

    void	enabledChange( bool );

private  :
    void	animateTimeout();
    void	autoRepeatTimeout();

private:
    QString	btext;
    QPixmap    *bpixmap;
    uint	toggleTyp	: 2;
    uint	buttonDown	: 1;
    uint	stat		: 2;
    uint	mlbDown		: 1;
    uint	autoresize	: 1;
    uint	animation	: 1;
    uint	repeat		: 1;
    QButtonData *d;

    friend class QButtonGroup;
    friend class QToolBar;
    void          ensureData();
    virtual void setGroup( QButtonGroup* );
    QTimer	 *timer();
    void	nextState();

private:	 

    QButton( const QButton & );
    QButton &operator=( const QButton & );

};


inline QString QButton::text() const
{
    return btext;
}

inline const QPixmap *QButton::pixmap() const
{
    return bpixmap;
}

inline bool QButton::isToggleButton() const
{
    return toggleTyp != SingleShot;
}

inline  bool QButton::isDown() const
{
    return buttonDown;
}

inline bool QButton::isOn() const
{
    return stat != Off;
}

inline bool QButton::autoResize() const  
{
    return autoresize;
}

inline bool QButton::autoRepeat() const
{
    return repeat;
}

inline QButton::ToggleState QButton::state() const
{
    return ToggleState(stat);
}

inline void QButton::setToggleButton( bool b )
{
    setToggleType( b ? Toggle : SingleShot );
}

inline void QButton::setOn( bool y )
{
    setState( y ? On : Off );
}

inline QButton::ToggleType QButton::toggleType() const
{
    return ToggleType(toggleTyp);
}





# 42 "/opt/Qtopia/include/qpushbutton.h" 2

# 1 "/opt/Qtopia/include/qiconset.h" 1
 








































# 1 "/opt/Qtopia/include/qpixmap.h" 1
 














































class QGfx;







class   QPixmap : public QPaintDevice, public Qt
{
public:
    enum ColorMode { Auto, Color, Mono };
    enum Optimization { DefaultOptim, NoOptim, MemoryOptim=NoOptim,
			NormalOptim, BestOptim };

    QPixmap();
    QPixmap( int w, int h,  int depth = -1, Optimization = DefaultOptim );
    QPixmap( const QSize &, int depth = -1, Optimization = DefaultOptim );
    QPixmap( const QString& fileName, const char *format=0,
	     ColorMode mode=Auto );
    QPixmap( const QString& fileName, const char *format,
	     int conversion_flags );
    QPixmap( const char *xpm[] );
    QPixmap( const QByteArray &data );
    QPixmap( const QPixmap & );
   ~QPixmap();

    QPixmap    &operator=( const QPixmap & );
    QPixmap    &operator=( const QImage	 & );

    bool	isNull()	const;

    int		width()		const { return data->w; }
    int		height()	const { return data->h; }
    QSize	size()		const { return QSize(data->w,data->h); }
    QRect	rect()		const { return QRect(0,0,data->w,data->h); }
    int		depth()		const { return data->d; }
    static int	defaultDepth();

    void	fill( const QColor &fillColor = Qt::white );
    void	fill( const QWidget *, int xofs, int yofs );
    void	fill( const QWidget *, const QPoint &ofs );
    void	resize( int width, int height );
    void	resize( const QSize & );

    const QBitmap *mask() const;
    void	setMask( const QBitmap & );
    bool	selfMask() const;
    QBitmap	createHeuristicMask( bool clipTight = TRUE ) const;

    static  QPixmap grabWindow( WId, int x=0, int y=0, int w=-1, int h=-1 );
    static  QPixmap grabWidget( QWidget * widget,
				int x=0, int y=0, int w=-1, int h=-1 );


    QPixmap	    xForm( const QWMatrix & ) const;


    static QWMatrix trueMatrix( const QWMatrix &, int w, int h );


    QImage	convertToImage() const;
    bool	convertFromImage( const QImage &, ColorMode mode=Auto );
    bool	convertFromImage( const QImage &, int conversion_flags );

    static const char* imageFormat( const QString &fileName );
    bool	load( const QString& fileName, const char *format=0,
		      ColorMode mode=Auto );
    bool	load( const QString& fileName, const char *format,
		      int conversion_flags );
    bool	loadFromData( const uchar *buf, uint len,
			      const char* format=0,
			      ColorMode mode=Auto );
    bool	loadFromData( const uchar *buf, uint len,
			      const char* format,
			      int conversion_flags );
    bool	loadFromData( const QByteArray &data,
			      const char* format=0,
			      int conversion_flags=0 );
    bool	save( const QString& fileName, const char* format ) const;  
    bool	save( const QString& fileName, const char* format,
		      int quality ) const;  





    int		serialNumber()	const;

    Optimization	optimization() const;
    void		setOptimization( Optimization );
    static Optimization defaultOptimization();
    static void		setDefaultOptimization( Optimization );

    virtual void detach();

    bool	isQBitmap() const;

# 154 "/opt/Qtopia/include/qpixmap.h"














protected:
    QPixmap( int w, int h, const uchar *data, bool isXbitmap );
    int metric( int ) const;








    struct QPixmapData : public QShared {	 
	QCOORD	w, h;
	short	d;
	uint	uninit	 : 1;
	uint	bitmap	 : 1;
	uint	selfmask : 1;



	int	ser_no;
	QBitmap *mask;








	void   *ximage;
	void   *maskgc;








	Optimization optim;
    } *data;

private:
    QPixmap( int w, int h, int depth, bool, Optimization );
    void	init( int, int, int, bool, Optimization );
    void	deref();
    QPixmap	copy( bool ignoreMask = FALSE ) const;
    static Optimization defOptim;
    friend   void bitBlt( QPaintDevice *, int, int,
				 const QPaintDevice *,
				 int, int, int, int, RasterOp, bool );
    friend   void bitBlt( QPaintDevice *, int, int,
				 const QImage* src,
				 int, int, int, int, int conversion_flags );
    friend class QBitmap;
    friend class QPaintDevice;
    friend class QPainter;
};


inline bool QPixmap::isNull() const
{
    return data->w == 0;
}

inline void QPixmap::fill( const QWidget *w, const QPoint &ofs )
{
    fill( w, ofs.x(), ofs.y() );
}

inline void QPixmap::resize( const QSize &s )
{
    resize( s.width(), s.height() );
}

inline const QBitmap *QPixmap::mask() const
{
    return data->mask;
}

inline bool QPixmap::selfMask() const
{
    return data->selfmask;
}








inline int QPixmap::serialNumber() const
{
    return data->ser_no;
}

inline QPixmap::Optimization QPixmap::optimization() const
{
    return data->optim;
}

inline bool QPixmap::isQBitmap() const
{
    return data->bitmap;
}









 




  QDataStream &operator<<( QDataStream &, const QPixmap & );
  QDataStream &operator>>( QDataStream &, QPixmap & );



# 42 "/opt/Qtopia/include/qiconset.h" 2




struct QIconSetPrivate;


class   QIconSet
{
public:
    enum Size { Automatic, Small, Large };

    enum Mode { Normal, Disabled, Active };

    QIconSet();
    QIconSet( const QPixmap &, Size = Automatic );
    QIconSet( const QPixmap &smallPix, const QPixmap &largePix );
    QIconSet( const QIconSet & );
    virtual ~QIconSet();

    void reset( const QPixmap &, Size );

    virtual void setPixmap( const QPixmap &, Size, Mode = Normal );
    virtual void setPixmap( const QString &, Size, Mode = Normal );
    QPixmap pixmap( Size, Mode ) const;
    QPixmap pixmap( Size s, bool enabled ) const;
    QPixmap pixmap() const;
    bool isGenerated( Size, Mode ) const;

    bool isNull() const;

    void detach();

    QIconSet &operator=( const QIconSet & );

private:
    QIconSetPrivate * d;
};



# 43 "/opt/Qtopia/include/qpushbutton.h" 2





class   QPushButton : public QButton
{
    public:	QMetaObject *metaObject() const { return staticMetaObject();	}	const char *className() const;	static QMetaObject* staticMetaObject();	static QString tr(const char*); static QString tr(const char*, const char*); 	protected:	void initMetaObject();	private:	static QMetaObject *metaObj; 

     
     
     
     

     
     
     

public:
    QPushButton( QWidget *parent, const char *name=0 );
    QPushButton( const QString &text, QWidget *parent, const char* name=0 );
    QPushButton( const QIconSet& icon, const QString &text, QWidget *parent, const char* name=0 );
    ~QPushButton();

    QSize	sizeHint() const;
    QSizePolicy sizePolicy() const;

    void	move( int x, int y );
    void	move( const QPoint &p );
    void	resize( int w, int h );
    void	resize( const QSize & );
    virtual void setGeometry( int x, int y, int w, int h );

    virtual void setGeometry( const QRect & );

    virtual void setToggleButton( bool );  

    bool	autoDefault()	const	{ return autoDefButton; }
    virtual void setAutoDefault( bool autoDef );
    bool	isDefault()	const	{ return defButton; }
    virtual void setDefault( bool def );

    virtual void setIsMenuButton( bool );
    bool	isMenuButton() const;

    void setPopup( QPopupMenu* popup );
    QPopupMenu* popup() const;

    void setIconSet( const QIconSet& );
    QIconSet* iconSet() const;

    void setFlat( bool );
    bool isFlat() const;

public  :
    virtual void setOn( bool );

    void	toggle();

protected:
    void	drawButton( QPainter * );
    void	drawButtonLabel( QPainter * );
    void	focusInEvent( QFocusEvent * );
    void	focusOutEvent( QFocusEvent * );
    void	resizeEvent( QResizeEvent * );
    void	updateMask();

private  :
    void popupPressed();

private:
    void	init();

    uint	autoDefButton	: 1;
    uint	defButton	: 1;
    uint	flt		: 1;
    uint	reserved		: 1;  
    uint	lastEnabled	: 1;  
    uint	hasMenuArrow	: 1;

    friend class QDialog;

private:	 

    QPushButton( const QPushButton & );
    QPushButton &operator=( const QPushButton & );

};





# 3 "today.cpp" 2

# 1 "/opt/Qtopia/include/qlabel.h" 1
 








































# 1 "/opt/Qtopia/include/qframe.h" 1
 













































class   QFrame : public QWidget			 
{
    public:	QMetaObject *metaObject() const { return staticMetaObject();	}	const char *className() const;	static QMetaObject* staticMetaObject();	static QString tr(const char*); static QString tr(const char*, const char*); 	protected:	void initMetaObject();	private:	static QMetaObject *metaObj; 
     
     
     
     
     
     
     
     
     

public:
    QFrame( QWidget *parent=0, const char *name=0, WFlags f=0,
	    bool = TRUE );

    int		frameStyle()	const;
    virtual void setFrameStyle( int );

    int		frameWidth()	const;
    QRect	contentsRect()	const;


    bool	lineShapesOk()	const { return TRUE; }


    QSize	sizeHint() const;
    QSizePolicy sizePolicy() const;

    enum Shape { NoFrame  = 0,				 
		 Box	  = 0x0001,			 
		 Panel    = 0x0002,			 
		 WinPanel = 0x0003,			 
		 HLine    = 0x0004,			 
		 VLine    = 0x0005,			 
		 StyledPanel = 0x0006,			 
		 PopupPanel = 0x0007,			 
		 MShape   = 0x000f			 
    };
    enum Shadow { Plain    = 0x0010,			 
		  Raised   = 0x0020,			 
		  Sunken   = 0x0030,			 
		  MShadow  = 0x00f0 };			 

    Shape	frameShape()	const;
    void	setFrameShape( Shape );
    Shadow	frameShadow()	const;
    void	setFrameShadow( Shadow );

    int		lineWidth()	const;
    virtual void setLineWidth( int );

    int		margin()	const;
    virtual void setMargin( int );

    int		midLineWidth()	const;
    virtual void setMidLineWidth( int );

    QRect	frameRect()	const;
    virtual void setFrameRect( const QRect & );

protected:
    void	paintEvent( QPaintEvent * );
    void	resizeEvent( QResizeEvent * );
    virtual void drawFrame( QPainter * );
    virtual void drawContents( QPainter * );
    virtual void frameChanged();
    void	updateMask();
    virtual void drawFrameMask( QPainter * );
    virtual void drawContentsMask( QPainter * );

private:
    void	updateFrameWidth();
    QRect	frect;
    int		fstyle;
    short	lwidth;
    short	mwidth;
    short	mlwidth;
    short	fwidth;

    void * d;
private:	 

    QFrame( const QFrame & );
    QFrame &operator=( const QFrame & );

};


inline int QFrame::frameStyle() const
{ return fstyle; }

inline QFrame::Shape QFrame::frameShape() const
{ return (Shape) ( fstyle & MShape ); }

inline QFrame::Shadow QFrame::frameShadow() const
{ return (Shadow) ( fstyle & MShadow ); }

inline void QFrame::setFrameShape( QFrame::Shape s )
{ setFrameStyle( ( fstyle & MShadow ) | s ); }

inline void QFrame::setFrameShadow( QFrame::Shadow s )
{ setFrameStyle( ( fstyle & MShape ) | s ); }

inline int QFrame::lineWidth() const
{ return lwidth; }

inline int QFrame::midLineWidth() const
{ return mlwidth; }

inline int QFrame::margin() const
{ return mwidth; }

inline int QFrame::frameWidth() const
{ return fwidth; }





# 42 "/opt/Qtopia/include/qlabel.h" 2





class QSimpleRichText;
class QLabelPrivate;

class   QLabel : public QFrame
{
    public:	QMetaObject *metaObject() const { return staticMetaObject();	}	const char *className() const;	static QMetaObject* staticMetaObject();	static QString tr(const char*); static QString tr(const char*, const char*); 	protected:	void initMetaObject();	private:	static QMetaObject *metaObj; 
     
     
     
     
     
     
	
public:
    QLabel( QWidget *parent, const char *name=0, WFlags f=0 );
    QLabel( const QString &text, QWidget *parent, const char *name=0,
	    WFlags f=0 );
    QLabel( QWidget * buddy, const QString &,
	    QWidget * parent, const char * name=0, WFlags f=0 );
    ~QLabel();

    QString	 text()		const	{ return ltext; }
    QPixmap     *pixmap()	const	{ return lpixmap; }

    QMovie      *movie()		const;


    TextFormat textFormat() const;
    void 	 setTextFormat( TextFormat );

    int		 alignment() const	{ return align; }
    virtual void setAlignment( int );
    int		 indent() const		{ return extraMargin; }
    void 	 setIndent( int );

    bool 	 autoResize() const	{ return autoresize; }
    virtual void setAutoResize( bool );

    bool 	hasScaledContents() const;
    void 	setScaledContents( bool );

    QSize	 sizeHint() const;
    QSize	 minimumSizeHint() const;
    QSizePolicy  sizePolicy() const;

    virtual void setBuddy( QWidget * );
    QWidget     *buddy() const;

    void	 setAutoMask(bool);

    int		 heightForWidth(int) const;

public  :
    virtual void setText( const QString &);
    virtual void setPixmap( const QPixmap & );

    virtual void setMovie( const QMovie & );

    virtual void setNum( int );
    virtual void setNum( double );
    void	 clear();

protected:
    void	 drawContents( QPainter * );
    void	 drawContentsMask( QPainter * );
    void	 fontChange( const QFont & );
    void	 resizeEvent( QResizeEvent* );

private  :

    void	 acceleratorSlot();
    void	 buddyDied();


    void	 movieUpdated(const QRect&);
    void	 movieResized(const QSize&);


private:
    void	init();
    void	clearContents();
    void	updateLabel( QSize oldSizeHint );
    QSize	sizeForWidth( int w ) const;
    QString	ltext;
    QPixmap    *lpixmap;

    QMovie *	lmovie;


    QWidget *	lbuddy;

    ushort	align;
    short	extraMargin;
    uint	autoresize:1;
    uint	scaledcontents :1;
    TextFormat textformat;

    QSimpleRichText* doc;


    QAccel *	accel;

    QLabelPrivate* d;

private:	 

    QLabel( const QLabel & );
    QLabel &operator=( const QLabel & );

};





# 4 "today.cpp" 2



# 1 "/opt/Qtopia/include/qpe/timestring.h" 1
 

























 
 
 
 
class DateFormat 
{
public:
     
    enum Order {
	DayMonthYear = 0x0111,  
	MonthDayYear = 0x010A,
	YearMonthDay = 0x0054
    };

    DateFormat(QChar s = '/', Order so = MonthDayYear) : _shortOrder(so),
        _longOrder(so), _shortSeparator(s) { }
    DateFormat(QChar s, Order so, Order lo) :  _shortOrder(so),
        _longOrder(lo), _shortSeparator(s) { }
    DateFormat(const DateFormat &o) : _shortOrder(o._shortOrder),
        _longOrder(o._longOrder), _shortSeparator(o._shortSeparator) { }

    bool operator==(const DateFormat &o)
    {
	if (o._shortOrder == _shortOrder && o._longOrder == _longOrder &&
		o._shortSeparator == _shortSeparator)
	    return TRUE;
	return FALSE;
    }

     
    enum Verbosity {
	shortNumber = 0x01,  
	longNumber  = 0x02,

	padNumber = 0x04,

	shortWord = 0x08,  
	longWord = 0x10,

	showWeekDay = 0x20
    };

    QString toNumberString() const;  
    QString toWordString() const;  

    QString numberDate(const QDate &d, int v = 0) const;
    QString wordDate(const QDate &d, int v = 0) const;


    void load(QDataStream&);
    void save(QDataStream&) const;


    QChar separator() const { return _shortSeparator; };
    Order shortOrder() const { return _shortOrder; };
    Order longOrder() const { return _longOrder; };

private:
    Order _shortOrder;
    Order _longOrder;
    QChar _shortSeparator;
};


QDataStream &operator<<(QDataStream &s, const DateFormat&df);
QDataStream &operator>>(QDataStream &s, DateFormat&df);


class TimeString
{
public:

     
		       


    static QString shortDate( const QDate &d ) 
    { return shortDate( d, currentDateFormat() ); }
    static QString dateString( const QDate &d )
    { return dateString( d, currentDateFormat() ); }
    static QString longDateString( const QDate &d )
    { return longDateString( d, currentDateFormat() ); }
    static QString dateString( const QDateTime &dt, bool ampm, bool seconds )
    { return dateString( dt, ampm, seconds, currentDateFormat() ); }

    static QString dateString( const QDateTime &t, bool ampm = false );
    static QString timeString( const QTime &t, bool ampm, bool seconds );
    static QString timeString( const QTime &t, bool ampm = false );
    static QString shortTime( bool ampm, bool seconds );
    static QString shortTime( bool ampm = false );



    static QString shortDate( const QDate &, DateFormat );
    static QString dateString( const QDate &, DateFormat  );
    static QString longDateString( const QDate &, DateFormat );

    static DateFormat currentDateFormat();

private:
    static QString dateString( const QDateTime &t, bool ampm, bool seconds, DateFormat );
    

};


# 7 "today.cpp" 2

# 1 "/opt/Qtopia/include/qpe/config.h" 1
 























 




class ConfigPrivate;
class Config
{
public:
    typedef QMap< QString, QString > ConfigGroup;
    
    enum Domain { File, User };
    Config( const QString &name, Domain domain=User );
    ~Config();

    bool operator == ( const Config & other ) const { return (filename == other.filename); }
    bool operator != ( const Config & other ) const { return (filename != other.filename); }
    
    bool isValid() const;
    bool hasKey( const QString &key ) const;
    
    void setGroup( const QString &gname );
    void writeEntry( const QString &key, const char* value );
    void writeEntry( const QString &key, const QString &value );
    void writeEntryCrypt( const QString &key, const QString &value );
    void writeEntry( const QString &key, int num );

    void writeEntry( const QString &key, bool b );

    void writeEntry( const QString &key, const QStringList &lst, const QChar &sep );
    void removeEntry( const QString &key );
    
    QString readEntry( const QString &key, const QString &deflt = QString::null ) const;
    QString readEntryCrypt( const QString &key, const QString &deflt = QString::null ) const;
    QString readEntryDirect( const QString &key, const QString &deflt = QString::null ) const;
    int readNumEntry( const QString &key, int deflt = -1 ) const;
    bool readBoolEntry( const QString &key, bool deflt = FALSE ) const;
    QStringList readListEntry( const QString &key, const QChar &sep ) const;

     
    QString readEntry( const QString &key, const QString &deflt );
    QString readEntryCrypt( const QString &key, const QString &deflt );
    QString readEntryDirect( const QString &key, const QString &deflt );
    int readNumEntry( const QString &key, int deflt );
    bool readBoolEntry( const QString &key, bool deflt );
    QStringList readListEntry( const QString &key, const QChar &sep );
    
    void clearGroup();
    
    void write( const QString &fn = QString::null );
    
protected:
    void read();
    bool parse( const QString &line );
    
    QMap< QString, ConfigGroup > groups;
    QMap< QString, ConfigGroup >::Iterator git;
    QString filename;
    QString lang;
    QString glang;
    bool changed;
    ConfigPrivate *d;
    static QString configFilename(const QString& name, Domain);
};

inline QString Config::readEntry( const QString &key, const QString &deflt ) const
{ return ((Config*)this)->readEntry(key,deflt); }
inline QString Config::readEntryCrypt( const QString &key, const QString &deflt ) const
{ return ((Config*)this)->readEntryCrypt(key,deflt); }
inline QString Config::readEntryDirect( const QString &key, const QString &deflt ) const
{ return ((Config*)this)->readEntryDirect(key,deflt); }
inline int Config::readNumEntry( const QString &key, int deflt ) const
{ return ((Config*)this)->readNumEntry(key,deflt); }
inline bool Config::readBoolEntry( const QString &key, bool deflt ) const
{ return ((Config*)this)->readBoolEntry(key,deflt); }
inline QStringList Config::readListEntry( const QString &key, const QChar &sep ) const
{ return ((Config*)this)->readListEntry(key,sep); }


# 8 "today.cpp" 2


# 1 "/opt/Qtopia/include/qdom.h" 1
 









































# 1 "/opt/Qtopia/include/qdict.h" 1
 








































# 1 "/opt/Qtopia/include/qgdict.h" 1
 








































# 1 "/opt/Qtopia/include/qcollection.h" 1
 












































class QGVector;
class QGList;
class QGDict;


class   QCollection			 
{
public:
    bool autoDelete()	const	       { return del_item; }
    void setAutoDelete( bool enable )  { del_item = enable; }

    virtual uint  count() const = 0;
    virtual void  clear() = 0;			 

    typedef void *Item;				 

protected:
    QCollection() { del_item = FALSE; }		 
    QCollection(const QCollection &) { del_item = FALSE; }
    virtual ~QCollection() {}

    bool del_item;				 

    virtual Item     newItem( Item );		 
    virtual void     deleteItem( Item );	 
};



# 42 "/opt/Qtopia/include/qgdict.h" 2




class QGDictIterator;
class QGDItList;


class QBaseBucket				 
{
public:
    QCollection::Item	 getData()			{ return data; }
    QCollection::Item	 setData( QCollection::Item d ) { return data = d; }
    QBaseBucket		*getNext()			{ return next; }
    void		 setNext( QBaseBucket *n)	{ next = n; }
protected:
    QBaseBucket( QCollection::Item d, QBaseBucket *n ) : data(d), next(n) {}
    QCollection::Item	 data;
    QBaseBucket		*next;
};

class QStringBucket : public QBaseBucket
{
public:
    QStringBucket( const QString &k, QCollection::Item d, QBaseBucket *n )
	: QBaseBucket(d,n), key(k)		{}
    const QString  &getKey() const		{ return key; }
private:
    QString	    key;
};

class QAsciiBucket : public QBaseBucket
{
public:
    QAsciiBucket( const char *k, QCollection::Item d, QBaseBucket *n )
	: QBaseBucket(d,n), key(k) {}
    const char *getKey() const { return key; }
private:
    const char *key;
};

class QIntBucket : public QBaseBucket
{
public:
    QIntBucket( long k, QCollection::Item d, QBaseBucket *n )
	: QBaseBucket(d,n), key(k) {}
    long  getKey() const { return key; }
private:
    long  key;
};

class QPtrBucket : public QBaseBucket
{
public:
    QPtrBucket( void *k, QCollection::Item d, QBaseBucket *n )
	: QBaseBucket(d,n), key(k) {}
    void *getKey() const { return key; }
private:
    void *key;
};


class   QGDict : public QCollection	 
{
public:
    uint	count() const	{ return numItems; }
    uint	size()	const	{ return vlen; }
    QCollection::Item look_string( const QString& key, QCollection::Item,
				   int );
    QCollection::Item look_ascii( const char *key, QCollection::Item, int );
    QCollection::Item look_int( long key, QCollection::Item, int );
    QCollection::Item look_ptr( void *key, QCollection::Item, int );

    QDataStream &read( QDataStream & );
    QDataStream &write( QDataStream & ) const;

protected:
    enum KeyType { StringKey, AsciiKey, IntKey, PtrKey };

    QGDict( uint len, KeyType kt, bool cs, bool ck );
    QGDict( const QGDict & );
   ~QGDict();

    QGDict     &operator=( const QGDict & );

    bool	remove_string( const QString &key, QCollection::Item item=0 );
    bool	remove_ascii( const char *key, QCollection::Item item=0 );
    bool	remove_int( long key, QCollection::Item item=0 );
    bool	remove_ptr( void *key, QCollection::Item item=0 );
    QCollection::Item take_string( const QString &key );
    QCollection::Item take_ascii( const char *key );
    QCollection::Item take_int( long key );
    QCollection::Item take_ptr( void *key );

    void	clear();
    void	resize( uint );

    int		hashKeyString( const QString & );
    int		hashKeyAscii( const char * );

    void	statistics() const;


    virtual QDataStream &read( QDataStream &, QCollection::Item & );
    virtual QDataStream &write( QDataStream &, QCollection::Item ) const;

private:
    QBaseBucket **vec;
    uint	vlen;
    uint	numItems;
    uint	keytype	: 2;
    uint	cases	: 1;
    uint	copyk	: 1;
    QGDItList  *iterators;
    void	   unlink_common( int, QBaseBucket *, QBaseBucket * );
    QStringBucket *unlink_string( const QString &,
				  QCollection::Item item = 0 );
    QAsciiBucket  *unlink_ascii( const char *, QCollection::Item item = 0 );
    QIntBucket    *unlink_int( long, QCollection::Item item = 0 );
    QPtrBucket    *unlink_ptr( void *, QCollection::Item item = 0 );
    void	init( uint, KeyType, bool, bool );
    friend class QGDictIterator;
};


class   QGDictIterator			 
{
friend class QGDict;
public:
    QGDictIterator( const QGDict & );
    QGDictIterator( const QGDictIterator & );
    QGDictIterator &operator=( const QGDictIterator & );
   ~QGDictIterator();

    QCollection::Item toFirst();

    QCollection::Item get()	     const;
    QString	      getKeyString() const;
    const char	     *getKeyAscii()  const;
    long	      getKeyInt()    const;
    void	     *getKeyPtr()    const;

    QCollection::Item operator()();
    QCollection::Item operator++();
    QCollection::Item operator+=(uint);

protected:
    QGDict	     *dict;

private:
    QBaseBucket      *curNode;
    uint	      curIndex;
};

inline QCollection::Item QGDictIterator::get() const
{
    return curNode ? curNode->getData() : 0;
}

inline QString QGDictIterator::getKeyString() const
{
    return curNode ? ((QStringBucket*)curNode)->getKey() : QString::null;
}

inline const char *QGDictIterator::getKeyAscii() const
{
    return curNode ? ((QAsciiBucket*)curNode)->getKey() : 0;
}

inline long QGDictIterator::getKeyInt() const
{
    return curNode ? ((QIntBucket*)curNode)->getKey() : 0;
}

inline void *QGDictIterator::getKeyPtr() const
{
    return curNode ? ((QPtrBucket*)curNode)->getKey() : 0;
}



# 42 "/opt/Qtopia/include/qdict.h" 2




template<class type> class   QDict : public QGDict
{
public:
    QDict(int size=17, bool caseSensitive=TRUE)
	: QGDict(size,StringKey,caseSensitive,FALSE) {}
    QDict( const QDict<type> &d ) : QGDict(d) {}
   ~QDict()				{ clear(); }
    QDict<type> &operator=(const QDict<type> &d)
			{ return (QDict<type>&)QGDict::operator=(d); }
    uint  count()   const		{ return QGDict::count(); }
    uint  size()    const		{ return QGDict::size(); }
    bool  isEmpty() const		{ return QGDict::count() == 0; }

    void  insert( const QString &k, const type *d )
					{ QGDict::look_string(k,(Item)d,1); }
    void  replace( const QString &k, const type *d )
					{ QGDict::look_string(k,(Item)d,2); }
    bool  remove( const QString &k )	{ return QGDict::remove_string(k); }
    type *take( const QString &k )	{ return (type *)QGDict::take_string(k); }
    type *find( const QString &k ) const
		{ return (type *)((QGDict*)this)->QGDict::look_string(k,0,0); }
    type *operator[]( const QString &k ) const
		{ return (type *)((QGDict*)this)->QGDict::look_string(k,0,0); }

    void  clear()			{ QGDict::clear(); }
    void  resize( uint n )		{ QGDict::resize(n); }
    void  statistics() const		{ QGDict::statistics(); }
private:
    void  deleteItem( Item d );
};


template<> inline void QDict<void>::deleteItem( Item )
{
}


template<class type> inline void QDict<type>::deleteItem( QCollection::Item d )
{
    if ( del_item ) delete (type *)d;
}


template<class type> class   QDictIterator : public QGDictIterator
{
public:
    QDictIterator(const QDict<type> &d) :QGDictIterator((QGDict &)d) {}
   ~QDictIterator()	      {}
    uint  count()   const     { return dict->count(); }
    bool  isEmpty() const     { return dict->count() == 0; }
    type *toFirst()	      { return (type *)QGDictIterator::toFirst(); }
    operator type *() const   { return (type *)QGDictIterator::get(); }
    type   *current() const   { return (type *)QGDictIterator::get(); }
    QString currentKey() const{ return QGDictIterator::getKeyString(); }
    type *operator()()	      { return (type *)QGDictIterator::operator()(); }
    type *operator++()	      { return (type *)QGDictIterator::operator++(); }
    type *operator+=(uint j)  { return (type *)QGDictIterator::operator+=(j);}
};



# 43 "/opt/Qtopia/include/qdom.h" 2



# 1 "/opt/Qtopia/include/qpen.h" 1
 













































class   QPen: public Qt
{
friend class QPainter;
public:
    QPen();
    QPen( PenStyle );
    QPen( const QColor &color, uint width=0, PenStyle style=SolidLine );
    QPen( const QColor &cl, uint w, PenStyle s, PenCapStyle c, PenJoinStyle j);
    QPen( const QPen & );
   ~QPen();
    QPen &operator=( const QPen & );

    PenStyle	style() const		{ return data->style; }
    void	setStyle( PenStyle );
    uint	width() const		{ return data->width; }
    void	setWidth( uint );
    const QColor &color() const		{ return data->color; }
    void	setColor( const QColor & );
    PenCapStyle	capStyle() const;
    void	setCapStyle( PenCapStyle );
    PenJoinStyle joinStyle() const;
    void	setJoinStyle( PenJoinStyle );

    bool	operator==( const QPen &p ) const;
    bool	operator!=( const QPen &p ) const
					{ return !(operator==(p)); }

private:
    QPen	copy()	const;
    void	detach();
    void	init( const QColor &, uint, uint );
    struct QPenData : public QShared {		 
	PenStyle  style;
	uint	  width;
	QColor	  color;
	Q_UINT16  linest;
    } *data;
};


 



  QDataStream &operator<<( QDataStream &, const QPen & );
  QDataStream &operator>>( QDataStream &, QPen & );



# 46 "/opt/Qtopia/include/qdom.h" 2







# 1 "/opt/Qtopia/include/qmodules.h" 1
 










# 53 "/opt/Qtopia/include/qdom.h" 2








# 601 "/opt/Qtopia/include/qdom.h"


# 10 "today.cpp" 2



# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/../../../../include/g++-3/iostream.h" 1 3
 

























#pragma interface



# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/../../../../include/g++-3/streambuf.h" 1 3
 


























#pragma interface


   



extern "C" {

}
 

# 1 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stdarg.h" 1 3
 
































































 










 



 

















void va_end (__gnuc_va_list);		 


 



 












 























 
 













# 175 "/usr/lib/gcc-lib/i386-linux/2.95.4/include/stdarg.h" 3


 




 

 

 

typedef __gnuc_va_list va_list;
























# 40 "/usr/lib/gcc-lib/i386-linux/2.95.4/../../../../include/g++-3/streambuf.h" 2 3

























extern "C++" {
class istream;  
class ostream; class streambuf;

 




typedef __off64_t   streamoff;
typedef __off64_t   streampos;




typedef __ssize_t   streamsize;

typedef unsigned long __fmtflags;
typedef unsigned char __iostate;

struct _ios_fields
{  
    streambuf *_strbuf;
    ostream* _tie;
    int _width;
    __fmtflags _flags;
    wchar_t   _fill;
    __iostate _state;
    __iostate _exceptions;
    int _precision;

    void *_arrays;  
};















# 124 "/usr/lib/gcc-lib/i386-linux/2.95.4/../../../../include/g++-3/streambuf.h" 3


class ios : public _ios_fields {
  ios& operator=(ios&);   
  ios (const ios&);  
  public:
    typedef __fmtflags fmtflags;
    typedef int iostate;
    typedef int openmode;
    typedef __ssize_t   streamsize;
    enum io_state {
	goodbit = 0 ,
	eofbit = 1 ,
	failbit = 2 ,
	badbit = 4  };
    enum open_mode {
	in = 1 ,
	out = 2 ,
	ate = 4 ,
	app = 8 ,
	trunc = 16 ,
	nocreate = 32 ,
	noreplace = 64 ,
	bin = 128 ,  
	binary = 128  };
    enum seek_dir { beg, cur, end};
    typedef enum seek_dir seekdir;
     
    enum { skipws= 01 ,
	   left= 02 , right= 04 , internal= 010 ,
	   dec= 020 , oct= 040 , hex= 0100 ,
	   showbase= 0200 , showpoint= 0400 ,
	   uppercase= 01000 , showpos= 02000 ,
	   scientific= 04000 , fixed= 010000 ,
	   unitbuf= 020000 , stdio= 040000 



	   };
    enum {  
	basefield=dec+oct+hex,
	floatfield = scientific+fixed,
	adjustfield = left+right+internal
    };

# 177 "/usr/lib/gcc-lib/i386-linux/2.95.4/../../../../include/g++-3/streambuf.h" 3


    ostream* tie() const { return _tie; }
    ostream* tie(ostream* val) { ostream* save=_tie; _tie=val; return save; }

     
    wchar_t   fill() const { return _fill; }
    wchar_t   fill(wchar_t   newf)
	{wchar_t   oldf = _fill; _fill = newf; return oldf;}
    fmtflags flags() const { return _flags; }
    fmtflags flags(fmtflags new_val) {
	fmtflags old_val = _flags; _flags = new_val; return old_val; }
    int precision() const { return _precision; }
    int precision(int newp) {
	unsigned short oldp = _precision; _precision = (unsigned short)newp;
	return oldp; }
    fmtflags setf(fmtflags val) {
	fmtflags oldbits = _flags;
	_flags |= val; return oldbits; }
    fmtflags setf(fmtflags val, fmtflags mask) {
	fmtflags oldbits = _flags;
	_flags = (_flags & ~mask) | (val & mask); return oldbits; }
    fmtflags unsetf(fmtflags mask) {
	fmtflags oldbits = _flags;
	_flags &= ~mask; return oldbits; }
    int width() const { return _width; }
    int width(int val) { int save = _width; _width = val; return save; }




    void _throw_failure() const { }

    void clear(iostate state = 0) {
	_state = _strbuf ? state : state|badbit;
	if (_state & _exceptions) _throw_failure(); }
    void set(iostate flag) { _state |= flag;
	if (_state & _exceptions) _throw_failure(); }
    void setstate(iostate flag) { _state |= flag;  
	if (_state & _exceptions) _throw_failure(); }
    int good() const { return _state == 0; }
    int eof() const { return _state & ios::eofbit; }
    int fail() const { return _state & (ios::badbit|ios::failbit); }
    int bad() const { return _state & ios::badbit; }
    iostate rdstate() const { return _state; }
    operator void*() const { return fail() ? (void*)0 : (void*)(-1); }
    int operator!() const { return fail(); }
    iostate exceptions() const { return _exceptions; }
    void exceptions(iostate enable) {
	_exceptions = enable;
	if (_state & _exceptions) _throw_failure(); }

    streambuf* rdbuf() const { return _strbuf; }
    streambuf* rdbuf(streambuf *_s) {
      streambuf *_old = _strbuf; _strbuf = _s; clear (); return _old; }

    static int sync_with_stdio(int on);
    static void sync_with_stdio() { sync_with_stdio(1); }
    static fmtflags bitalloc();
    static int xalloc();
    void*& pword(int);
    void* pword(int) const;
    long& iword(int);
    long iword(int) const;









     
    class Init {
    public:
      Init () { }
    };

  protected:
    inline ios(streambuf* sb = 0, ostream* tie_to = 0);
    inline virtual ~ios();
    inline void init(streambuf* sb, ostream* tie = 0);
};




typedef ios::seek_dir _seek_dir;


 
 
 
 
 

 
 
class streammarker : private _IO_marker {
    friend class streambuf;
    void set_offset(int offset) { _pos = offset; }
  public:
    streammarker(streambuf *sb);
    ~streammarker();
    int saving() { return  1; }
    int delta(streammarker&);
    int delta();
};

struct streambuf : public _IO_FILE {  
    friend class ios;
    friend class istream;
    friend class ostream;
    friend class streammarker;
    const void *&_vtable() { return *(const void**)((_IO_FILE*)this + 1); }
  protected:
    static streambuf* _list_all;  
    _IO_FILE*& xchain() { return _chain; }
    void _un_link();
    void _link_in();
    char* gptr() const
      { return _flags  & 0x100  ? _IO_save_base : _IO_read_ptr; }
    char* pptr() const { return _IO_write_ptr; }
    char* egptr() const
      { return _flags  & 0x100  ? _IO_save_end : _IO_read_end; }
    char* epptr() const { return _IO_write_end; }
    char* pbase() const { return _IO_write_base; }
    char* eback() const
      { return _flags  & 0x100  ? _IO_save_base : _IO_read_base;}
    char* base() const { return _IO_buf_base; }
    char* ebuf() const { return _IO_buf_end; }
    int blen() const { return _IO_buf_end - _IO_buf_base; }
    void xput_char(char c) { *_IO_write_ptr++ = c; }
    int xflags() { return _flags ; }
    int xflags(int f) {int fl = _flags ; _flags  = f; return fl;}
    void xsetflags(int f) { _flags  |= f; }
    void xsetflags(int f, int mask)
      { _flags  = (_flags  & ~mask) | (f & mask); }
    void gbump(int n)
      { _flags  & 0x100  ? (_IO_save_base+=n):(_IO_read_ptr+=n);}
    void pbump(int n) { _IO_write_ptr += n; }
    void setb(char* b, char* eb, int a=0);
    void setp(char* p, char* ep)
      { _IO_write_base=_IO_write_ptr=p; _IO_write_end=ep; }
    void setg(char* eb, char* g, char *eg) {
      if (_flags  & 0x100 ) _IO_free_backup_area(this); 
      _IO_read_base = eb; _IO_read_ptr = g; _IO_read_end = eg; }
    char *shortbuf() { return _shortbuf; }

    int in_backup() { return _flags & 0x100 ; }
     
    char *Gbase() { return in_backup() ? _IO_save_base : _IO_read_base; }
     
    char *eGptr() { return in_backup() ? _IO_save_end : _IO_read_end; }
     
    char *Bbase() { return in_backup() ? _IO_read_base : _IO_save_base; }
    char *Bptr() { return _IO_backup_base; }
     
    char *eBptr() { return in_backup() ? _IO_read_end : _IO_save_end; }
    char *Nbase() { return _IO_save_base; }
    char *eNptr() { return _IO_save_end; }
    int have_backup() { return _IO_save_base != __null ; }
    int have_markers() { return _markers != __null ; }
    void free_backup_area();
    void unsave_markers();  
    int put_mode() { return _flags & 0x800 ; }
    int switch_to_get_mode();
    
    streambuf(int flags=0);
  public:
    static int flush_all();
    static void flush_all_linebuffered();  
    virtual ~streambuf();
    virtual int overflow(int c = (-1) );  
    virtual int underflow();  
    virtual int uflow();  
    virtual int pbackfail(int c);
 
    virtual streamsize xsputn(const char* s, streamsize n);
    virtual streamsize xsgetn(char* s, streamsize n);
    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    virtual streampos seekpos(streampos pos, int mode = ios::in|ios::out);

    streampos pubseekoff(streamoff o, _seek_dir d, int mode=ios::in|ios::out)
      { return _IO_seekoff (this, o, d, mode); }
    streampos pubseekpos(streampos pos, int mode = ios::in|ios::out)
      { return _IO_seekpos (this, pos, mode); }
    streampos sseekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    streampos sseekpos(streampos pos, int mode = ios::in|ios::out);
    virtual streambuf* setbuf(char* p, int len);
    virtual int sync();
    virtual int doallocate();

    int seekmark(streammarker& mark, int delta = 0);
    int sputbackc(char c);
    int sungetc();
    int unbuffered() { return _flags & 2  ? 1 : 0; }
    int linebuffered() { return _flags & 0x200  ? 1 : 0; }
    void unbuffered(int i)
	{ if (i) _flags |= 2 ; else _flags &= ~2 ; }
    void linebuffered(int i)
	{ if (i) _flags |= 0x200 ; else _flags &= ~0x200 ; }
    int allocate() {  
	if (base() || unbuffered()) return 0;
	else return doallocate(); }
     
    void allocbuf() { if (base() == __null ) doallocbuf(); }
    void doallocbuf();
    int in_avail() { return _IO_read_end - _IO_read_ptr; }
    int out_waiting() { return _IO_write_ptr - _IO_write_base; }
    streamsize sputn(const char* s, streamsize n) { return xsputn(s, n); }
    streamsize padn(char pad, streamsize n) { return _IO_padn(this, pad, n); }
    streamsize sgetn(char* s, streamsize n) { return _IO_sgetn(this, s, n); }
    int ignore(int);
    int get_column();
    int set_column(int);
    long sgetline(char* buf, size_t   n, char delim, int putback_delim);
    int sputc(int c) { return _IO_putc(c, this); }
    int sbumpc() { return _IO_getc(this); }
    int sgetc() { return ((  this  )->_IO_read_ptr >= (  this  )->_IO_read_end && __underflow (  this  ) == (-1)  ? (-1)  : *(unsigned char *) (  this  )->_IO_read_ptr)  ; }
    int snextc() {
	if (_IO_read_ptr >= _IO_read_end && __underflow(this) == (-1) )
	  return (-1) ;
	else return _IO_read_ptr++, sgetc(); }
    void stossc() { if (_IO_read_ptr < _IO_read_end) _IO_read_ptr++; }
    int vscan(char const *fmt0, __gnuc_va_list  ap, ios* stream = __null );
    int scan(char const *fmt0 ...);
    int vform(char const *fmt0, __gnuc_va_list  ap);
    int form(char const *fmt0 ...);




    virtual streamsize sys_read(char* buf, streamsize size);
    virtual streamsize sys_write(const char*, streamsize);
    virtual streampos sys_seek(streamoff, _seek_dir);
    virtual int sys_close();
    virtual int sys_stat(void*);  

    virtual int showmanyc();
    virtual void imbue(void *);

};

 
 

class filebuf : public streambuf {
  protected:
    void init();
  public:
    static const int openprot;  
    filebuf();
    filebuf(int fd);
    filebuf(int fd, char* p, int len);



    ~filebuf();
    filebuf* attach(int fd);
    filebuf* open(const char *filename, const char *mode);
    filebuf* open(const char *filename, ios::openmode mode, int prot = 0664);
    virtual int underflow();
    virtual int overflow(int c = (-1) );
    int is_open() const { return _fileno >= 0; }
    int fd() const { return is_open() ? _fileno : (-1) ; }
    filebuf* close();
    virtual int doallocate();
    virtual streampos seekoff(streamoff, _seek_dir, int mode=ios::in|ios::out);
    virtual streambuf* setbuf(char* p, int len);
    streamsize xsputn(const char* s, streamsize n);
    streamsize xsgetn(char* s, streamsize n);
    virtual int sync();
  protected:  
 
    int is_reading() { return eback() != egptr(); }
    char* cur_ptr() { return is_reading() ?  gptr() : pptr(); }
     
    char* file_ptr() { return eGptr(); }
     
    virtual streamsize sys_read(char* buf, streamsize size);
    virtual streampos sys_seek(streamoff, _seek_dir);
    virtual streamsize sys_write(const char*, streamsize);
    virtual int sys_stat(void*);  
    virtual int sys_close();




};

inline void ios::init(streambuf* sb, ostream* tie_to) {
		_state = sb ? ios::goodbit : ios::badbit; _exceptions=0;
		_strbuf=sb; _tie = tie_to; _width=0; _fill=' ';

		_flags=ios::skipws|ios::dec;



		_precision=6; _arrays = 0; }

inline ios::ios(streambuf* sb, ostream* tie_to) { init(sb, tie_to); }

inline ios::~ios() {



     
     
    operator delete[] (_arrays);
}
}  

# 31 "/usr/lib/gcc-lib/i386-linux/2.95.4/../../../../include/g++-3/iostream.h" 2 3


extern "C++" {
class istream; class ostream;
typedef ios& (*__manip)(ios&);
typedef istream& (*__imanip)(istream&);
typedef ostream& (*__omanip)(ostream&);

extern istream& ws(istream& ins);
extern ostream& flush(ostream& outs);
extern ostream& endl(ostream& outs);
extern ostream& ends(ostream& outs);

class ostream : virtual public ios
{
     
    void do_osfx();
  public:
    ostream() { }
    ostream(streambuf* sb, ostream* tied= __null );
    int opfx() {
	if (!good()) return 0;
	else { if (_tie) _tie->flush();  ; return 1;} }
    void osfx() {  ;
		  if (flags() & (ios::unitbuf|ios::stdio))
		      do_osfx(); }
    ostream& flush();
    ostream& put(char c) { _strbuf->sputc(c); return *this; }





    ostream& write(const char *s, streamsize n);
    ostream& write(const unsigned char *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& write(const signed char *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& write(const void *s, streamsize n)
      { return write((const char*)s, n);}
    ostream& seekp(streampos);
    ostream& seekp(streamoff, _seek_dir);
    streampos tellp();
    ostream& form(const char *format ...);
    ostream& vform(const char *format, __gnuc_va_list  args);

    ostream& operator<<(char c);
    ostream& operator<<(unsigned char c) { return (*this) << (char)c; }
    ostream& operator<<(signed char c) { return (*this) << (char)c; }
    ostream& operator<<(const char *s);
    ostream& operator<<(const unsigned char *s)
	{ return (*this) << (const char*)s; }
    ostream& operator<<(const signed char *s)
	{ return (*this) << (const char*)s; }
    ostream& operator<<(const void *p);
    ostream& operator<<(int n);
    ostream& operator<<(unsigned int n);
    ostream& operator<<(long n);
    ostream& operator<<(unsigned long n);

    __extension__ ostream& operator<<(long long n);
    __extension__ ostream& operator<<(unsigned long long n);

    ostream& operator<<(short n) {return operator<<((int)n);}
    ostream& operator<<(unsigned short n) {return operator<<((unsigned int)n);}

    ostream& operator<<(bool b) { return operator<<((int)b); }

    ostream& operator<<(double n);
    ostream& operator<<(float n) { return operator<<((double)n); }

    ostream& operator<<(long double n);



    ostream& operator<<(__omanip func) { return (*func)(*this); }
    ostream& operator<<(__manip func) {(*func)(*this); return *this;}
    ostream& operator<<(streambuf*);



};

class istream : virtual public ios
{
     
protected:
    size_t   _gcount;

    int _skip_ws();
  public:
    istream(): _gcount (0) { }
    istream(streambuf* sb, ostream*tied= __null );
    istream& get(char* ptr, int len, char delim = '\n');
    istream& get(unsigned char* ptr, int len, char delim = '\n')
	{ return get((char*)ptr, len, delim); }
    istream& get(char& c);
    istream& get(unsigned char& c) { return get((char&)c); }
    istream& getline(char* ptr, int len, char delim = '\n');
    istream& getline(unsigned char* ptr, int len, char delim = '\n')
	{ return getline((char*)ptr, len, delim); }
    istream& get(signed char& c)  { return get((char&)c); }
    istream& get(signed char* ptr, int len, char delim = '\n')
	{ return get((char*)ptr, len, delim); }
    istream& getline(signed char* ptr, int len, char delim = '\n')
	{ return getline((char*)ptr, len, delim); }
    istream& read(char *ptr, streamsize n);
    istream& read(unsigned char *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& read(signed char *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& read(void *ptr, streamsize n)
      { return read((char*)ptr, n); }
    istream& get(streambuf& sb, char delim = '\n');
    istream& gets(char **s, char delim = '\n');
    int ipfx(int need = 0) {
	if (!good()) { set(ios::failbit); return 0; }
	else {
	   ;
	  if (_tie && (need == 0 || rdbuf()->in_avail() < need)) _tie->flush();
	  if (!need && (flags() & ios::skipws)) return _skip_ws();
	  else return 1;
	}
    }
    int ipfx0() {  
	if (!good()) { set(ios::failbit); return 0; }
	else {
	   ;
	  if (_tie) _tie->flush();
	  if (flags() & ios::skipws) return _skip_ws();
	  else return 1;
	}
    }
    int ipfx1() {  
	if (!good()) { set(ios::failbit); return 0; }
	else {
	   ;
	  if (_tie && rdbuf()->in_avail() == 0) _tie->flush();
	  return 1;
	}
    }
    void isfx() {  ; }
    int get() { if (!ipfx1()) return (-1) ;
		else { int ch = _strbuf->sbumpc();
		       if (ch == (-1) ) set(ios::eofbit);
		       isfx();
		       return ch;
		     } }
    int peek();
    size_t   gcount() { return _gcount; }
    istream& ignore(int n=1, int delim = (-1) );
    int sync ();
    istream& seekg(streampos);
    istream& seekg(streamoff, _seek_dir);
    streampos tellg();
    istream& putback(char ch) {
	if (good() && _strbuf->sputbackc(ch) == (-1) ) clear(ios::badbit);
	return *this;}
    istream& unget() {
	if (good() && _strbuf->sungetc() == (-1) ) clear(ios::badbit);
	return *this;}
    istream& scan(const char *format ...);
    istream& vscan(const char *format, __gnuc_va_list  args);






    istream& operator>>(char*);
    istream& operator>>(unsigned char* p) { return operator>>((char*)p); }
    istream& operator>>(signed char*p) { return operator>>((char*)p); }
    istream& operator>>(char& c);
    istream& operator>>(unsigned char& c) {return operator>>((char&)c);}
    istream& operator>>(signed char& c) {return operator>>((char&)c);}
    istream& operator>>(int&);
    istream& operator>>(long&);

    __extension__ istream& operator>>(long long&);
    __extension__ istream& operator>>(unsigned long long&);

    istream& operator>>(short&);
    istream& operator>>(unsigned int&);
    istream& operator>>(unsigned long&);
    istream& operator>>(unsigned short&);

    istream& operator>>(bool&);

    istream& operator>>(float&);
    istream& operator>>(double&);
    istream& operator>>(long double&);
    istream& operator>>( __manip func) {(*func)(*this); return *this;}
    istream& operator>>(__imanip func) { return (*func)(*this); }
    istream& operator>>(streambuf*);
};

class iostream : public istream, public ostream
{
  public:
    iostream() { }
    iostream(streambuf* sb, ostream*tied= __null );
};

class _IO_istream_withassign : public istream {
public:
  _IO_istream_withassign& operator=(istream&);
  _IO_istream_withassign& operator=(_IO_istream_withassign& rhs)
    { return operator= (static_cast<istream&> (rhs)); }
};

class _IO_ostream_withassign : public ostream {
public:
  _IO_ostream_withassign& operator=(ostream&);
  _IO_ostream_withassign& operator=(_IO_ostream_withassign& rhs)
    { return operator= (static_cast<ostream&> (rhs)); }
};

extern _IO_istream_withassign cin;
 
extern _IO_ostream_withassign cout, cerr;

extern _IO_ostream_withassign clog



;

extern istream& lock(istream& ins);
extern istream& unlock(istream& ins);
extern ostream& lock(ostream& outs);
extern ostream& unlock(ostream& outs);

struct Iostream_init { } ;   

inline ios& dec(ios& i)
{ i.setf(ios::dec, ios::dec|ios::hex|ios::oct); return i; }
inline ios& hex(ios& i)
{ i.setf(ios::hex, ios::dec|ios::hex|ios::oct); return i; }
inline ios& oct(ios& i)
{ i.setf(ios::oct, ios::dec|ios::hex|ios::oct); return i; }
}  


# 13 "today.cpp" 2


 



Today::Today( QWidget* parent,  const char* name, WFlags fl )
  : TodayBase( parent, name, fl )
{
  QDate date = QDate::currentDate();
  QString text = (date.toString());
  TextLabel1->setText(text);
  db = new DateBookDB;
  getDates();
}


 



void Today::getDates()
{
 QDate date = QDate::currentDate();
 QValueList<EffectiveEvent> list = db->getEffectiveEvents(date, date);
 Config config( "qpe" );
 bool ampm = config.readBoolEntry( "AMPM", TRUE );
 

 	if ( list.count() > 0 ) {
	    QString msg;
	    for ( QValueList<EffectiveEvent>::ConstIterator it=list.begin();
		  it!=list.end(); ++it ) {
	      
	      msg += "<B>" + (*it).description() + "</B>"
		 
		+ "<BR>"
		+ TimeString::dateString((*it).event().start(),ampm)
		+ "<BR>"
		+ (*it).notes() + "";
	    }
	    DatesField->setText(msg);
	}
}


 



int Today::getTodo()
{
  QDomDocument dom;
  QDomElement tel;
  
  QFile f("todolist.xml");
  if(f.open(0x0001 ))
    {
      if(dom.setContent(&f))
	{
	  tel = dom.documentElement();
	  if(tel.tagName() == "!DOCTYPE Tasks")
	    {
	      for(QDomNode el = tel.firstChild(); !el.isNull(); el = el.nextSibling())
		{
		  cout << "ELEMENT: " << el.nodeName().latin1() << endl;
		  if(el.nodeName() == "LIGHTING")
		    {
		    }
		  else if(el.nodeName() == "MESH")
		    {
		    }
		  else cout << ("Unknown element name: " + el.nodeName() + " (in <WORLD>)");
		}
	    }
	  else
	    {
	      cout << ("Invalid root element name");
	      return 0;
	    }
	}
      else
	{
	  cout << ("Invalid data format");
	  return 0;
	}
    }
  else
    {
      cout << ("Invalid file");
      return 0;
    }
  return 1;
}


 


Today::~Today()
{
     
}

 


void Today::goodBye()
{
    close();
}
